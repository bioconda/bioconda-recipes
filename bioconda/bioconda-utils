#!/usr/bin/env python

import sys
import os
import subprocess as sp

import yaml
import argh
from argh import arg
import networkx as nx

import utils

# NOTE:
#
# A package is the name of the software package, like `bowtie`.
#
# A recipe is the path to the recipe of one version of a package, like
# `recipes/bowtie` or `recipes/bowtie/1.0.1`.


@arg('config', help='Config YAML file')
@arg('repository', help='Path to top-level dir of repository')
@arg('--packages', nargs="+",
     help='Glob for package[s] to build. Default is to build all packages. Can '
     'be specified more than once')
@arg('--testonly', help='Test packages instead of building')
@arg('--verbose', help='Make output more verbose for local debugging')
@arg('--run-setup', help='Run the setup commands listed in the config')
@arg('--force', help='Force building the recipe even if it already exists in '
     'the bioconda channel')
def build(config, repository, packages="*", testonly=False, verbose=False,
          run_setup=False, force=False, index_dirs=True):
    """
    Build one or many bioconda packages.
    """
    if run_setup:
        utils.run_setup_from_config(config)

    env_matrix = utils._env_matrix_from_config(config)

    recipes = [
        recipe for package in packages for recipe in
        utils.get_recipes(repository, package)
    ]

    if not force:
        recipes = list(utils.filter_recipes(recipes, env_matrix))

    env_matrix.verbose = verbose

    dag, name2recipes = utils.get_dag(recipes)

    print("Packages to build", file=sys.stderr)
    print(*nx.nodes(dag), file=sys.stderr, sep="\n")

    subdags_n = int(os.environ.get("SUBDAGS", 1))
    subdag_i = int(os.environ.get("SUBDAG", 0))

    # Get connected subdags and sort by nodes
    if testonly:
        # use each node as a subdag (they are grouped into equal sizes below)
        subdags = sorted([[n] for n in nx.nodes(dag)])
    else:
        # take connected components as subdags
        subdags = sorted(
            map(sorted, nx.connected_components(dag.to_undirected())))
    # chunk subdags such that we have at most subdags_n many
    if subdags_n < len(subdags):
        chunks = [[n for subdag in subdags[i::subdags_n] for n in subdag]
                  for i in range(subdags_n)]
    else:
        chunks = subdags
    if subdag_i >= len(chunks):
        print("Nothing to be done.")
        return
    # merge subdags of the selected chunk
    subdag = dag.subgraph(chunks[subdag_i])
    # ensure that packages which need a build are built in the right order
    recipes = [recipe for package in nx.topological_sort(subdag) for recipe in
               name2recipes[package]]

    print("Building/testing subdag {} of recipes in order:".format(subdag_i),
          file=sys.stderr)
    print(*recipes, file=sys.stderr, sep="\n")

    for recipe in recipes:
        for env in env_matrix:
            yield utils.build(recipe, env, verbose, testonly, force)

    if not testonly:
        # upload builds
        if (
            os.environ.get("TRAVIS_BRANCH") == "master" and
            os.environ.get("TRAVIS_PULL_REQUEST") == "false"
        ):
            for recipe in recipes:
                packages = {
                    sp.run(["conda", "build", "--output", recipe],
                           stdout=sp.PIPE, env=env,
                           check=True).stdout.strip().decode()
                    for env in env_matrix
                }
                for package in packages:
                    if os.path.exists(package):
                        try:
                            sp.run(["anaconda", "-t",
                                    os.environ.get("ANACONDA_TOKEN"),
                                    "upload", package], stdout=sp.PIPE,
                                   stderr=sp.STDOUT, check=True)
                        except sp.CalledProcessError as e:
                            print(e.stdout.decode(), file=sys.stderr)
                            if b"already exists" in e.stdout:
                                # ignore error assuming that it is caused by
                                # existing package
                                pass
                            else:
                                raise e


@arg('repository', help='Path to top-level dir of repository')
#@arg('gml', help='Output GML file. If filename ends in .gz or .bz2 it will '
#     'be compressed')
@arg('--packages', nargs="+",
     help='Glob for package[s] to show in DAG. Default is to show all '
     'packages. Can be specified more than once')
@arg('--format', choices=['gml', 'dot'], help='Set format to print graph.')
@arg('--hide-singletons', action='store_true', help='Hide singletons in the printed graph.')
def dag(repository, packages="*", format='gml', hide_singletons=False):
    """
    Export the DAG of packages to a GML-format file for visualization
    """
    dag = utils.get_dag(utils.get_recipes(repository, packages))[0]
    if hide_singletons:
        for node in nx.nodes(dag):
            if dag.degree(node) == 0:
                dag.remove_node(node)
    if format == 'gml':
        nx.write_gml(dag, sys.stdout.buffer)
    elif format == 'dot':
        from networkx.drawing.nx_pydot import write_dot
        write_dot(dag, sys.stdout)

argh.dispatch_commands([build, dag])
