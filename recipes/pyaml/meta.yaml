{% set name = "pyaml" %}
{% set version = "20.4.0" %}
{% set file_ext = "tar.gz" %}
{% set hash_type = "sha256" %}
{% set hash_value = "29a5c2a68660a799103d6949167bd6c7953d031449d08802386372de1db6ad71" %}

package:
  name: '{{ name|lower }}'
  version: '{{ version }}'

source:
  fn: '{{ name }}-{{ version }}.{{ file_ext }}'
  url: https://pypi.io/packages/source/{{ name[0] }}/{{ name }}/{{ name }}-{{ version }}.{{ file_ext }}
  '{{ hash_type }}': '{{ hash_value }}'

build:
  number: 0
  script: python setup.py install --single-version-externally-managed --record=record.txt

requirements:
  build:
    - python
    - setuptools
    - pyyaml
  run:
    - python
    - pyyaml

test:
  imports:
    - pyaml
    - pyaml.tests

about:
  home: https://github.com/mk-fg/pretty-yaml
  license: WTFPL
  license_family: OTHER
  license_file: ''
  summary: PyYAML-based module to produce pretty and readable YAML-serialized data
  description: "pretty-yaml (or pyaml)\n======================\n\nPyYAML-based python module to produce pretty and readable YAML-serialized data.\n\nThis module is for serialization only, see `ruamel.yaml`_\
    \ module for literate\nYAML parsing (keeping track of comments, spacing, line/column numbers of values, etc).\n\n[note: to dump stuff parsed by ruamel.yaml with this module, use only ``YAML(typ='safe')``\
    \ there]\n\n.. contents::\n  :backlinks: none\n\n\nWarning\n-------\n\nPrime goal of this module is to produce human-readable output that can be easily\nmanipulated and re-used, but maybe with some\
    \ occasional caveats.\n\nOne good example of such \"caveat\" is that e.g. ``{'foo': '123'}`` will serialize\nto ``foo: 123``, which for PyYAML would be a bug, as 123 will then be read back\nas an integer\
    \ from that, but here it's a feature.\n\nSo please do not rely on the thing to produce output that can always be\ndeserialized exactly to what was exported, at least - use PyYAML (e.g. with\noptions\
    \ from the next section) for that.\n\n\nWhat this module does and why\n-----------------------------\n\nYAML is generally nice and easy format to read *if* it was written by humans.\n\nPyYAML can a\
    \ do fairly decent job of making stuff readable, and the best\ncombination of parameters for such output that I've seen so far is probably this one::\n\n  >>> m = [123, 45.67, {1: None, 2: False}, u'some\
    \ text']\n  >>> data = dict(a=u'asldnsa\\nasldp\xE1knsa\\n', b=u'whatever text', ma=m, mb=m)\n  >>> yaml.safe_dump(data, sys.stdout, allow_unicode=True, default_flow_style=False)\n  a: 'asldnsa\n\n\
    \    asldp\xE1knsa\n\n    '\n  b: whatever text\n  ma: &id001\n  - 123\n  - 45.67\n  - 1: null\n    2: false\n  - some text\n  mb: *id001\n\npyaml tries to improve on that a bit, with the following\
    \ tweaks:\n\n* Most human-friendly representation options in PyYAML (that I know of) get\n  picked as defaults.\n\n* Does not dump \"null\" values, if possible, replacing these with just empty\n  strings,\
    \ which have the same meaning but reduce visual clutter and are easier\n  to edit.\n\n* Dicts, sets, OrderedDicts, defaultdicts, namedtuples, etc are representable\n  and get sorted on output (OrderedDicts\
    \ and namedtuples keep their ordering),\n  so that output would be as diff-friendly as possible, and not arbitrarily\n  depend on python internals.\n\n  It appears that at least recent PyYAML versions\
    \ also do such sorting for\n  python dicts.\n\n* List items get indented, as they should be.\n\n* bytestrings that can't be auto-converted to unicode raise error, as yaml has\n  no \"binary bytes\"\
    \ (i.e. unix strings) type.\n\n* Attempt is made to pick more readable string representation styles, depending\n  on the value, e.g.::\n\n    >>> yaml.safe_dump(cert, sys.stdout)\n    cert: '-----BEGIN\
    \ CERTIFICATE-----\n\n      MIIH3jCCBcagAwIBAgIJAJi7AjQ4Z87OMA0GCSqGSIb3DQEBCwUAMIHBMRcwFQYD\n\n      VQQKFA52YWxlcm9uLm5vX2lzcDEeMBwGA1UECxMVQ2VydGlmaWNhdGUgQXV0aG9y\n    ...\n\n    >>> pyaml.p(cert):\n\
    \    cert: |\n      -----BEGIN CERTIFICATE-----\n      MIIH3jCCBcagAwIBAgIJAJi7AjQ4Z87OMA0GCSqGSIb3DQEBCwUAMIHBMRcwFQYD\n      VQQKFA52YWxlcm9uLm5vX2lzcDEeMBwGA1UECxMVQ2VydGlmaWNhdGUgQXV0aG9y\n    ...\n\
    \n* \"force_embed\" option to avoid having &id stuff scattered all over the output\n  (which might be beneficial in some cases, hence the option).\n\n* \"&id\" anchors, if used, get labels from the\
    \ keys they get attached to,\n  not just use meaningless enumerators.\n\n* \"string_val_style\" option to only apply to strings that are values, not keys,\n  i.e::\n\n    >>> pyaml.p(data, string_val_style='\"\
    ')\n    key: \"value\\nasldp\xE1knsa\\n\"\n    >>> yaml.safe_dump(data, sys.stdout, allow_unicode=True, default_style='\"')\n    \"key\": \"value\\nasldp\xE1knsa\\n\"\n\n* \"sort_dicts=False\" option\
    \ to leave dict item ordering to python, and not\n  force-sort them in yaml output, which can be important for python 3.6+ where\n  they retain ordering info.\n\n* Has an option to add vertical spacing\
    \ (empty lines) between keys on different\n  depths, to make output much more seekable.\n\nResult for the (rather meaningless) example above (without any additional\ntweaks)::\n\n  >>> pyaml.p(data)\n\
    \  a: |\n    asldnsa\n    asldp\xE1knsa\n  b: 'whatever text'\n  ma: &ma\n    - 123\n    - 45.67\n    - 1:\n      2: false\n    - 'some text'\n  mb: *ma\n\n----------\n\nExtended example::\n\n  >>>\
    \ pyaml.dump(conf, sys.stdout, vspacing=[2, 1]):\n  destination:\n\n    encoding:\n      xz:\n        enabled: true\n        min_size: 5120\n        options:\n        path_filter:\n          - \\.(gz|bz2|t[gb]z2?|xz|lzma|7z|zip|rar)$\n\
    \          - \\.(rpm|deb|iso)$\n          - \\.(jpe?g|gif|png|mov|avi|ogg|mkv|webm|mp[34g]|flv|flac|ape|pdf|djvu)$\n          - \\.(sqlite3?|fossil|fsl)$\n          - \\.git/objects/[0-9a-f]+/[0-9a-f]+$\n\
    \n    result:\n      append_to_file:\n      append_to_lafs_dir:\n      print_to_stdout: true\n\n    url: http://localhost:3456/uri\n\n\n  filter:\n    - /(CVS|RCS|SCCS|_darcs|\\{arch\\})/$\n    - /\\\
    .(git|hg|bzr|svn|cvs)(/|ignore|attributes|tags)?$\n    - /=(RELEASE-ID|meta-update|update)$\n\n\n  http:\n\n    ca_certs_files: /etc/ssl/certs/ca-certificates.crt\n\n    debug_requests: false\n\n  \
    \  request_pool_options:\n      cachedConnectionTimeout: 600\n      maxPersistentPerHost: 10\n      retryAutomatically: true\n\n\n  logging:\n\n    formatters:\n      basic:\n        datefmt: '%Y-%m-%d\
    \ %H:%M:%S'\n        format: '%(asctime)s :: %(name)s :: %(levelname)s: %(message)s'\n\n    handlers:\n      console:\n        class: logging.StreamHandler\n        formatter: basic\n        level:\
    \ custom\n        stream: ext://sys.stderr\n\n    loggers:\n      twisted:\n        handlers:\n          - console\n        level: 0\n\n    root:\n      handlers:\n        - console\n      level: custom\n\
    \nNote that unless there are many moderately wide and deep trees of data, which\nare expected to be read and edited by people, it might be preferrable to\ndirectly use PyYAML regardless, as it won't\
    \ introduce another (rather pointless\nin that case) dependency and a point of failure.\n\n\nSome Tricks\n-----------\n\n* Pretty-print any yaml or json (yaml subset) file from the shell::\n\n    %\
    \ python -m pyaml /path/to/some/file.yaml\n    % curl -s https://www.githubstatus.com/api/v2/summary.json | python -m pyaml\n\n* Process and replace json/yaml file in-place::\n\n    % python -m pyaml\
    \ -r file-with-json.data\n\n* Easier \"debug printf\" for more complex data (all funcs below are aliases to\n  same thing)::\n\n    pyaml.p(stuff)\n    pyaml.pprint(my_data)\n    pyaml.pprint('-----\
    \ HOW DOES THAT BREAKS!?!?', input_data, some_var, more_stuff)\n    pyaml.print(data, file=sys.stderr) # needs \"from __future__ import print_function\"\n\n* Force all string values to a certain style\
    \ (see info on these in\n  `PyYAML docs`_)::\n\n    pyaml.dump(many_weird_strings, string_val_style='|')\n    pyaml.dump(multiline_words, string_val_style='>')\n    pyaml.dump(no_want_quotes, string_val_style='plain')\n\
    \n  Using ``pyaml.add_representer()`` (note \\*p\\*yaml) as suggested in\n  `this SO thread`_ (or `github-issue-7`_) should also work.\n\n* Control indent and width of the results::\n\n    pyaml.dump(wide_and_deep,\
    \ indent=4, width=120)\n\n  These are actually keywords for PyYAML Emitter (passed to it from Dumper),\n  see more info on these in `PyYAML docs`_.\n\n* Dump multiple yaml documents into a file: ``pyaml.dump_all([data1,\
    \ data2, data3], dst_file)``\n\n  explicit_start=True is implied, unless explicit_start=False is passed.\n\n.. _PyYAML docs: http://pyyaml.org/wiki/PyYAMLDocumentation#Scalars\n.. _this SO thread: http://stackoverflow.com/a/7445560\n\
    .. _github-issue-7: https://github.com/mk-fg/pretty-yaml/issues/7\n\n\nInstallation\n------------\n\nIt's a regular package for Python (3.x or 2.x).\n\nModule uses PyYAML_ for processing of the actual\
    \ YAML files and should pull it\nin as a dependency.\n\nDependency on unidecode_ module is optional and should only be necessary if\nsame-id objects or recursion is used within serialized data.\n\n\
    Be sure to use python3/python2, pip3/pip2, easy_install-... binaries below,\nbased on which python version you want to install the module for, if you have\nseveral on the system (as is norm these days\
    \ for py2-py3 transition).\n\nUsing pip_ is the best way::\n\n  % pip install pyaml\n\n(add --user option to install into $HOME for current user only)\n\nOr, if you don't have \"pip\" command::\n\n\
    \  % python -m ensurepip\n  % python -m pip install --upgrade pip\n  % python -m pip install pyaml\n\n(same suggestion wrt \"install --user\" as above)\n\nOn a very old systems, one of these might work::\n\
    \n  % curl https://bootstrap.pypa.io/get-pip.py | python\n  % pip install pyaml\n\n  % easy_install pyaml\n\n  % git clone --depth=1 https://github.com/mk-fg/pretty-yaml\n  % cd pretty-yaml\n  % python\
    \ setup.py install\n\n(all of install-commands here also have --user option,\nsee also `pip docs \"installing\" section`_)\n\nCurrent-git version can be installed like this::\n\n  % pip install 'git+https://github.com/mk-fg/pretty-yaml#egg=pyaml'\n\
    \nNote that to install stuff to system-wide PATH and site-packages (without\n--user), elevated privileges (i.e. root and su/sudo) are often required.\n\nUse \"...install --user\", `~/.pydistutils.cfg`_\
    \ or virtualenv_ to do unprivileged\ninstalls into custom paths.\n\nMore info on python packaging can be found at `packaging.python.org`_.\n\n.. _ruamel.yaml: https://bitbucket.org/ruamel/yaml/\n..\
    \ _PyYAML: http://pyyaml.org/\n.. _unidecode: http://pypi.python.org/pypi/Unidecode\n.. _pip: http://pip-installer.org/\n.. _pip docs \"installing\" section: http://www.pip-installer.org/en/latest/installing.html\n\
    .. _~/.pydistutils.cfg: http://docs.python.org/install/index.html#distutils-configuration-files\n.. _virtualenv: http://pypi.python.org/pypi/virtualenv\n.. _packaging.python.org: https://packaging.python.org/installing/\n"
  doc_url: ''
  dev_url: ''

extra:
  recipe-maintainers: ''
