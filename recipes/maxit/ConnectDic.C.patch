diff --git a/connect-v3.3/src/ConnectDic.C b/connect-v3.3/src/ConnectDic.C
index 283bebd..1950cd9 100644
--- a/connect-v3.3/src/ConnectDic.C
+++ b/connect-v3.3/src/ConnectDic.C
@@ -30,64 +30,64 @@ not limited to, any and all claims alleging products liability.
 /*
                RCSB PDB SOFTWARE LICENSE AGREEMENT
 
-BY CLICKING THE ACCEPTANCE BUTTON OR INSTALLING OR USING 
-THIS "SOFTWARE, THE INDIVIDUAL OR ENTITY LICENSING THE  
-SOFTWARE ("LICENSEE") IS CONSENTING TO BE BOUND BY AND IS 
-BECOMING A PARTY TO THIS AGREEMENT.  IF LICENSEE DOES NOT 
+BY CLICKING THE ACCEPTANCE BUTTON OR INSTALLING OR USING
+THIS "SOFTWARE, THE INDIVIDUAL OR ENTITY LICENSING THE
+SOFTWARE ("LICENSEE") IS CONSENTING TO BE BOUND BY AND IS
+BECOMING A PARTY TO THIS AGREEMENT.  IF LICENSEE DOES NOT
 AGREE TO ALL OF THE TERMS OF THIS AGREEMENT
 THE LICENSEE MUST NOT INSTALL OR USE THE SOFTWARE.
 
 1. LICENSE AGREEMENT
 
-This is a license between you ("Licensee") and the Protein Data Bank (PDB) 
-at Rutgers, The State University of New Jersey (hereafter referred to 
-as "RUTGERS").   The software is owned by RUTGERS and protected by 
-copyright laws, and some elements are protected by laws governing 
-trademarks, trade dress and trade secrets, and may be protected by 
-patent laws. 
+This is a license between you ("Licensee") and the Protein Data Bank (PDB)
+at Rutgers, The State University of New Jersey (hereafter referred to
+as "RUTGERS").   The software is owned by RUTGERS and protected by
+copyright laws, and some elements are protected by laws governing
+trademarks, trade dress and trade secrets, and may be protected by
+patent laws.
 
 2. LICENSE GRANT
 
-RUTGERS grants you, and you hereby accept, non-exclusive, royalty-free 
-perpetual license to install, use, modify, prepare derivative works, 
-incorporate into other computer software, and distribute in binary 
-and source code format, or any derivative work thereof, together with 
-any associated media, printed materials, and on-line or electronic 
-documentation (if any) provided by RUTGERS (collectively, the "SOFTWARE"), 
-subject to the following terms and conditions: (i) any distribution 
-of the SOFTWARE shall bind the receiver to the terms and conditions 
-of this Agreement; (ii) any distribution of the SOFTWARE in modified 
-form shall clearly state that the SOFTWARE has been modified from 
-the version originally obtained from RUTGERS.  
-
-2. COPYRIGHT; RETENTION OF RIGHTS.  
-
-The above license grant is conditioned on the following: (i) you must 
-reproduce all copyright notices and other proprietary notices on any 
-copies of the SOFTWARE and you must not remove such notices; (ii) in 
-the event you compile the SOFTWARE, you will include the copyright 
-notice with the binary in such a manner as to allow it to be easily 
-viewable; (iii) if you incorporate the SOFTWARE into other code, you 
-must provide notice that the code contains the SOFTWARE and include 
-a copy of the copyright notices and other proprietary notices.  All 
-copies of the SOFTWARE shall be subject to the terms of this Agreement.  
-
-3. NO MAINTENANCE OR SUPPORT; TREATMENT OF ENHANCEMENTS 
-
-RUTGERS is under no obligation whatsoever to: (i) provide maintenance 
-or support for the SOFTWARE; or (ii) to notify you of bug fixes, patches, 
-or upgrades to the features, functionality or performance of the 
-SOFTWARE ("Enhancements") (if any), whether developed by RUTGERS 
-or third parties.  If, in its sole discretion, RUTGERS makes an 
-Enhancement available to you and RUTGERS does not separately enter 
-into a written license agreement with you relating to such bug fix, 
-patch or upgrade, then it shall be deemed incorporated into the SOFTWARE 
-and subject to this Agreement. You are under no obligation whatsoever 
-to provide any Enhancements to RUTGERS or the public that you may 
-develop over time; however, if you choose to provide your Enhancements 
-to RUTGERS, or if you choose to otherwise publish or distribute your 
-Enhancements, in source code form without contemporaneously requiring 
-end users or RUTGERS to enter into a separate written license agreement 
+RUTGERS grants you, and you hereby accept, non-exclusive, royalty-free
+perpetual license to install, use, modify, prepare derivative works,
+incorporate into other computer software, and distribute in binary
+and source code format, or any derivative work thereof, together with
+any associated media, printed materials, and on-line or electronic
+documentation (if any) provided by RUTGERS (collectively, the "SOFTWARE"),
+subject to the following terms and conditions: (i) any distribution
+of the SOFTWARE shall bind the receiver to the terms and conditions
+of this Agreement; (ii) any distribution of the SOFTWARE in modified
+form shall clearly state that the SOFTWARE has been modified from
+the version originally obtained from RUTGERS.
+
+2. COPYRIGHT; RETENTION OF RIGHTS.
+
+The above license grant is conditioned on the following: (i) you must
+reproduce all copyright notices and other proprietary notices on any
+copies of the SOFTWARE and you must not remove such notices; (ii) in
+the event you compile the SOFTWARE, you will include the copyright
+notice with the binary in such a manner as to allow it to be easily
+viewable; (iii) if you incorporate the SOFTWARE into other code, you
+must provide notice that the code contains the SOFTWARE and include
+a copy of the copyright notices and other proprietary notices.  All
+copies of the SOFTWARE shall be subject to the terms of this Agreement.
+
+3. NO MAINTENANCE OR SUPPORT; TREATMENT OF ENHANCEMENTS
+
+RUTGERS is under no obligation whatsoever to: (i) provide maintenance
+or support for the SOFTWARE; or (ii) to notify you of bug fixes, patches,
+or upgrades to the features, functionality or performance of the
+SOFTWARE ("Enhancements") (if any), whether developed by RUTGERS
+or third parties.  If, in its sole discretion, RUTGERS makes an
+Enhancement available to you and RUTGERS does not separately enter
+into a written license agreement with you relating to such bug fix,
+patch or upgrade, then it shall be deemed incorporated into the SOFTWARE
+and subject to this Agreement. You are under no obligation whatsoever
+to provide any Enhancements to RUTGERS or the public that you may
+develop over time; however, if you choose to provide your Enhancements
+to RUTGERS, or if you choose to otherwise publish or distribute your
+Enhancements, in source code form without contemporaneously requiring
+end users or RUTGERS to enter into a separate written license agreement
 for such Enhancements, then you hereby grant RUTGERS a non-exclusive,
 royalty-free perpetual license to install, use, modify, prepare
 derivative works, incorporate into the SOFTWARE or other computer
@@ -105,37 +105,37 @@ and conditions.  Upon termination, Licensee shall destroy all
 copies of the SOFTWARE.
 
 6. PROPRIETARY RIGHTS.  Title, ownership rights, and intellectual
-property rights in the Product shall remain with RUTGERS.  Licensee 
-acknowledges such ownership and intellectual property rights and will 
-not take any action to jeopardize, limit or interfere in any manner 
-with RUTGERS' ownership of or rights with respect to the SOFTWARE.  
-The SOFTWARE is protected by copyright and other intellectual 
-property laws and by international treaties.  Title and related 
-rights in the content accessed through the SOFTWARE is the property 
-of the applicable content owner and is protected by applicable law.  
+property rights in the Product shall remain with RUTGERS.  Licensee
+acknowledges such ownership and intellectual property rights and will
+not take any action to jeopardize, limit or interfere in any manner
+with RUTGERS' ownership of or rights with respect to the SOFTWARE.
+The SOFTWARE is protected by copyright and other intellectual
+property laws and by international treaties.  Title and related
+rights in the content accessed through the SOFTWARE is the property
+of the applicable content owner and is protected by applicable law.
 The license granted under this Agreement gives Licensee no rights to such
 content.
 
-7. DISCLAIMER OF WARRANTY.  THE SOFTWARE IS PROVIDED FREE OF 
-CHARGE, AND, THEREFORE, ON AN "AS IS" BASIS, WITHOUT WARRANTY OF 
-ANY KIND, INCLUDING WITHOUT LIMITATION THE WARRANTIES THAT IT 
-IS FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE 
-OR NON-INFRINGING.  THE ENTIRE RISK AS TO THE QUALITY AND 
-PERFORMANCE OF THE SOFTWARE IS BORNE BY LICENSEE.  SHOULD THE 
-SOFTWARE PROVE DEFECTIVE IN ANY RESPECT, THE LICENSEE AND NOT 
-LICENSOR ASSUMES THE ENTIRE COST OF ANY SERVICE AND REPAIR.  
-THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF 
-THIS AGREEMENT.  NO USE OF THE PRODUCT IS AUTHORIZED HEREUNDER 
+7. DISCLAIMER OF WARRANTY.  THE SOFTWARE IS PROVIDED FREE OF
+CHARGE, AND, THEREFORE, ON AN "AS IS" BASIS, WITHOUT WARRANTY OF
+ANY KIND, INCLUDING WITHOUT LIMITATION THE WARRANTIES THAT IT
+IS FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE
+OR NON-INFRINGING.  THE ENTIRE RISK AS TO THE QUALITY AND
+PERFORMANCE OF THE SOFTWARE IS BORNE BY LICENSEE.  SHOULD THE
+SOFTWARE PROVE DEFECTIVE IN ANY RESPECT, THE LICENSEE AND NOT
+LICENSOR ASSUMES THE ENTIRE COST OF ANY SERVICE AND REPAIR.
+THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF
+THIS AGREEMENT.  NO USE OF THE PRODUCT IS AUTHORIZED HEREUNDER
 EXCEPT UNDER THIS DISCLAIMER.
 
 8. LIMITATION OF LIABILITY.  TO THE MAXIMUM EXTENT PERMITTED BY
-APPLICABLE LAW,  IN NO EVENT WILL LICENSOR BE LIABLE FOR ANY 
-INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING 
-OUT OF THE USE OF OR INABILITY TO USE THE SOFTWARE, INCLUDING, 
-WITHOUT LIMITATION, DAMAGES FOR LOSS OF GOODWILL, WORK 
-STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL 
+APPLICABLE LAW,  IN NO EVENT WILL LICENSOR BE LIABLE FOR ANY
+INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OF OR INABILITY TO USE THE SOFTWARE, INCLUDING,
+WITHOUT LIMITATION, DAMAGES FOR LOSS OF GOODWILL, WORK
+STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL
 OTHER COMMERCIAL DAMAGES OR LOSSES, EVEN IF ADVISED OF THE
-POSSIBILITY THEREOF. 
+POSSIBILITY THEREOF.
 */
 
 /*!
@@ -144,6 +144,11 @@ POSSIBILITY THEREOF.
 ** \brief Implementation file for ConnectDic class.
 */
 
+#include <iostream>
+#include <memory>
+#include <string>
+#include <vector>
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/stat.h>
@@ -395,7 +400,7 @@ bool ConnectDic::OpenFile()
                       for (unsigned int i = 0; i < blockNames.size(); ++i) {
                            if (blockNames[i] == "INDEX" ||
                                blockNames[i] == "OBSOLETE") continue;
-               
+
                            Block &block = fobj->GetBlock(blockNames[i]);
                            add_drug(block);
                       }
@@ -525,7 +530,7 @@ const int ConnectDic::find_monomer_type(const std::string& residueName)
 
 const std::string ConnectDic::getAtomType(const std::string& drugID, const std::string& atomName)
 {
-       try { 
+       try {
             const ConnectFormat& drug = find_drug(drugID);
             const AtomFormat& atom = drug.find_atom(atomName);
             return atom.atomtype();
@@ -536,7 +541,7 @@ const std::string ConnectDic::getAtomType(const std::string& drugID, const std::
 
 const double ConnectDic::get_molecule_weight(const std::string& drugID)
 {
-       try { 
+       try {
             const ConnectFormat& drug = find_drug(drugID);
 /*
             if ((drugID == "ARG") || (drugID == "HIS") || (drugID == "LYS"))
@@ -549,7 +554,7 @@ const double ConnectDic::get_molecule_weight(const std::string& drugID)
 
 bool ConnectDic::is_L_aa_residue(const std::string& drugID)
 {
-       try { 
+       try {
             const ConnectFormat& drug = find_drug(drugID);
             if (String::IsEqual(drug.getMetaData("type"), "L-peptide linking", Char::eCASE_INSENSITIVE)) return true;
             return false;
@@ -560,7 +565,7 @@ bool ConnectDic::is_L_aa_residue(const std::string& drugID)
 
 bool ConnectDic::is_D_aa_residue(const std::string& drugID)
 {
-       try { 
+       try {
             const ConnectFormat& drug = find_drug(drugID);
             if (String::IsEqual(drug.getMetaData("type"), "D-peptide linking", Char::eCASE_INSENSITIVE)) return true;
             return false;
@@ -663,7 +668,7 @@ void ConnectDic::find_drugs(const std::string &drugID, std::vector<ConnectFormat
 {
        drug_list.clear();
 
-       try { 
+       try {
             const ConnectFormat& drug = find_drug(drugID);
             drug_list.push_back(drug);
 
@@ -680,7 +685,7 @@ void ConnectDic::find_variants(const std::string &drugID, std::vector<ConnectFor
 {
        drug_list.clear();
 
-       try { 
+       try {
             const ConnectFormat& drug = find_drug(drugID);
 
             std::pair<std::multimap<std::string, int>::iterator, std::multimap<std::string, int>::iterator> range = _VariantConnMap.equal_range(drugID);
@@ -694,7 +699,7 @@ void ConnectDic::find_variants(const std::string &drugID, std::vector<ConnectFor
 
 const std::set<std::string>& ConnectDic::get_connected_atoms(const std::string& drugID)
 {
-       try { 
+       try {
             const ConnectFormat& drug = find_drug(drugID);
             return drug.getTerminalConnectedAtoms();
        } catch (const std::exception& exc) {}
@@ -703,72 +708,81 @@ const std::set<std::string>& ConnectDic::get_connected_atoms(const std::string&
 
 bool ConnectDic::BinaryConvertor(const std::string& textfile, const std::string& binaryfile)
 {
-       std::string cs;
-       _fObj = read_cif_file(binaryfile, textfile, cs);
-       if (!cs.empty()) {
-            fprintf(stdout, "Read %s failed\n\n%s\n", textfile.c_str(), cs.c_str());
-            if (_fObj) delete _fObj;
-            return false;
-       }
+    std::string cs;
 
-       ISTable *Table = new ISTable("index");
-       Table->AddColumn("id");
-       Table->AddColumn("formula");
-       Table->AddColumn("subcomponent_list");
-       Table->AddColumn("three_letter_code");
-       ISTable *Table1 = new ISTable("obsolete");
-       Table1->AddColumn("id");
-       Table1->AddColumn("supercede");
-
-       int row = 0;
-       int row1 = 0;
-       std::vector<std::string> blockNames;
-       _fObj->GetBlockNames(blockNames);
-       for (unsigned int i = 0; i < blockNames.size(); ++i) {
-            Block &block = _fObj->GetBlock(blockNames[i]);
-            ISTable *t = getTablePtr(block, "chem_comp");
-            if (!t) continue;
-
-            Table->AddRow();
-            get_value_clean(cs, t, 0, "id");
-            Table->UpdateCell(row, "id", cs);
-            get_value_clean(cs, t, 0, "formula");
-            Table->UpdateCell(row, "formula", cs);
-            get_value_clean(cs, t, 0, "pdbx_subcomponent_list");
-            Table->UpdateCell(row, "subcomponent_list", cs);
-            get_value_clean(cs, t, 0, "three_letter_code");
-            Table->UpdateCell(row, "three_letter_code", cs);
-            row++;
-
-            get_value_clean_upper(cs, t, 0, "pdbx_release_status");
-            if (cs == "OBS") {
-                 Table1->AddRow();
-                 get_value_clean(cs, t, 0, "id");
-                 Table1->UpdateCell(row1, "id", cs);
-                 get_value_clean(cs, t, 0, "pdbx_replaced_by");
-                 Table1->UpdateCell(row1, "supercede", cs);
-                 row1++;
-            }
-       }
+    _fObj = read_cif_file(binaryfile, textfile, cs);
 
-       _fObj->AddBlock("INDEX");
-       Block &block = _fObj->GetBlock("INDEX");
-       block.WriteTable(Table);
+    // Check if there was an error during file read
+    if (!cs.empty()) {
+        fprintf(stdout, "Read %s failed\n\n%s\n", textfile.c_str(), cs.c_str());
+        if (_fObj) delete _fObj;
+        return false;
+    }
 
-       _fObj->AddBlock("OBSOLETE");
-       Block &block1 = _fObj->GetBlock("OBSOLETE");
-       block1.WriteTable(Table1);
+    // Use smart pointers to manage memory automatically
+    std::unique_ptr<ISTable> Table(new ISTable("index"));
+    Table->AddColumn("id");
+    Table->AddColumn("formula");
+    Table->AddColumn("subcomponent_list");
+    Table->AddColumn("three_letter_code");
 
-       _fObj->Close();
+    std::unique_ptr<ISTable> Table1(new ISTable("obsolete"));
+    Table1->AddColumn("id");
+    Table1->AddColumn("supercede");
 
-       return true;
-}
+    int row = 0;
+    int row1 = 0;
+    std::vector<std::string> blockNames;
+
+    _fObj->GetBlockNames(blockNames);
+
+    for (const auto& blockName : blockNames) {
+        Block& block = _fObj->GetBlock(blockName);
+
+        // Use smart pointer to ensure table memory is managed automatically
+        std::unique_ptr<ISTable> t(getTablePtr(block, "chem_comp"));
+        if (!t) continue;
+
+        Table->AddRow();
+        get_value_clean(cs, t.get(), 0, "id");
+        Table->UpdateCell(row, "id", cs);
+        get_value_clean(cs, t.get(), 0, "formula");
+        Table->UpdateCell(row, "formula", cs);
+        get_value_clean(cs, t.get(), 0, "pdbx_subcomponent_list");
+        Table->UpdateCell(row, "subcomponent_list", cs);
+        get_value_clean(cs, t.get(), 0, "three_letter_code");
+        Table->UpdateCell(row, "three_letter_code", cs);
+        row++;
 
+        get_value_clean_upper(cs, t.get(), 0, "pdbx_release_status");
+        if (cs == "OBS") {
+            Table1->AddRow();
+            get_value_clean(cs, t.get(), 0, "id");
+            Table1->UpdateCell(row1, "id", cs);
+            get_value_clean(cs, t.get(), 0, "pdbx_replaced_by");
+            Table1->UpdateCell(row1, "supercede", cs);
+            row1++;
+        }
 
+        t.reset();
+    }
+
+    _fObj->AddBlock("INDEX");
+    Block& block = _fObj->GetBlock("INDEX");
+    block.WriteTable(Table.get());
+
+    _fObj->AddBlock("OBSOLETE");
+    Block& block1 = _fObj->GetBlock("OBSOLETE");
+    block1.WriteTable(Table1.get());
+
+    _fObj->Close();
+
+    return true;
+}
 
 bool ConnectDic::hasValidPhosphorylGroup(const std::string& drugID)
 {
-       try { 
+       try {
             const ConnectFormat& drug = find_drug(drugID);
             if (drug.hasValidPhosphorylGroup()) return true;
             return false;
