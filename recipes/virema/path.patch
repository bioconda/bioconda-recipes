--- ViReMa_0.6/ViReMa.py	2014-06-25 12:43:38.000000000 +0000
+++ ViReMa_0.6/ViReMa.py.new	2017-09-09 01:48:14.028354189 +0000
@@ -1,580 +1,1162 @@
-##      Copyright (c) 2013-2014 Andrew Laurence Routh
-##      
-##      Permission is hereby granted, free of charge, to any person obtaining a copy
-##      of this software and associated documentation files (the "Software"), to deal
-##      in the Software without restriction, including without limitation the rights
-##      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-##      copies of the Software, and to permit persons to whom the Software is
-##      furnished to do so, subject to the following conditions:
-##      
-##      The above copyright notice and this permission notice shall be included in
-##      all copies or substantial portions of the Software.
-##      
-##      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-##      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-##      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-##      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-##      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-##      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-##      THE SOFTWARE.
-##
-##      ----------------------------------------------------------------------------------------
-print '\n-------------------------------------------------------------------------------------------'
-print 'ViReMa Version 0.6 - written by Andrew Routh'
-print 'Last modified 6/6/2014'
-print '-------------------------------------------------------------------------------------------'
-##      ----------------------------------------------------------------------------------------
-
-import time
-start = time.time()
-from subprocess import call
-from re import findall
-import argparse
-from Compiler_Module import *
-import ConfigViReMa as cfgvars
-from os import makedirs
-from os.path import exists
-import sys
-
-##      -------------------------------------------------------------------------------------------
-##      Take arguments from command line, and send them to the config file for cross-module access
-##      -------------------------------------------------------------------------------------------
-
-if __name__ =='__main__':
-        parser = argparse.ArgumentParser()
-        parser.add_argument("Virus_Index", help="Virus genome reference index key. e.g. FHV_Genome")
-        parser.add_argument("--Host_Index", help="Host genome reference index key, e.g. d_melanogaster_fb5_22")
-        parser.add_argument("Input_Data", help= "File containing single reads in FASTQ format")
-        parser.add_argument("Output_Data", help= "Destination file for results")
-	parser.add_argument("--N", help= "Number of mismatches tolerated in mapped seed and in mapped segments. Default is 1.")
-	parser.add_argument("--Seed", help="Number of nucleotides in the Seed region. Default is 25.")
-	parser.add_argument("--ThreePad", help="Number of nucleotides not allowed to have mismatches at 3' end of segment. Default is 5.")
-	parser.add_argument("--FivePad", help="Number of nucleotides not allowed to have mismatches at 5' end of segment. Default is 5.")
-	parser.add_argument("--X", help="Number of nucleotides not allowed to have mismatches at 3' end and 5' of segment. Overrides seperate ThreePad and FivePad settings. Default is 5.")
-        parser.add_argument("--Host_Seed", help="Number of nucleotides in the Seed region when mapping to the Host Genome. Default is same as Seed value.")
-        parser.add_argument("-F", action='store_true', help="Select '-F' if data is in FASTA format fasta. Default is FASTQ.")
-        parser.add_argument("--Defuzz", help="Choose how to defuzz data:  '5' to report at 5' end of fuzzy region, '3' to report at 3' end, or '0' to report in centre of fuzzy region. Default is no fuzz handling (similar to choosing Right - see Routh et al).")
-        parser.add_argument("--MaxFuzz", help="Select maximum allowed length of fuzzy region. Recombination events with longer fuzzy regions will not be reported. Default is Seed Length.")
-	parser.add_argument("-DeDup", action='store_true', help="Remove potential PCR duplicates. Default is 'off'.")
-        parser.add_argument("-ReadNamesEntry", action='store_true', help="Append Read Names contributing to each compiled result. Default is off.")
-        parser.add_argument("--MicroInDel_Length", help= "Size of MicroInDels - these are common artifacts of cDNA preparation.  See Routh et al JMB 2012. Default size is 0)")
-        parser.add_argument("--Compound_Handling", help= "Select this option for compound recombination event mapping (see manual for details). Enter number of nucleotides to map (must be less than Seed, and greater than number of nts in MicroInDel). Default is off.")
-        parser.add_argument("--Output_Tag", help= "Enter a tag name that will be appended to end of each output file.")
-        parser.add_argument("--Output_Dir", help= "Enter a directory name that all compiled output files will be saved in.")
-        parser.add_argument("--p", help= "Enter number of available processors. Default is 1.")
-        parser.add_argument("--Chunk", help= "Enter number of reads to process together.")
-	parser.add_argument("--Aligner", help="Enter Alignment Software: 'bwa', 'bowtie'. Default is bowtie.")
-        parser.add_argument("-No_Compile", action='store_true', help= "Select this option if you do not wish to compile the results file into.  Maybe useful when combining results from different datasets.")
-        parser.add_argument("-BED", action='store_true', help= "Output recombination data into BED files.")
-        parser.add_argument("-Win", action='store_true', help= "Select this option if running ViReMa from a Windows/Cygwin shell.")
-        args = parser.parse_args()
-
-        cfgvars.Lib1 = str(args.Virus_Index)
-        if args.Host_Index:
-                cfgvars.Lib2 = str(args.Host_Index)
-        else:
-                cfgvars.Lib2 = None
-        cfgvars.File1 = str(args.Input_Data)
-        if not exists(str(args.Output_Data)):
-                        cfgvars.File2 = str(args.Output_Data)
-        else:
-                        print "Output File already exists!  Appending time to directory name to prevent overwrite."
-                        cfgvars.File2 = str(args.Output_Data) + str(int(time.time()))
-        if args.F:	
-		cfgvars.ReadType = '-f'
-	else: 
-		cfgvars.ReadType = '-q'
-        if args.Seed:
-                cfgvars.Seed = int(args.Seed)
-        else:
-                cfgvars.Seed = 25
-	if args.N:
-		cfgvars.Mismatches = int(args.N)
-	else:
-		cfgvars.Mismatches = 1
-        if args.Compound_Handling:
-                cfgvars.Compound_Handling = str(args.Compound_Handling)
-        else:
-                cfgvars.Compound_Handling = ''
-        if args.MicroInDel_Length:
-                cfgvars.MicroInDel_Length = int(args.MicroInDel_Length)
-        else:
-                cfgvars.MicroInDel_Length = 0
-	if args.ThreePad:
-		cfgvars.ThreePad = int(args.ThreePad)
-	else:
-		cfgvars.ThreePad = 5
-	if args.FivePad:
-		cfgvars.FivePad = int(args.FivePad)
-	else:
-		cfgvars.FivePad = 5
-	if args.X:
-                cfgvars.FivePad = int(args.X)
-                cfgvars.ThreePad = int(args.X)
-        else:
-                pass
-        if args.p:
-                cfgvars.Threads = str(args.p)
-        else:
-                cfgvars.Threads = '1'
-        if args.Output_Tag:
-                cfgvars.FileTag = str(args.Output_Tag) + "_"
-        else:
-                cfgvars.FileTag = ''
-        if args.Defuzz == '3':
-		cfgvars.Defuzz = 'Right'
-	elif args.Defuzz == '5':
-		cfgvars.Defuzz = 'Left'
-	elif args.Defuzz == '0':
-		cfgvars.Defuzz = 'Centre'
-        else:
-                cfgvars.Defuzz = False
-        if args.MaxFuzz:
-                cfgvars.MaxFuzz = int(args.MaxFuzz)
-        else:
-                cfgvars.MaxFuzz = cfgvars.Seed
-	if args.DeDup:
-                cfgvars.DeDup = True
-        else:
-                cfgvars.DeDup = False
-        if args.ReadNamesEntry:
-                cfgvars.ReadNamesEntry = True
-        else:
-                cfgvars.ReadNamesEntry = False
-        if args.Aligner == 'bwa':
-		cfgvars.Aligner = 'bwa'
-	else: 
-		cfgvars.Aligner = 'bowtie'
-        if args.Chunk:
-                cfgvars.Chunk = str(args.Chunk)
-        else:
-                cfgvars.Chunk = False
-        if args.Host_Seed:
-                if int(args.Host_Seed) < cfgvars.Seed:
-                        cfgvars.Host_Seed = cfgvars.Seed
-                else:
-                        cfgvars.Host_Seed = int(args.Host_Seed)
-        else:
-                cfgvars.Host_Seed = cfgvars.Seed
-        if args.No_Compile:
-                cfgvars.Compile = False
-        else:
-                cfgvars.Compile = True
-        if args.Win:
-                cfgvars.Win = True
-        else:
-                cfgvars.Win = False
-        if args.BED:
-                cfgvars.BED = True
-        else:
-                cfgvars.BED = False
-
-        CommandLineEntry = str(sys.argv)
-        Report = open(cfgvars.File2,"a")
-        Report.write(cfgvars.Lib1 + '\n')
-        Report.write(CommandLineEntry + '\n')
-        Report.close()
-        
-##      ----------------------------------------------------------------------------------------
-##      Function Countreads will determine the number of complete reads in the given input file.
-##      ----------------------------------------------------------------------------------------
-
-def Countreads(File, ReadType):
-        with open(File, 'r') as CountReadsIn:
-        	NumberofReads = 0
-        	for line in CountReadsIn:
-                	if ReadType == "Q":
-                        	NumberofReads += 0.25
-                	elif ReadType == "F":
-                        	NumberofReads += 0.5
-        return int(NumberofReads)
-
-##      ------------------------------------------------------------------------------------------------------------
-##      For each read aligned and output to the temporary SAM file, the function FindReadMapping() will extract
-##      data for any succesfully aligning portions of the read, and then write to a new TEMPREADS file any remaining
-##      nucleotides that will be mapped in a subsequent alignment iteration. The mapping data is then summarised and
-##      returned to functions Alignment() for compiling.
-##      ------------------------------------------------------------------------------------------------------------
-
-def FindReadMapping(output, CurrentSeed, Seed):
-        if output[2] != '*':
-                if len(output[9]) < Seed:    
-		#output[9] is the query sequence
-                        return "TOOSMALL", "U", "*", "*", output[9], "N"
-                else:
-			MismatchTag = [i[5:] for i in output if 'MD:Z:' in i][0]
-			Align = findall(r"[^\W\d_]+|\d+", MismatchTag)	
-			#output[12] is the default mismatches field in bowtie
-			flag = bin(int(output[1]))
-			#This is the bitwise FLAG from the standard .SAM format.  A flag of '4' means the read is unmapped.
-                        if len(flag) > 6 and flag[-5] == '1':		
-			#A flag of '16' means the read mapped to the reference in the reverse direction and so needs to be reverse complented to regain to the original read
-                                Align = Align[::-1]
-                                output[9] = Rev_Comp(output[9])
-                                Direction = '_RevStrand_'
-                        else:
-                                Direction = '_'       
-                        if int(Align[0]) <= cfgvars.FivePad:
-                                        #Here, a mismatched nucleotide has occcurred too near the 5' end of the mapped read.
-                                        #Consequently, this read will be trimmed as if it has not aligned.
-                                        #If there is a good mapping, it will be found in a subsequent iteration.
-                                        Code = '%sX' % (output[9][0])
-                                        if len(output[9][1:]) >= Seed:
-                                                return "NONE", Code, "*", "*", str(len(output[9][1:])), "Y", output[9], output[10],
-                                        else:
-                                                return "NONE", Code, "*", "*", output[9][1:], "N", output[9], output[10]
-                        else:
-					#Here, we find the number of mapped nucleotides including allowed mismatches (note, mismatches are not allowed at the ends of a segment as determined by the 'ThreePad' and 'FivePad' variables
-                                        if cfgvars.Mismatches >= 2 and len(Align) > 3 and int(Align[4]) >= cfgvars.ThreePad:
-						#Means if two mismatches are allowed, and if two mismatches are found, and if none of these mismatches are disqualifying
-                                        	if Align[2] == '0':
-							#Means there are two adjacent but allowed mismatches
-							Code = '%sM2X%sM' % (Align[0], Align[4])
-						else:
-							#Means there are two non-adjacent and allowed mismatches
-							Code = '%sM1X%sM1X%sM' % (Align[0], Align[2], Align[4])
-					        MappedLength = int(Align[0]) + int(Align[2]) + int(Align[4]) + 2
-						#Length of the three mapped sections plus the mismatches
-                                        elif cfgvars.Mismatches >= 1 and len(Align) > 1 and int(Align[2]) >= cfgvars.ThreePad:
-						#Means if one mismatch is allowed, and if one mismatch is found and it is not disqualifying
-                                                MappedLength = int(Align[0]) + int(Align[2]) + 1
-						Code = '%sM1X%sM' % (Align[0], Align[2])
-                                        else:
-						#Means no mismatches were found
-                                                MappedLength = int(Align[0])
-						Code = '%sM' % (str(MappedLength))
-					if int(MappedLength) < CurrentSeed:
-                                                #After accounting for disallowed mismatches, the remaining mapped nucleotides are now shorter than the required Seed Length
-                                                #Therefore, there is no confident mapping.
-                                                Code = '%sX' % (output[9][0])
-                                                if len(output[9][1:]) >= Seed:
-                                                        return "NONE", Code, "*", "*", str(len(output[9][1:])), "Y", output[9], output[10],
-                                                else:
-                                                        return "NONE", Code, "*", "*", output[9][1:], "N", output[9], output[10]
-                                        else:
-                                                if Direction == '_RevStrand_':
-                                                        #output[3] is the 1-based leftmost position of the clipped alignment from the .SAM format
-                                                        output[3] = str(int(output[3]) + len(output[9]) - 1)
-                                                        if cfgvars.Mismatches >= 2 and len(Align) > 3 and int(Align[4]) >= cfgvars.ThreePad:
-                                                        #Means if two mismatches are allowed, and if two mismatches are found, and if none of these mismatches are disqualifying
-                                                                if Align[2] == '0':
-                                                                        #Means there are two adjacent but allowed mismatches
-                                                                        Alignment = output[3] + Direction + str(int(output[3]) - int(Align[0]) + 1) + '\t' + output[9][int(Align[0]):int(Align[0]) + 2] + '\t' + output[2] + '\t' + str(int(output[3]) - int(Align[0]) - 2) + Direction + str(int(output[3]) - MappedLength + 1)
-                                                                        #This is for Reverse Strand. So, this means: mapping of first section + \t + identity of two allowed and adjacent mismatching nucleotides + \t + mapping of last section.
-                                                                else:
-                                                                        #Means there are two non-adjacent and allowed mismatches
-                                                                        Alignment = output[3] + Direction + str(int(output[3]) - int(Align[0]) + 1) + '\t' + output[9][int(Align[0])] + '\t' + output[2] + '\t' + str(int(output[3]) - int(Align[0]) - 1) + Direction + str(int(output[3]) - int(Align[0]) - int(Align[2])) + '\t' + output[9][(int(Align[0]) + int(Align[2]) + 1)] + "\t" + output[2] + '\t' + str(int(output[3]) - int(Align[0]) - int(Align[2]) - 2) + Direction + str(int(output[3]) - MappedLength + 1)
-                                                                        #This is for Reverse Strand. This means: mapping of first section + \t + identity of allowed mismatching nucleotide + \t + mapping of second section + \t + identity of second allowed mismatching nucleotide + \t + mapping of third section
-                                                        elif cfgvars.Mismatches >= 1 and len(Align) > 1 and int(Align[2]) >= cfgvars.ThreePad:
-                                                                #Means if one mismatch is allowed, and if one mismatch is found and it is not disqualifying
-                                                                Alignment = output[3] + Direction + str(int(output[3]) - int(Align[0]) + 1) + '\t' + output[9][int(Align[0])] + '\t' + output[2] + '\t' + str(int(output[3]) - int(Align[0]) - 1) + Direction + str(int(output[3]) - MappedLength + 1)
-                                                                #This is for Reverse Strand. So, this means: mapping of first section + \t + identity of allowed mismatching nucleotides + \t + mapping of last section.
-                                                        else:
-                                                                #Means no mismatches were found
-                                                                Alignment = output[3] + Direction + str(int(output[3]) - MappedLength + 1)
-                                                                #This is Reverse Strand. So, this means: mapping of whole read.
-                                                else:
-                                                        if cfgvars.Mismatches >= 2 and len(Align) > 3 and int(Align[4]) >= cfgvars.ThreePad:
-                                                        #Means if two mismatches are allowed, and if two mismatches are found, and if none of these mismatches are disqualifying
-                                                                if Align[2] == '0':
-                                                                        #Means there are two adjacent but allowed mismatches
-                                                                        Alignment = output[3] + Direction + str(int(output[3]) + int(Align[0]) - 1) + '\t' + output[9][int(Align[0]):int(Align[0]) + 2] + '\t' + output[2] + '\t' + str(int(output[3]) + int(Align[0]) + 2) + Direction + str(MappedLength + int(output[3]) - 1)
-                                                                        #This means: mapping of first section + \t + identity of two allowed and adjacent mismatching nucleotides + \t + mapping of last section.
-                                                                else:
-                                                                        #Means there are two non-adjacent and allowed mismatches
-                                                                        Alignment = output[3] + Direction + str(int(output[3]) + int(Align[0]) - 1) + '\t' + output[9][int(Align[0])] + '\t' + output[2] + '\t' + str(int(output[3]) + int(Align[0]) + 1) + Direction + str(int(Align[0]) + int(Align[2]) + int(output[3])) + '\t' + output[9][(int(Align[0]) + int(Align[2]) + 1)] + '\t' + output[2] + '\t' + str(int(output[3]) + int(Align[0]) + int(Align[2]) + 2) + Direction + str(MappedLength + int(output[3]) - 1)
-                                                                        #This means: mapping of first section + \t + identity of allowed mismatching nucleotide + \t + mapping of second section + \t + identity of second allowed mismatching nucleotide + \t + mapping of third section
-                                                        elif cfgvars.Mismatches >= 1 and len(Align) > 1 and int(Align[2]) >= cfgvars.ThreePad:
-                                                                #Means if one mismatch is allowed, and if one mismatch is found and it is not disqualifying
-                                                                Alignment = output[3] + Direction + str(int(output[3]) + int(Align[0]) - 1) + '\t' + output[9][int(Align[0])] + '\t' + output[2] + '\t' + str(int(output[3]) + int(Align[0]) + 1) + Direction + str(MappedLength + int(output[3]) - 1)
-                                                                #This means: mapping of first section + \t + identity of allowed mismatching nucleotides + \t + mapping of last section.
-                                                        else:
-                                                                #Means no mismatches were found
-                                                                Alignment = output[3] + Direction + str(MappedLength + int(output[3]) - 1)
-                                                                #This means: mapping of whole read.
-                                                if len(output[9][(MappedLength):]) >= Seed:
-                                                        #Means there are still enough unmapped nucleotide remaining after mapped section to form a new seed
-                                                        return "SOME", Code, output[2], Alignment, str(len(output[9][(MappedLength):])), "Y", output[9][(MappedLength):], output[10][(MappedLength):]
-                                                else:
-                                                        return "SOME", Code, output[2], Alignment, output[9][(MappedLength):], "N"
-        else:
-		#No mapping was found for this read during this alignment
-                if len(output[9]) < Seed:
-			#Read was too short.
-                        return "TOOSMALL", "U", "*", "*", output[9], "N",
-                else:
-                        #Code = '%sX' % (output[9][0])
-                        if len(output[9][1:]) >= Seed:
-				#Read is still long enough for next iteration
-                                return "NONE", '%sX' % (output[9][0]), "*", "*", str(len(output[9][1:])), "Y", output[9], output[10]
-                        else:
-				#Read is now too short for subsequent iterations.
-                                return "NONE", '%sX' % (output[9][0]), "*", "*", output[9][1:], "N", output[9], output[10]
-            
-##      ----------------------------------------------------------------------------------------
-##      Function Alignment() will take read data and attempt to align it to the reference genomes (Virus first, Host second).
-##      Bowtie must be in your $PATH.
-##      If the Seed of the read successfully aligns to a reference genome, bowtie will continue to align the remaining nucleotides after the Seed.
-##      Alignment() will extract all the successfully aligned nucleotides and the remaining unaligned nucleotides will be written to a new temporary read file.
-##      If there is no succesful alignment, Alignment() will trim one nucleotide from the beginning of the read and report.
-##      Again, the remaining nucleotides will be written to a new temporary file which will be used for subsequent alignmen.
-##      ----------------------------------------------------------------------------------------
-
-def Alignment(ReadsIn, ReadType, Seed):
-	####  Function AddToReportDict() adds details of any alignments, mismatches or trimmed nucleotide to temporary dictionary.
-	####  Entries are annotated accordingly to the sequence read name, therefore read names MUST be unique.  Take care when using paired-end reads.
-	def AddToReportDict(Dict, Namee):
-		if Name in Dict:
-			Dict[Namee] += [Mapping[0:5]]
-		else:
-			Dict[Namee] = [Mapping[0:5]]
-	SamHeaders = ['@HD', '@SQ', '@RG', '@PG', '@CO']
-	#Run Bowtie/BWA using Virus Genome.   Bowtie/BWA must be in your PATH.  Remove the --mm and -p options if operating in Windows or cygwin.
-        if cfgvars.Aligner == 'bwa':
-		with open('TEMPSAI1', 'w') as outfilesai:
-			call(['bwa', 'aln', '-k', str(cfgvars.Mismatches), '-l', str(Seed), '-n', '10000', '-o', '0', '-t', cfgvars.Threads, cfgvars.Lib1, ReadsIn], stdout = outfilesai)
-		with open('TEMPSAM1', 'w') as outfilesam:
-			call(['bwa', 'samse', cfgvars.Lib1, 'TEMPSAI1', ReadsIn], stdout = outfilesam)
-        else:
-                if cfgvars.Win:
-                        call(['bowtie', ReadType, '-n', str(cfgvars.Mismatches), '-l', str(Seed), '-e', '100000', '--quiet', '--best', '-S', '--sam-nohead', cfgvars.Lib1, ReadsIn, 'TEMPSAM1'])
-                else:
-                        call(['bowtie', ReadType, '-n', str(cfgvars.Mismatches), '-l', str(Seed), '-e', '100000', '--quiet', '--mm', '-p', cfgvars.Threads, '--best', '-S', '--sam-nohead', cfgvars.Lib1, ReadsIn, 'TEMPSAM1'])
-        NumHostReads = 0
-        with open('TEMPSAM1','r') as SAMIN1:
-	        TempReads = open('TEMPREADS', 'w')
-	        if cfgvars.Lib2:
-			#If using two genomes, open a new file to write any reads that did not map to virus genome
-	                HostAttemptReads = open("TEMPREADS2", "w")
-	        else:
-	                pass
-	        for line in SAMIN1:
-	                line = line.split('\t')
-	                if line[2] != '*' and True not in [i[:5] == 'MD:Z:' for i in line]:  ####REMOVE THIS HACK LATER
-                                print "WARNING, SAM entry contains mapping Data but no Mismatch Tag: Read ignored"
-                                print line  
-                        else:
-                                Name = line[0]
-                                if Name[:3] in SamHeaders:
-                                        pass
-                                else:
-                                    Mapping = FindReadMapping(line, Seed, Seed)
-                                    if Mapping[0] == "NONE":
-                                        #No mapping to virus genone was found.  If a host genome is provided, write read out to new tempread file for an extra alignment
-                                        if cfgvars.Lib2:
-                                                if Mapping[5] == "Y":
-                                                #'Y' is just a tag to say that the read has enough nucleotides remaining to be used in subsequent iterations.
-                                                        if int(Mapping[4]) >= cfgvars.Host_Seed:
-                                                                #Only write read to tempfile used for host alignment is that read is longer than the chosen Host_Seed length, otherwise, skip host alignment
-                                                                #HostAttemptReads.write("@" + str(Name) + "\n" + str(Mapping[6]) + "\n+\n" +str(Mapping[7])+ "\n" )
-                                                                HostAttemptReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6]), str(Mapping[7])) )
-                                                                NumHostReads += 1
-                                                        else:
-                                                        #Proceed to next iteration without host mapping and trim first nucleotide
-                                                                #TempReads.write("@" + str(Name) + "\n" + str(Mapping[6][1:]) + "\n+\n" + str(Mapping[7][1:])+ "\n" )
-                                                                TempReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6][1:]), str(Mapping[7][1:])) )
-                                                                AddToReportDict(ReportDict, Name)
-                                                else:
-                                                #'N' is just a tag to sat that the read is too short for subsequent iterations and so will not be written to the temp read file.
-                                                        AddToReportDict(ReportDict, Name)
-                                        else:
-                                                if Mapping[5] == "Y":
-                                                        #Proceed to next iteration without host mapping and trim first nucleotide
-                                                        #TempReads.write("@" + str(Name) + "\n" + str(Mapping[6][1:]) + "\n+\n" + str(Mapping[7][1:])+ "\n" )
-                                                        TempReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6][1:]), str(Mapping[7][1:])) )
-                                                else:
-                                                        pass
-                                                AddToReportDict(ReportDict, Name)
-                                    else:
-                                        if Mapping[5] == "Y":
-                                                #Proceed to next iteration without host mapping.
-                                                #TempReads.write("@" + str(Name) + "\n" + str(Mapping[6]) + "\n+\n" + str(Mapping[7])+ "\n" )
-                                                TempReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6]), str(Mapping[7])) )
-                                        else:
-                                                pass
-                                                #'N' is just a tag to sat that the read is too short for subsequent iterations and so will not be written to the temp read file.
-                                        AddToReportDict(ReportDict, Name)
-        if cfgvars.Lib2:
-                HostAttemptReads.close()
-                if NumHostReads > 0:
-                        #Run Bowtie/BWA using Host Genome.   Bowtie/BWA must be in your PATH.  Remove the --mm and -p options if operating in Windows or cygwin.  With a large host genome, this will dramatically increase runtime as the reference genome will have to be loaded into temporary memory with each iteration.
-                        if cfgvars.Aligner == 'bwa':
-                                with open('TEMPSAI2', 'w') as outfilesai:
-                                        call(['bwa', 'aln', '-k', str(cfgvars.Mismatches), '-l', str(cfgvars.Host_Seed), '-n', '10000', '-o', '0', '-t', cfgvars.Threads, cfgvars.Lib1, ReadsIn], stdout = outfilesai)
-                                with open('TEMPSAM2', 'w') as outfilesam:
-                                        call(['bwa', 'samse', cfgvars.Lib1, 'TEMPSAI2', ReadsIn], stdout = outfilesam)
-                        else:
-                                if cfgvars.Win:
-                                        call(['bowtie', '-q', '-n', str(cfgvars.Mismatches), '-l', str(cfgvars.Host_Seed), '-e', '100000', '--quiet', '--best', '-S', '--sam-nohead', cfgvars.Lib2, 'TEMPREADS2', 'TEMPSAM2'])
-                                else:
-                                        call(['bowtie', '-q', '-n', str(cfgvars.Mismatches), '-l', str(cfgvars.Host_Seed), '-e', '100000', '--quiet', '--mm', '-p', cfgvars.Threads, '--best', '-S', '--sam-nohead', cfgvars.Lib2, 'TEMPREADS2', 'TEMPSAM2'])
-                        with open('TEMPSAM2', 'r') as SAMIN2:
-                                for line in SAMIN2:
-                                        line = line.split('\t')
-                                        Name = line[0]
-                                        if Name[:3] in SamHeaders:
-                                                pass
-                                        else:
-                                            Mapping = FindReadMapping(line, cfgvars.Host_Seed, Seed)
-                                            if Mapping[0] != "NONE":
-                                                if Mapping[5] == "Y":
-                                                        #TempReads.write("@" + str(Name) + "\n" + str(Mapping[6]) + "\n+\n" + str(Mapping[7]) + "\n" )
-                                                        TempReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6]), str(Mapping[7])) )
-                                                else:
-                                                        pass
-                                                AddToReportDict(ReportDict, Name)
-                                            else:
-                                                if Mapping[5] == "Y":
-                                                        #TempReads.write("@" + str(Name) + "\n" + str(Mapping[6][1:]) + "\n+\n" + str(Mapping[7][1:])+ "\n" )
-                                                        TempReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6][1:]), str(Mapping[7][1:])) ) 
-                                                else:
-                                                        pass
-                                                AddToReportDict(ReportDict, Name)
-                else:
-                        pass
-        TempReads.close()
-                
-
-##      ----------------------------------------------------------------------------------------
-##      Function IterateAlignments() will call Bowtie and beging alignments starting with supplied input file
-##	and continuing with the generated TEMPREAD files until there no reads left.
-##	If providing a FASTA file, this get converted to a FASTQ file with uniform quality 
-##	scores of PHRED == 30 after the first Bowtie iteration
-##      ----------------------------------------------------------------------------------------
-
-def IterateAlignments(File):
-        if cfgvars.ReadType == '-f':
-                print "%s reads in input file." % Countreads(File, 'F')
-		Alignment(File, '-f', cfgvars.Seed)
-	else:
-                print "%s reads in input file." % Countreads(File, 'Q')
-		Alignment(File, '-q', cfgvars.Seed)
-        ReadsRemaining = Countreads('TEMPREADS', 'Q')
-        print "%s reads remaining to be aligned after first iteration." % (ReadsRemaining)
-        n = 1
-        while ReadsRemaining > 0:
-            n += 1
-            Alignment('TEMPREADS', '-q', cfgvars.Seed)
-            ReadsRemaining = Countreads('TEMPREADS', 'Q')
-            print "%s reads remaining to be aligned after %s iterations." % (ReadsRemaining, n)
-    
-##      ----------------------------------------------------------------------------------------
-##      ReportResults() Analyses the results from all the Bowtie calls and collates all the results 
-##	for each read into a single output and writes this to the final Output file.
-##      ----------------------------------------------------------------------------------------
-
-def ReportResults():
-        Report = open(cfgvars.File2,"a")
-        for k in ReportDict:
-            FinalAlignment = []
-            FinalAlignment.append(k)
-            Trimmednucs = ''
-            Code = []
-            for i in ReportDict[k]:
-                if i[0] == "SOME":
-                        if Trimmednucs:
-                                FinalAlignment.append(Trimmednucs)
-                                Code.append("%sU" % (str(len(Trimmednucs))))
-                        else:
-                                pass
-                        FinalAlignment.append(i[2])
-                        FinalAlignment.append(i[3])
-                        Trimmednucs = ''
-                        Code.append(i[1])
-                elif i[0] == 'NONE':
-                        Trimmednucs += i[1][:-1]
-            	else:
-			pass
-            Trimmednucs += i[4]
-            if len(Trimmednucs) > 0:
-			FinalAlignment.append(Trimmednucs)
-            		Code.append("%sU" % (str(len(Trimmednucs))))
-            else:
-                    pass
-            #FinalAlignment.append(str(Code))
-            #for i in FinalAlignment:
-            #        Report.write("%s\t" % (i))
-            [Report.write("%s\t" % (i)) for i in FinalAlignment]
-            Code = "".join(Code)
-            Report.write("%s\t\n" % (Code))
-        Report.close()
-
-##      ----------------------------------------------------------------------------------------
-##      Run Modules
-##      ----------------------------------------------------------------------------------------
-
-if __name__ == '__main__':
-        if cfgvars.Chunk:
-                with open(cfgvars.File1, 'r') as MAINFILE:
-                        ChunkNum = 0
-                        Read = MAINFILE.readline()
-                        while Read:
-                                ChunkedReads = open('ChunkedReads', 'w')
-                                ReadNum = 0
-                                while ReadNum < int(cfgvars.Chunk):
-                                        if Read:
-                                                if cfgvars.ReadType == '-f':
-                                                        ChunkedReads.write(Read)
-                                                        ChunkedReads.write(MAINFILE.readline())
-                                                else:
-                                                        ChunkedReads.write(Read)
-                                                        ChunkedReads.write(MAINFILE.readline())
-                                                        ChunkedReads.write(MAINFILE.readline())
-                                                        ChunkedReads.write(MAINFILE.readline())
-                                                Read = MAINFILE.readline()
-                                                ReadNum += 1
-                                        else:
-                                                ReadNum += 1
-                                ChunkedReads.close()
-                                ChunkNum += 1
-                                ReportDict = {}
-                                print "Begining alignments on Chunk Number %s" % ChunkNum
-                                IterateAlignments('ChunkedReads')
-                                print "Appending Results from Chunk Number %s to: " % ChunkNum, str(cfgvars.File2)
-                                ReportResults()
-        else:
-                ReportDict = {}
-                print "Begining alignments"
-                IterateAlignments(cfgvars.File1)
-                print "Reporting Results to: ", str(cfgvars.File2)
-                ReportResults()
-        if cfgvars.Compile:
-                if cfgvars.Aligner =='bwa':
-			cfgvars.RefsLib1, cfgvars.RefsLib2, cfgvars.Genes = ExtractRefDataBWA()
-                else:
-			cfgvars.RefsLib1, cfgvars.RefsLib2, cfgvars.Genes = ExtractRefData()
-                if cfgvars.DeDup:
-			UniquifyReport(cfgvars.File2, 'DeDuped_' + cfgvars.File2)
-			cfgvars.File2 = 'DeDuped_' + cfgvars.File2
-		else:
-			pass
-		print "Compiling Results and saving into individual outputs"
-		if args.Output_Dir and cfgvars.Compile:
-                        if not exists(str(args.Output_Dir)):
-                                cfgvars.Output_Dir = str(args.Output_Dir) + '/'
-                                makedirs(cfgvars.Output_Dir)
-                        else:
-                                print "Output Directory already exists!  Appending time to directory name to prevent overwrite."
-                                cfgvars.Output_Dir = str(args.Output_Dir) + str(int(time.time())) + '/'
-                                makedirs(cfgvars.Output_Dir)
-                else:
-                        cfgvars.Output_Dir = ''
-                if cfgvars.BED:
-                        if not exists(cfgvars.Output_Dir + 'BED_Files/'):
-                                makedirs(cfgvars.Output_Dir + 'BED_Files/')
-                        else:
-                                makedirs(cfgvars.Output_Dir + 'BED_Files_' + str(int(time.time())) + '/')
-                                print "WARNING: BED Folder already present in output directory!"
-                else:
-                        pass
-                ResultsSort(cfgvars.File2)
-
-finish = time.time()
-print "Time to complete in seconds: ", int(finish - start)
-
-##      ----------------------------------------------------------------------------------------
-##      End
-##      ----------------------------------------------------------------------------------------
-
-
-
+#!/opt/anaconda1anaconda2anaconda3/bin/python
+
+##      Copyright (c) 2013-2014 Andrew Laurence Routh
+
+##      
+
+##      Permission is hereby granted, free of charge, to any person obtaining a copy
+
+##      of this software and associated documentation files (the "Software"), to deal
+
+##      in the Software without restriction, including without limitation the rights
+
+##      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+
+##      copies of the Software, and to permit persons to whom the Software is
+
+##      furnished to do so, subject to the following conditions:
+
+##      
+
+##      The above copyright notice and this permission notice shall be included in
+
+##      all copies or substantial portions of the Software.
+
+##      
+
+##      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+
+##      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+
+##      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+
+##      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+
+##      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+
+##      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+
+##      THE SOFTWARE.
+
+##
+
+##      ----------------------------------------------------------------------------------------
+
+print '\n-------------------------------------------------------------------------------------------'
+
+print 'ViReMa Version 0.6 - written by Andrew Routh'
+
+print 'Last modified 6/6/2014'
+
+print '-------------------------------------------------------------------------------------------'
+
+##      ----------------------------------------------------------------------------------------
+
+
+
+import time
+
+start = time.time()
+
+from subprocess import call
+
+from re import findall
+
+import argparse
+
+from Compiler_Module import *
+
+import ConfigViReMa as cfgvars
+
+from os import makedirs
+
+from os.path import exists
+
+import sys
+
+
+
+##      -------------------------------------------------------------------------------------------
+
+##      Take arguments from command line, and send them to the config file for cross-module access
+
+##      -------------------------------------------------------------------------------------------
+
+
+
+if __name__ =='__main__':
+
+        parser = argparse.ArgumentParser()
+
+        parser.add_argument("Virus_Index", help="Virus genome reference index key. e.g. FHV_Genome")
+
+        parser.add_argument("--Host_Index", help="Host genome reference index key, e.g. d_melanogaster_fb5_22")
+
+        parser.add_argument("Input_Data", help= "File containing single reads in FASTQ format")
+
+        parser.add_argument("Output_Data", help= "Destination file for results")
+
+	parser.add_argument("--N", help= "Number of mismatches tolerated in mapped seed and in mapped segments. Default is 1.")
+
+	parser.add_argument("--Seed", help="Number of nucleotides in the Seed region. Default is 25.")
+
+	parser.add_argument("--ThreePad", help="Number of nucleotides not allowed to have mismatches at 3' end of segment. Default is 5.")
+
+	parser.add_argument("--FivePad", help="Number of nucleotides not allowed to have mismatches at 5' end of segment. Default is 5.")
+
+	parser.add_argument("--X", help="Number of nucleotides not allowed to have mismatches at 3' end and 5' of segment. Overrides seperate ThreePad and FivePad settings. Default is 5.")
+
+        parser.add_argument("--Host_Seed", help="Number of nucleotides in the Seed region when mapping to the Host Genome. Default is same as Seed value.")
+
+        parser.add_argument("-F", action='store_true', help="Select '-F' if data is in FASTA format fasta. Default is FASTQ.")
+
+        parser.add_argument("--Defuzz", help="Choose how to defuzz data:  '5' to report at 5' end of fuzzy region, '3' to report at 3' end, or '0' to report in centre of fuzzy region. Default is no fuzz handling (similar to choosing Right - see Routh et al).")
+
+        parser.add_argument("--MaxFuzz", help="Select maximum allowed length of fuzzy region. Recombination events with longer fuzzy regions will not be reported. Default is Seed Length.")
+
+	parser.add_argument("-DeDup", action='store_true', help="Remove potential PCR duplicates. Default is 'off'.")
+
+        parser.add_argument("-ReadNamesEntry", action='store_true', help="Append Read Names contributing to each compiled result. Default is off.")
+
+        parser.add_argument("--MicroInDel_Length", help= "Size of MicroInDels - these are common artifacts of cDNA preparation.  See Routh et al JMB 2012. Default size is 0)")
+
+        parser.add_argument("--Compound_Handling", help= "Select this option for compound recombination event mapping (see manual for details). Enter number of nucleotides to map (must be less than Seed, and greater than number of nts in MicroInDel). Default is off.")
+
+        parser.add_argument("--Output_Tag", help= "Enter a tag name that will be appended to end of each output file.")
+
+        parser.add_argument("--Output_Dir", help= "Enter a directory name that all compiled output files will be saved in.")
+
+        parser.add_argument("--p", help= "Enter number of available processors. Default is 1.")
+
+        parser.add_argument("--Chunk", help= "Enter number of reads to process together.")
+
+	parser.add_argument("--Aligner", help="Enter Alignment Software: 'bwa', 'bowtie'. Default is bowtie.")
+
+        parser.add_argument("-No_Compile", action='store_true', help= "Select this option if you do not wish to compile the results file into.  Maybe useful when combining results from different datasets.")
+
+        parser.add_argument("-BED", action='store_true', help= "Output recombination data into BED files.")
+
+        parser.add_argument("-Win", action='store_true', help= "Select this option if running ViReMa from a Windows/Cygwin shell.")
+
+        args = parser.parse_args()
+
+
+
+        cfgvars.Lib1 = str(args.Virus_Index)
+
+        if args.Host_Index:
+
+                cfgvars.Lib2 = str(args.Host_Index)
+
+        else:
+
+                cfgvars.Lib2 = None
+
+        cfgvars.File1 = str(args.Input_Data)
+
+        if not exists(str(args.Output_Data)):
+
+                        cfgvars.File2 = str(args.Output_Data)
+
+        else:
+
+                        print "Output File already exists!  Appending time to directory name to prevent overwrite."
+
+                        cfgvars.File2 = str(args.Output_Data) + str(int(time.time()))
+
+        if args.F:	
+
+		cfgvars.ReadType = '-f'
+
+	else: 
+
+		cfgvars.ReadType = '-q'
+
+        if args.Seed:
+
+                cfgvars.Seed = int(args.Seed)
+
+        else:
+
+                cfgvars.Seed = 25
+
+	if args.N:
+
+		cfgvars.Mismatches = int(args.N)
+
+	else:
+
+		cfgvars.Mismatches = 1
+
+        if args.Compound_Handling:
+
+                cfgvars.Compound_Handling = str(args.Compound_Handling)
+
+        else:
+
+                cfgvars.Compound_Handling = ''
+
+        if args.MicroInDel_Length:
+
+                cfgvars.MicroInDel_Length = int(args.MicroInDel_Length)
+
+        else:
+
+                cfgvars.MicroInDel_Length = 0
+
+	if args.ThreePad:
+
+		cfgvars.ThreePad = int(args.ThreePad)
+
+	else:
+
+		cfgvars.ThreePad = 5
+
+	if args.FivePad:
+
+		cfgvars.FivePad = int(args.FivePad)
+
+	else:
+
+		cfgvars.FivePad = 5
+
+	if args.X:
+
+                cfgvars.FivePad = int(args.X)
+
+                cfgvars.ThreePad = int(args.X)
+
+        else:
+
+                pass
+
+        if args.p:
+
+                cfgvars.Threads = str(args.p)
+
+        else:
+
+                cfgvars.Threads = '1'
+
+        if args.Output_Tag:
+
+                cfgvars.FileTag = str(args.Output_Tag) + "_"
+
+        else:
+
+                cfgvars.FileTag = ''
+
+        if args.Defuzz == '3':
+
+		cfgvars.Defuzz = 'Right'
+
+	elif args.Defuzz == '5':
+
+		cfgvars.Defuzz = 'Left'
+
+	elif args.Defuzz == '0':
+
+		cfgvars.Defuzz = 'Centre'
+
+        else:
+
+                cfgvars.Defuzz = False
+
+        if args.MaxFuzz:
+
+                cfgvars.MaxFuzz = int(args.MaxFuzz)
+
+        else:
+
+                cfgvars.MaxFuzz = cfgvars.Seed
+
+	if args.DeDup:
+
+                cfgvars.DeDup = True
+
+        else:
+
+                cfgvars.DeDup = False
+
+        if args.ReadNamesEntry:
+
+                cfgvars.ReadNamesEntry = True
+
+        else:
+
+                cfgvars.ReadNamesEntry = False
+
+        if args.Aligner == 'bwa':
+
+		cfgvars.Aligner = 'bwa'
+
+	else: 
+
+		cfgvars.Aligner = 'bowtie'
+
+        if args.Chunk:
+
+                cfgvars.Chunk = str(args.Chunk)
+
+        else:
+
+                cfgvars.Chunk = False
+
+        if args.Host_Seed:
+
+                if int(args.Host_Seed) < cfgvars.Seed:
+
+                        cfgvars.Host_Seed = cfgvars.Seed
+
+                else:
+
+                        cfgvars.Host_Seed = int(args.Host_Seed)
+
+        else:
+
+                cfgvars.Host_Seed = cfgvars.Seed
+
+        if args.No_Compile:
+
+                cfgvars.Compile = False
+
+        else:
+
+                cfgvars.Compile = True
+
+        if args.Win:
+
+                cfgvars.Win = True
+
+        else:
+
+                cfgvars.Win = False
+
+        if args.BED:
+
+                cfgvars.BED = True
+
+        else:
+
+                cfgvars.BED = False
+
+
+
+        CommandLineEntry = str(sys.argv)
+
+        Report = open(cfgvars.File2,"a")
+
+        Report.write(cfgvars.Lib1 + '\n')
+
+        Report.write(CommandLineEntry + '\n')
+
+        Report.close()
+
+        
+
+##      ----------------------------------------------------------------------------------------
+
+##      Function Countreads will determine the number of complete reads in the given input file.
+
+##      ----------------------------------------------------------------------------------------
+
+
+
+def Countreads(File, ReadType):
+
+        with open(File, 'r') as CountReadsIn:
+
+        	NumberofReads = 0
+
+        	for line in CountReadsIn:
+
+                	if ReadType == "Q":
+
+                        	NumberofReads += 0.25
+
+                	elif ReadType == "F":
+
+                        	NumberofReads += 0.5
+
+        return int(NumberofReads)
+
+
+
+##      ------------------------------------------------------------------------------------------------------------
+
+##      For each read aligned and output to the temporary SAM file, the function FindReadMapping() will extract
+
+##      data for any succesfully aligning portions of the read, and then write to a new TEMPREADS file any remaining
+
+##      nucleotides that will be mapped in a subsequent alignment iteration. The mapping data is then summarised and
+
+##      returned to functions Alignment() for compiling.
+
+##      ------------------------------------------------------------------------------------------------------------
+
+
+
+def FindReadMapping(output, CurrentSeed, Seed):
+
+        if output[2] != '*':
+
+                if len(output[9]) < Seed:    
+
+		#output[9] is the query sequence
+
+                        return "TOOSMALL", "U", "*", "*", output[9], "N"
+
+                else:
+
+			MismatchTag = [i[5:] for i in output if 'MD:Z:' in i][0]
+
+			Align = findall(r"[^\W\d_]+|\d+", MismatchTag)	
+
+			#output[12] is the default mismatches field in bowtie
+
+			flag = bin(int(output[1]))
+
+			#This is the bitwise FLAG from the standard .SAM format.  A flag of '4' means the read is unmapped.
+
+                        if len(flag) > 6 and flag[-5] == '1':		
+
+			#A flag of '16' means the read mapped to the reference in the reverse direction and so needs to be reverse complented to regain to the original read
+
+                                Align = Align[::-1]
+
+                                output[9] = Rev_Comp(output[9])
+
+                                Direction = '_RevStrand_'
+
+                        else:
+
+                                Direction = '_'       
+
+                        if int(Align[0]) <= cfgvars.FivePad:
+
+                                        #Here, a mismatched nucleotide has occcurred too near the 5' end of the mapped read.
+
+                                        #Consequently, this read will be trimmed as if it has not aligned.
+
+                                        #If there is a good mapping, it will be found in a subsequent iteration.
+
+                                        Code = '%sX' % (output[9][0])
+
+                                        if len(output[9][1:]) >= Seed:
+
+                                                return "NONE", Code, "*", "*", str(len(output[9][1:])), "Y", output[9], output[10],
+
+                                        else:
+
+                                                return "NONE", Code, "*", "*", output[9][1:], "N", output[9], output[10]
+
+                        else:
+
+					#Here, we find the number of mapped nucleotides including allowed mismatches (note, mismatches are not allowed at the ends of a segment as determined by the 'ThreePad' and 'FivePad' variables
+
+                                        if cfgvars.Mismatches >= 2 and len(Align) > 3 and int(Align[4]) >= cfgvars.ThreePad:
+
+						#Means if two mismatches are allowed, and if two mismatches are found, and if none of these mismatches are disqualifying
+
+                                        	if Align[2] == '0':
+
+							#Means there are two adjacent but allowed mismatches
+
+							Code = '%sM2X%sM' % (Align[0], Align[4])
+
+						else:
+
+							#Means there are two non-adjacent and allowed mismatches
+
+							Code = '%sM1X%sM1X%sM' % (Align[0], Align[2], Align[4])
+
+					        MappedLength = int(Align[0]) + int(Align[2]) + int(Align[4]) + 2
+
+						#Length of the three mapped sections plus the mismatches
+
+                                        elif cfgvars.Mismatches >= 1 and len(Align) > 1 and int(Align[2]) >= cfgvars.ThreePad:
+
+						#Means if one mismatch is allowed, and if one mismatch is found and it is not disqualifying
+
+                                                MappedLength = int(Align[0]) + int(Align[2]) + 1
+
+						Code = '%sM1X%sM' % (Align[0], Align[2])
+
+                                        else:
+
+						#Means no mismatches were found
+
+                                                MappedLength = int(Align[0])
+
+						Code = '%sM' % (str(MappedLength))
+
+					if int(MappedLength) < CurrentSeed:
+
+                                                #After accounting for disallowed mismatches, the remaining mapped nucleotides are now shorter than the required Seed Length
+
+                                                #Therefore, there is no confident mapping.
+
+                                                Code = '%sX' % (output[9][0])
+
+                                                if len(output[9][1:]) >= Seed:
+
+                                                        return "NONE", Code, "*", "*", str(len(output[9][1:])), "Y", output[9], output[10],
+
+                                                else:
+
+                                                        return "NONE", Code, "*", "*", output[9][1:], "N", output[9], output[10]
+
+                                        else:
+
+                                                if Direction == '_RevStrand_':
+
+                                                        #output[3] is the 1-based leftmost position of the clipped alignment from the .SAM format
+
+                                                        output[3] = str(int(output[3]) + len(output[9]) - 1)
+
+                                                        if cfgvars.Mismatches >= 2 and len(Align) > 3 and int(Align[4]) >= cfgvars.ThreePad:
+
+                                                        #Means if two mismatches are allowed, and if two mismatches are found, and if none of these mismatches are disqualifying
+
+                                                                if Align[2] == '0':
+
+                                                                        #Means there are two adjacent but allowed mismatches
+
+                                                                        Alignment = output[3] + Direction + str(int(output[3]) - int(Align[0]) + 1) + '\t' + output[9][int(Align[0]):int(Align[0]) + 2] + '\t' + output[2] + '\t' + str(int(output[3]) - int(Align[0]) - 2) + Direction + str(int(output[3]) - MappedLength + 1)
+
+                                                                        #This is for Reverse Strand. So, this means: mapping of first section + \t + identity of two allowed and adjacent mismatching nucleotides + \t + mapping of last section.
+
+                                                                else:
+
+                                                                        #Means there are two non-adjacent and allowed mismatches
+
+                                                                        Alignment = output[3] + Direction + str(int(output[3]) - int(Align[0]) + 1) + '\t' + output[9][int(Align[0])] + '\t' + output[2] + '\t' + str(int(output[3]) - int(Align[0]) - 1) + Direction + str(int(output[3]) - int(Align[0]) - int(Align[2])) + '\t' + output[9][(int(Align[0]) + int(Align[2]) + 1)] + "\t" + output[2] + '\t' + str(int(output[3]) - int(Align[0]) - int(Align[2]) - 2) + Direction + str(int(output[3]) - MappedLength + 1)
+
+                                                                        #This is for Reverse Strand. This means: mapping of first section + \t + identity of allowed mismatching nucleotide + \t + mapping of second section + \t + identity of second allowed mismatching nucleotide + \t + mapping of third section
+
+                                                        elif cfgvars.Mismatches >= 1 and len(Align) > 1 and int(Align[2]) >= cfgvars.ThreePad:
+
+                                                                #Means if one mismatch is allowed, and if one mismatch is found and it is not disqualifying
+
+                                                                Alignment = output[3] + Direction + str(int(output[3]) - int(Align[0]) + 1) + '\t' + output[9][int(Align[0])] + '\t' + output[2] + '\t' + str(int(output[3]) - int(Align[0]) - 1) + Direction + str(int(output[3]) - MappedLength + 1)
+
+                                                                #This is for Reverse Strand. So, this means: mapping of first section + \t + identity of allowed mismatching nucleotides + \t + mapping of last section.
+
+                                                        else:
+
+                                                                #Means no mismatches were found
+
+                                                                Alignment = output[3] + Direction + str(int(output[3]) - MappedLength + 1)
+
+                                                                #This is Reverse Strand. So, this means: mapping of whole read.
+
+                                                else:
+
+                                                        if cfgvars.Mismatches >= 2 and len(Align) > 3 and int(Align[4]) >= cfgvars.ThreePad:
+
+                                                        #Means if two mismatches are allowed, and if two mismatches are found, and if none of these mismatches are disqualifying
+
+                                                                if Align[2] == '0':
+
+                                                                        #Means there are two adjacent but allowed mismatches
+
+                                                                        Alignment = output[3] + Direction + str(int(output[3]) + int(Align[0]) - 1) + '\t' + output[9][int(Align[0]):int(Align[0]) + 2] + '\t' + output[2] + '\t' + str(int(output[3]) + int(Align[0]) + 2) + Direction + str(MappedLength + int(output[3]) - 1)
+
+                                                                        #This means: mapping of first section + \t + identity of two allowed and adjacent mismatching nucleotides + \t + mapping of last section.
+
+                                                                else:
+
+                                                                        #Means there are two non-adjacent and allowed mismatches
+
+                                                                        Alignment = output[3] + Direction + str(int(output[3]) + int(Align[0]) - 1) + '\t' + output[9][int(Align[0])] + '\t' + output[2] + '\t' + str(int(output[3]) + int(Align[0]) + 1) + Direction + str(int(Align[0]) + int(Align[2]) + int(output[3])) + '\t' + output[9][(int(Align[0]) + int(Align[2]) + 1)] + '\t' + output[2] + '\t' + str(int(output[3]) + int(Align[0]) + int(Align[2]) + 2) + Direction + str(MappedLength + int(output[3]) - 1)
+
+                                                                        #This means: mapping of first section + \t + identity of allowed mismatching nucleotide + \t + mapping of second section + \t + identity of second allowed mismatching nucleotide + \t + mapping of third section
+
+                                                        elif cfgvars.Mismatches >= 1 and len(Align) > 1 and int(Align[2]) >= cfgvars.ThreePad:
+
+                                                                #Means if one mismatch is allowed, and if one mismatch is found and it is not disqualifying
+
+                                                                Alignment = output[3] + Direction + str(int(output[3]) + int(Align[0]) - 1) + '\t' + output[9][int(Align[0])] + '\t' + output[2] + '\t' + str(int(output[3]) + int(Align[0]) + 1) + Direction + str(MappedLength + int(output[3]) - 1)
+
+                                                                #This means: mapping of first section + \t + identity of allowed mismatching nucleotides + \t + mapping of last section.
+
+                                                        else:
+
+                                                                #Means no mismatches were found
+
+                                                                Alignment = output[3] + Direction + str(MappedLength + int(output[3]) - 1)
+
+                                                                #This means: mapping of whole read.
+
+                                                if len(output[9][(MappedLength):]) >= Seed:
+
+                                                        #Means there are still enough unmapped nucleotide remaining after mapped section to form a new seed
+
+                                                        return "SOME", Code, output[2], Alignment, str(len(output[9][(MappedLength):])), "Y", output[9][(MappedLength):], output[10][(MappedLength):]
+
+                                                else:
+
+                                                        return "SOME", Code, output[2], Alignment, output[9][(MappedLength):], "N"
+
+        else:
+
+		#No mapping was found for this read during this alignment
+
+                if len(output[9]) < Seed:
+
+			#Read was too short.
+
+                        return "TOOSMALL", "U", "*", "*", output[9], "N",
+
+                else:
+
+                        #Code = '%sX' % (output[9][0])
+
+                        if len(output[9][1:]) >= Seed:
+
+				#Read is still long enough for next iteration
+
+                                return "NONE", '%sX' % (output[9][0]), "*", "*", str(len(output[9][1:])), "Y", output[9], output[10]
+
+                        else:
+
+				#Read is now too short for subsequent iterations.
+
+                                return "NONE", '%sX' % (output[9][0]), "*", "*", output[9][1:], "N", output[9], output[10]
+
+            
+
+##      ----------------------------------------------------------------------------------------
+
+##      Function Alignment() will take read data and attempt to align it to the reference genomes (Virus first, Host second).
+
+##      Bowtie must be in your $PATH.
+
+##      If the Seed of the read successfully aligns to a reference genome, bowtie will continue to align the remaining nucleotides after the Seed.
+
+##      Alignment() will extract all the successfully aligned nucleotides and the remaining unaligned nucleotides will be written to a new temporary read file.
+
+##      If there is no succesful alignment, Alignment() will trim one nucleotide from the beginning of the read and report.
+
+##      Again, the remaining nucleotides will be written to a new temporary file which will be used for subsequent alignmen.
+
+##      ----------------------------------------------------------------------------------------
+
+
+
+def Alignment(ReadsIn, ReadType, Seed):
+
+	####  Function AddToReportDict() adds details of any alignments, mismatches or trimmed nucleotide to temporary dictionary.
+
+	####  Entries are annotated accordingly to the sequence read name, therefore read names MUST be unique.  Take care when using paired-end reads.
+
+	def AddToReportDict(Dict, Namee):
+
+		if Name in Dict:
+
+			Dict[Namee] += [Mapping[0:5]]
+
+		else:
+
+			Dict[Namee] = [Mapping[0:5]]
+
+	SamHeaders = ['@HD', '@SQ', '@RG', '@PG', '@CO']
+
+	#Run Bowtie/BWA using Virus Genome.   Bowtie/BWA must be in your PATH.  Remove the --mm and -p options if operating in Windows or cygwin.
+
+        if cfgvars.Aligner == 'bwa':
+
+		with open('TEMPSAI1', 'w') as outfilesai:
+
+			call(['bwa', 'aln', '-k', str(cfgvars.Mismatches), '-l', str(Seed), '-n', '10000', '-o', '0', '-t', cfgvars.Threads, cfgvars.Lib1, ReadsIn], stdout = outfilesai)
+
+		with open('TEMPSAM1', 'w') as outfilesam:
+
+			call(['bwa', 'samse', cfgvars.Lib1, 'TEMPSAI1', ReadsIn], stdout = outfilesam)
+
+        else:
+
+                if cfgvars.Win:
+
+                        call(['bowtie', ReadType, '-n', str(cfgvars.Mismatches), '-l', str(Seed), '-e', '100000', '--quiet', '--best', '-S', '--sam-nohead', cfgvars.Lib1, ReadsIn, 'TEMPSAM1'])
+
+                else:
+
+                        call(['bowtie', ReadType, '-n', str(cfgvars.Mismatches), '-l', str(Seed), '-e', '100000', '--quiet', '--mm', '-p', cfgvars.Threads, '--best', '-S', '--sam-nohead', cfgvars.Lib1, ReadsIn, 'TEMPSAM1'])
+
+        NumHostReads = 0
+
+        with open('TEMPSAM1','r') as SAMIN1:
+
+	        TempReads = open('TEMPREADS', 'w')
+
+	        if cfgvars.Lib2:
+
+			#If using two genomes, open a new file to write any reads that did not map to virus genome
+
+	                HostAttemptReads = open("TEMPREADS2", "w")
+
+	        else:
+
+	                pass
+
+	        for line in SAMIN1:
+
+	                line = line.split('\t')
+
+	                if line[2] != '*' and True not in [i[:5] == 'MD:Z:' for i in line]:  ####REMOVE THIS HACK LATER
+
+                                print "WARNING, SAM entry contains mapping Data but no Mismatch Tag: Read ignored"
+
+                                print line  
+
+                        else:
+
+                                Name = line[0]
+
+                                if Name[:3] in SamHeaders:
+
+                                        pass
+
+                                else:
+
+                                    Mapping = FindReadMapping(line, Seed, Seed)
+
+                                    if Mapping[0] == "NONE":
+
+                                        #No mapping to virus genone was found.  If a host genome is provided, write read out to new tempread file for an extra alignment
+
+                                        if cfgvars.Lib2:
+
+                                                if Mapping[5] == "Y":
+
+                                                #'Y' is just a tag to say that the read has enough nucleotides remaining to be used in subsequent iterations.
+
+                                                        if int(Mapping[4]) >= cfgvars.Host_Seed:
+
+                                                                #Only write read to tempfile used for host alignment is that read is longer than the chosen Host_Seed length, otherwise, skip host alignment
+
+                                                                #HostAttemptReads.write("@" + str(Name) + "\n" + str(Mapping[6]) + "\n+\n" +str(Mapping[7])+ "\n" )
+
+                                                                HostAttemptReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6]), str(Mapping[7])) )
+
+                                                                NumHostReads += 1
+
+                                                        else:
+
+                                                        #Proceed to next iteration without host mapping and trim first nucleotide
+
+                                                                #TempReads.write("@" + str(Name) + "\n" + str(Mapping[6][1:]) + "\n+\n" + str(Mapping[7][1:])+ "\n" )
+
+                                                                TempReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6][1:]), str(Mapping[7][1:])) )
+
+                                                                AddToReportDict(ReportDict, Name)
+
+                                                else:
+
+                                                #'N' is just a tag to sat that the read is too short for subsequent iterations and so will not be written to the temp read file.
+
+                                                        AddToReportDict(ReportDict, Name)
+
+                                        else:
+
+                                                if Mapping[5] == "Y":
+
+                                                        #Proceed to next iteration without host mapping and trim first nucleotide
+
+                                                        #TempReads.write("@" + str(Name) + "\n" + str(Mapping[6][1:]) + "\n+\n" + str(Mapping[7][1:])+ "\n" )
+
+                                                        TempReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6][1:]), str(Mapping[7][1:])) )
+
+                                                else:
+
+                                                        pass
+
+                                                AddToReportDict(ReportDict, Name)
+
+                                    else:
+
+                                        if Mapping[5] == "Y":
+
+                                                #Proceed to next iteration without host mapping.
+
+                                                #TempReads.write("@" + str(Name) + "\n" + str(Mapping[6]) + "\n+\n" + str(Mapping[7])+ "\n" )
+
+                                                TempReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6]), str(Mapping[7])) )
+
+                                        else:
+
+                                                pass
+
+                                                #'N' is just a tag to sat that the read is too short for subsequent iterations and so will not be written to the temp read file.
+
+                                        AddToReportDict(ReportDict, Name)
+
+        if cfgvars.Lib2:
+
+                HostAttemptReads.close()
+
+                if NumHostReads > 0:
+
+                        #Run Bowtie/BWA using Host Genome.   Bowtie/BWA must be in your PATH.  Remove the --mm and -p options if operating in Windows or cygwin.  With a large host genome, this will dramatically increase runtime as the reference genome will have to be loaded into temporary memory with each iteration.
+
+                        if cfgvars.Aligner == 'bwa':
+
+                                with open('TEMPSAI2', 'w') as outfilesai:
+
+                                        call(['bwa', 'aln', '-k', str(cfgvars.Mismatches), '-l', str(cfgvars.Host_Seed), '-n', '10000', '-o', '0', '-t', cfgvars.Threads, cfgvars.Lib1, ReadsIn], stdout = outfilesai)
+
+                                with open('TEMPSAM2', 'w') as outfilesam:
+
+                                        call(['bwa', 'samse', cfgvars.Lib1, 'TEMPSAI2', ReadsIn], stdout = outfilesam)
+
+                        else:
+
+                                if cfgvars.Win:
+
+                                        call(['bowtie', '-q', '-n', str(cfgvars.Mismatches), '-l', str(cfgvars.Host_Seed), '-e', '100000', '--quiet', '--best', '-S', '--sam-nohead', cfgvars.Lib2, 'TEMPREADS2', 'TEMPSAM2'])
+
+                                else:
+
+                                        call(['bowtie', '-q', '-n', str(cfgvars.Mismatches), '-l', str(cfgvars.Host_Seed), '-e', '100000', '--quiet', '--mm', '-p', cfgvars.Threads, '--best', '-S', '--sam-nohead', cfgvars.Lib2, 'TEMPREADS2', 'TEMPSAM2'])
+
+                        with open('TEMPSAM2', 'r') as SAMIN2:
+
+                                for line in SAMIN2:
+
+                                        line = line.split('\t')
+
+                                        Name = line[0]
+
+                                        if Name[:3] in SamHeaders:
+
+                                                pass
+
+                                        else:
+
+                                            Mapping = FindReadMapping(line, cfgvars.Host_Seed, Seed)
+
+                                            if Mapping[0] != "NONE":
+
+                                                if Mapping[5] == "Y":
+
+                                                        #TempReads.write("@" + str(Name) + "\n" + str(Mapping[6]) + "\n+\n" + str(Mapping[7]) + "\n" )
+
+                                                        TempReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6]), str(Mapping[7])) )
+
+                                                else:
+
+                                                        pass
+
+                                                AddToReportDict(ReportDict, Name)
+
+                                            else:
+
+                                                if Mapping[5] == "Y":
+
+                                                        #TempReads.write("@" + str(Name) + "\n" + str(Mapping[6][1:]) + "\n+\n" + str(Mapping[7][1:])+ "\n" )
+
+                                                        TempReads.write("@%s\n%s\n+\n%s\n" % (str(Name), str(Mapping[6][1:]), str(Mapping[7][1:])) ) 
+
+                                                else:
+
+                                                        pass
+
+                                                AddToReportDict(ReportDict, Name)
+
+                else:
+
+                        pass
+
+        TempReads.close()
+
+                
+
+
+
+##      ----------------------------------------------------------------------------------------
+
+##      Function IterateAlignments() will call Bowtie and beging alignments starting with supplied input file
+
+##	and continuing with the generated TEMPREAD files until there no reads left.
+
+##	If providing a FASTA file, this get converted to a FASTQ file with uniform quality 
+
+##	scores of PHRED == 30 after the first Bowtie iteration
+
+##      ----------------------------------------------------------------------------------------
+
+
+
+def IterateAlignments(File):
+
+        if cfgvars.ReadType == '-f':
+
+                print "%s reads in input file." % Countreads(File, 'F')
+
+		Alignment(File, '-f', cfgvars.Seed)
+
+	else:
+
+                print "%s reads in input file." % Countreads(File, 'Q')
+
+		Alignment(File, '-q', cfgvars.Seed)
+
+        ReadsRemaining = Countreads('TEMPREADS', 'Q')
+
+        print "%s reads remaining to be aligned after first iteration." % (ReadsRemaining)
+
+        n = 1
+
+        while ReadsRemaining > 0:
+
+            n += 1
+
+            Alignment('TEMPREADS', '-q', cfgvars.Seed)
+
+            ReadsRemaining = Countreads('TEMPREADS', 'Q')
+
+            print "%s reads remaining to be aligned after %s iterations." % (ReadsRemaining, n)
+
+    
+
+##      ----------------------------------------------------------------------------------------
+
+##      ReportResults() Analyses the results from all the Bowtie calls and collates all the results 
+
+##	for each read into a single output and writes this to the final Output file.
+
+##      ----------------------------------------------------------------------------------------
+
+
+
+def ReportResults():
+
+        Report = open(cfgvars.File2,"a")
+
+        for k in ReportDict:
+
+            FinalAlignment = []
+
+            FinalAlignment.append(k)
+
+            Trimmednucs = ''
+
+            Code = []
+
+            for i in ReportDict[k]:
+
+                if i[0] == "SOME":
+
+                        if Trimmednucs:
+
+                                FinalAlignment.append(Trimmednucs)
+
+                                Code.append("%sU" % (str(len(Trimmednucs))))
+
+                        else:
+
+                                pass
+
+                        FinalAlignment.append(i[2])
+
+                        FinalAlignment.append(i[3])
+
+                        Trimmednucs = ''
+
+                        Code.append(i[1])
+
+                elif i[0] == 'NONE':
+
+                        Trimmednucs += i[1][:-1]
+
+            	else:
+
+			pass
+
+            Trimmednucs += i[4]
+
+            if len(Trimmednucs) > 0:
+
+			FinalAlignment.append(Trimmednucs)
+
+            		Code.append("%sU" % (str(len(Trimmednucs))))
+
+            else:
+
+                    pass
+
+            #FinalAlignment.append(str(Code))
+
+            #for i in FinalAlignment:
+
+            #        Report.write("%s\t" % (i))
+
+            [Report.write("%s\t" % (i)) for i in FinalAlignment]
+
+            Code = "".join(Code)
+
+            Report.write("%s\t\n" % (Code))
+
+        Report.close()
+
+
+
+##      ----------------------------------------------------------------------------------------
+
+##      Run Modules
+
+##      ----------------------------------------------------------------------------------------
+
+
+
+if __name__ == '__main__':
+
+        if cfgvars.Chunk:
+
+                with open(cfgvars.File1, 'r') as MAINFILE:
+
+                        ChunkNum = 0
+
+                        Read = MAINFILE.readline()
+
+                        while Read:
+
+                                ChunkedReads = open('ChunkedReads', 'w')
+
+                                ReadNum = 0
+
+                                while ReadNum < int(cfgvars.Chunk):
+
+                                        if Read:
+
+                                                if cfgvars.ReadType == '-f':
+
+                                                        ChunkedReads.write(Read)
+
+                                                        ChunkedReads.write(MAINFILE.readline())
+
+                                                else:
+
+                                                        ChunkedReads.write(Read)
+
+                                                        ChunkedReads.write(MAINFILE.readline())
+
+                                                        ChunkedReads.write(MAINFILE.readline())
+
+                                                        ChunkedReads.write(MAINFILE.readline())
+
+                                                Read = MAINFILE.readline()
+
+                                                ReadNum += 1
+
+                                        else:
+
+                                                ReadNum += 1
+
+                                ChunkedReads.close()
+
+                                ChunkNum += 1
+
+                                ReportDict = {}
+
+                                print "Begining alignments on Chunk Number %s" % ChunkNum
+
+                                IterateAlignments('ChunkedReads')
+
+                                print "Appending Results from Chunk Number %s to: " % ChunkNum, str(cfgvars.File2)
+
+                                ReportResults()
+
+        else:
+
+                ReportDict = {}
+
+                print "Begining alignments"
+
+                IterateAlignments(cfgvars.File1)
+
+                print "Reporting Results to: ", str(cfgvars.File2)
+
+                ReportResults()
+
+        if cfgvars.Compile:
+
+                if cfgvars.Aligner =='bwa':
+
+			cfgvars.RefsLib1, cfgvars.RefsLib2, cfgvars.Genes = ExtractRefDataBWA()
+
+                else:
+
+			cfgvars.RefsLib1, cfgvars.RefsLib2, cfgvars.Genes = ExtractRefData()
+
+                if cfgvars.DeDup:
+
+			UniquifyReport(cfgvars.File2, 'DeDuped_' + cfgvars.File2)
+
+			cfgvars.File2 = 'DeDuped_' + cfgvars.File2
+
+		else:
+
+			pass
+
+		print "Compiling Results and saving into individual outputs"
+
+		if args.Output_Dir and cfgvars.Compile:
+
+                        if not exists(str(args.Output_Dir)):
+
+                                cfgvars.Output_Dir = str(args.Output_Dir) + '/'
+
+                                makedirs(cfgvars.Output_Dir)
+
+                        else:
+
+                                print "Output Directory already exists!  Appending time to directory name to prevent overwrite."
+
+                                cfgvars.Output_Dir = str(args.Output_Dir) + str(int(time.time())) + '/'
+
+                                makedirs(cfgvars.Output_Dir)
+
+                else:
+
+                        cfgvars.Output_Dir = ''
+
+                if cfgvars.BED:
+
+                        if not exists(cfgvars.Output_Dir + 'BED_Files/'):
+
+                                makedirs(cfgvars.Output_Dir + 'BED_Files/')
+
+                        else:
+
+                                makedirs(cfgvars.Output_Dir + 'BED_Files_' + str(int(time.time())) + '/')
+
+                                print "WARNING: BED Folder already present in output directory!"
+
+                else:
+
+                        pass
+
+                ResultsSort(cfgvars.File2)
+
+
+
+finish = time.time()
+
+print "Time to complete in seconds: ", int(finish - start)
+
+
+
+##      ----------------------------------------------------------------------------------------
+
+##      End
+
+##      ----------------------------------------------------------------------------------------
+
+
+
+
+
+
+
--- ViReMa_0.6/Compiler_Module.py	2014-06-25 13:36:30.000000000 +0000
+++ ViReMa_0.6/Compiler_Module.py.new	2017-09-09 01:55:26.266087299 +0000
@@ -1,967 +1,1936 @@
-##      Copyright (c) 2013-2014 Andrew Laurence Routh
-##      
-##      Permission is hereby granted, free of charge, to any person obtaining a copy
-##      of this software and associated documentation files (the "Software"), to deal
-##      in the Software without restriction, including without limitation the rights
-##      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-##      copies of the Software, and to permit persons to whom the Software is
-##      furnished to do so, subject to the following conditions:
-##      
-##      The above copyright notice and this permission notice shall be included in
-##      all copies or substantial portions of the Software.
-##      
-##      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-##      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-##      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-##      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-##      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-##      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-##      THE SOFTWARE.
-##
-##      -------------------------------------------------------------------------------------------
-if __name__ == '__main__':
-    print '\n-------------------------------------------------------------------------------------------'
-    print 'ViReMa_0.6 - Viral Recombination Mapper - Compilation Module'
-    print 'Last modified 6/05/2014'
-    print '-------------------------------------------------------------------------------------------'
-
-import ConfigViReMa as cfgvars
-from re import finditer
-import time
-
-##      ------------------------------------------------------------------------------------------------------------
-##      Compound_Handling_Script will determine whether trimmed nucleotides found between recombination
-##      sites are present between the donor and accpetor sites for these two recombination events.
-##      If so, they are assumed to have arisen due to multiple recombination events occuring within close proximity.
-##      This is only a good assumption in viral genomes (where the number if possible matches is low) and
-##      when there are sufficient nucleotides in the trimmed sequence. This number is set at the command line
-##      wih the option: --Compound_Handling.  A default value of 10 is recommended.  This value must be
-##      larger than the MicroInDel number.
-##      ------------------------------------------------------------------------------------------------------------
-
-def Compound_Handling_Script(Donor, DonorSite, Insertion, AcceptorSite, uDelDicts, RecDicts, ReadName):
-                if "_RevStrand" in Donor:
-                        DonorA = ">" + Donor[:-10]
-                        Insertion = Rev_Comp(Insertion)
-                        DonorSite, AcceptorSite = AcceptorSite, DonorSite
-                else:
-                        DonorA = ">" + Donor
-                Frag = cfgvars.Genes[DonorA][int(DonorSite):int(AcceptorSite)]
-                if Insertion in Frag:
-                        Hits = [m.start() for m in finditer(Insertion, Frag)]
-                        if len(Hits) == 1:
-                                if "_RevStrand" in Donor:
-                                        #Unique Compound Recombination Site Found
-                                        NewAcceptorSite = str(int(Hits[0]) + int(DonorSite) + 1)
-                                        if int(NewAcceptorSite) - int(DonorSite) - 1 <= cfgvars.MicroInDel_Length:
-                                                AddToDict(Donor, Donor, NewAcceptorSite, DonorSite, uDelDicts, ReadName)
-                                        else:
-                                                AddToDict(Donor, Donor, NewAcceptorSite, DonorSite, RecDicts, ReadName)
-                                        NewDonorSite = str(int(Hits[0]) + int(DonorSite) + len(Insertion) + 1) 
-                                        if int(AcceptorSite) - int(NewDonorSite) - 1 <= cfgvars.MicroInDel_Length:              
-                                                AddToDict(Donor, Donor, AcceptorSite, NewDonorSite, uDelDicts, ReadName)
-                                        else:
-                                                AddToDict(Donor, Donor, AcceptorSite, NewDonorSite, RecDicts, ReadName)
-                                else:
-                                        #Unique Compound Recombination Site Found
-                                        NewAcceptorSite = str(int(Hits[0]) + int(DonorSite) + 1)
-                                        if int(NewAcceptorSite) - int(DonorSite) - 1 <= cfgvars.MicroInDel_Length:
-                                                AddToDict(Donor, Donor, DonorSite, NewAcceptorSite, uDelDicts, ReadName)
-                                        else:
-                                                AddToDict(Donor, Donor, DonorSite, NewAcceptorSite, RecDicts, ReadName)
-                                        NewDonorSite = str(int(Hits[0]) + int(DonorSite) + len(Insertion) + 1) 
-                                        if int(AcceptorSite) - int(NewDonorSite) - 1 <= cfgvars.MicroInDel_Length:              
-                                                AddToDict(Donor, Donor, NewDonorSite, AcceptorSite, uDelDicts, ReadName)
-                                        else:
-                                                AddToDict(Donor, Donor, NewDonorSite, AcceptorSite, RecDicts, ReadName)
-                                return "HIT"
-                
-##      ----------------------------------------------------------------------------------------------------------
-##      UniquifyReport() removes identical results.  Reads giving identical results may be PCR duplicates.  
-##      Similarly, finding unique multiple unique reads over single recombination junctions validates recombinant
-##      ----------------------------------------------------------------------------------------------------------
-
-def UniquifyReport(FileIn, FileOut):
-        print "Removing potential PCR duplicates..."
-        TempSet = set()
-        Dict = []
-        n = 0
-        with open(FileIn, 'r') as InputData:
-                CLE = str(InputData.readline())
-                VirusLib = str(InputData.readline())
-                #commandline entry
-                x = InputData.readline()
-                while x:
-                        x = x.split('\t', 1)
-                        if x[1] not in TempSet:
-                                y = str(x[0]) + '\t' + str(x[1])
-                                Dict.append(y)
-                                TempSet.add(x[1])
-                        n += 1
-                        x = InputData.readline()
-                print "Total of %s reads in original dataset" % n
-        with open(FileOut, 'w') as DeDupedData:
-                n = 0
-                DeDupedData.write(CLE)
-                DeDupedData.write(VirusLib)
-                for i in Dict:
-                        DeDupedData.write(i)
-                        n += 1
-                print "%s reads remaining after removing potential PCR duplicates" % n
-
-##      ----------------------------------------------------------------------------------------
-##      Function BedGraph_Plot() will find regions deleted or duplicated due to recombination and return
-##      a string string of frequencies and nucleotide positions. 
-##      ----------------------------------------------------------------------------------------
-
-def BEDGraph_Plot():
-        DelCover = {}
-        InsCover = {}
-        with open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Virus_Recombination_Results.bed","r") as Input_Data:
-                TrackName = Input_Data.readline()
-                for i in cfgvars.RefsLib1:
-                        i = '>' + i
-                        if "_RevStrand" not in i:
-                                DelCover[i] = [0] * len(cfgvars.Genes[i])
-                                InsCover[i] = [0] * len(cfgvars.Genes[i])
-                for line in Input_Data:
-                        line = line.split()
-                        Gene_Name = '>' + line[0]
-                        Donorsite = int(line[1])
-                        Acceptorsite = int(line[2])
-                        Count = int(line[4])
-                        Strand = line[5]
-                        #DonorSums[Donorsite] += Count
-                        #AcceptorSums[Acceptorsite] += Count
-                        if Strand == '+':
-                                if Donorsite < Acceptorsite:
-                                        while Donorsite < Acceptorsite:
-                                                DelCover[Gene_Name][Donorsite] += Count
-                                                Donorsite +=1
-                                elif Acceptorsite < Donorsite:
-                                        while Acceptorsite < Donorsite:
-                                                InsCover[Gene_Name][Acceptorsite] += Count
-                                                Acceptorsite +=1
-        OutputFile = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Virus_Conservation.bedgraph","w")
-        OutputFile.write('track type=bedGraph name="Virus_Conservation" description="Virus_Conservation"\n')
-        for i in DelCover:
-                n = 0
-                for j in DelCover[i]:
-                        OutputFile.write('%s\t%s\t%s\t%s\n' % (str(i[1:]), str(n), str(n+1), str(j)))
-                        n += 1
-        OutputFile.close()
-        OutputFile = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Virus_Duplications.bedgraph","w")
-        OutputFile.write('track type=bedGraph name="Virus_Duplications" description="Virus_Duplications"n"\n')
-        for i in InsCover:
-                n = 0
-                for j in InsCover[i]:
-                        OutputFile.write('%s\t%s\t%s\t%s\n' % (str(i[1:]), str(n), str(n+1), '-' + str(j)))
-                        n += 1
-        OutputFile.close()
-
-##      ----------------------------------------------------------------------------------------
-##      Function Rev_Comp() will return the Reverse Complement of a given DNA string
-##      ----------------------------------------------------------------------------------------
-
-def Rev_Comp(Seq):
-        Seq = Seq.upper()
-        basecomplement = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A', 'N': 'N'}
-        letters = list(Seq)
-        letters = [basecomplement[base] for base in letters]
-        return ''.join(letters)[::-1]
-
-##      ----------------------------------------------------------------------------------------------------
-##      Indices will find the locations of pertinent information in the results file as directed by the Code
-##      ----------------------------------------------------------------------------------------------------
-    
-def Indices(List):
-        n = 1
-        Ms = []
-        Xs = []
-        for i in List:
-                if i == "M":
-                        Ms.append(n)
-                        n+=2
-                else:
-                        Xs.append(n)
-                        n+=1
-        return [Ms, Xs]
-
-##      -------------------------------------------------------------------------------------------------------
-##      ExtractRefData() will find the names of the genes used in the virus or host genome references.
-##      Bowtie-inspect must be in $PATH.
-##      -------------------------------------------------------------------------------------------------------
-
-def ExtractRefData():
-        import ConfigViReMa as cfgvars
-        from subprocess import check_output
-        cfgvars.RefsLib1 = set()
-        cfgvars.RefsLib2 = set()
-        print "Extracting Virus Gene Names..."
-        z = check_output(['bowtie-inspect', '-a', '1000000', cfgvars.Lib1]).split()
-        cfgvars.Genes = {}
-        def RefsAppend(Lib, i):
-                Name = i.rstrip()
-                Lib.add(Name[1:])
-                Lib.add(Name[1:] + "_RevStrand")
-                return Name
-            
-        for i in z:
-                if i[0] == '>':
-                        Name = RefsAppend(cfgvars.RefsLib1, i)
-                else:
-                        if cfgvars.Compound_Handling or cfgvars.Defuzz or cfgvars.MicroInDel_Length or cfgvars.BED:
-                                Temp = []
-                                Temp.append(i.rstrip())
-                                Gene = "".join(Temp)
-                                cfgvars.Genes[Name] = Gene
-        if cfgvars.Lib2:
-                        print "Extracting Host Gene Names..."
-                        z = check_output(['bowtie-inspect', '-a', '1000000', cfgvars.Lib2]).split()
-                        for i in z:
-                                if i[0] == '>':
-                                        Name = RefsAppend(cfgvars.RefsLib2, i)
-                                else:
-                                        if cfgvars.Compound_Handling or cfgvars.Defuzz or cfgvars.MicroInDel_Length or cfgvars.BED:
-                                                Temp = []
-                                                Temp.append(i.rstrip())
-                                                Gene = "".join(Temp)
-                                                cfgvars.Genes[Name] = Gene
-        else:
-                        pass
-        print "Finished extracting gene data"
-        return cfgvars.RefsLib1, cfgvars.RefsLib2, cfgvars.Genes
-
-##      -------------------------------------------------------------------------------------------------------
-##      ExtractRefDataBWA() will find the names of the genes used in the virus or host genome references.
-##      Input is typical FASTA file, as per the BWA command line.
-##      -------------------------------------------------------------------------------------------------------
-
-def ExtractRefDataBWA():
-        import ConfigViReMa as cfgvars
-        cfgvars.RefsLib1 = []
-        cfgvars.RefsLib2 = []
-        cfgvars.Genes = {}
-        print "Extracting Virus Gene Data..."
-        with open(cfgvars.Lib1,'r') as FASTAIN:
-                for line in FASTAIN:
-                        if line[0] == '>':
-                                Name = line.rstrip()
-                                cfgvars.RefsLib1.append(Name[1:])
-                                cfgvars.RefsLib1.append(Name[1:] + "_RevStrand")
-                        else:
-                                if cfgvars.Compound_Handling or cfgvars.Defuzz or cfgvars.MicroInDel_Length:
-                                        if Name in cfgvars.Genes:
-                                                cfgvars.Genes[Name] += line.rstrip()
-                                        else:
-                                                cfgvars.Genes[Name] = line.rstrip()
-
-        if cfgvars.Lib2:
-                print "Extracting Host Gene Data..."
-                with open(cfgvars.Lib2,'r') as FASTAIN:
-                        for line in FASTAIN:
-                                if line[0] == '>':
-                                        Name = line.rstrip()
-                                        cfgvars.RefsLib2.append(Name[1:])
-                                        cfgvars.RefsLib2.append(Name[1:] + "_RevStrand")
-                                else:
-                                        if cfgvars.Compound_Handling or cfgvars.Defuzz or cfgvars.MicroInDel_Length:
-                                                if Name in cfgvars.Genes:
-                                                        cfgvars.Genes[Name] += line.rstrip()
-                                                else:
-                                                        cfgvars.Genes[Name] = line.rstrip()
-        print "Finished extracting gene data"
-        return cfgvars.RefsLib1, cfgvars.RefsLib2, cfgvars.Genes
-    
-##      -------------------------------------------------------------------------------------------
-##      AddToDict() takes the Donor and Acceptor sites and references for a given recombination event,
-##      and collates them into a Dictionary which will later be written to a results file.
-##      -------------------------------------------------------------------------------------------
-
-def AddToDict(Donor, Acceptor, DonorSite, AcceptorSite, Dict, ReadName):
-        Fuzz = 0
-        if cfgvars.Defuzz:
-                if "_RevStrand" in Donor:
-                        if int(AcceptorSite) != int(DonorSite) - 1:
-                                Fuzz = FindFuzz(Donor, DonorSite, Acceptor, AcceptorSite, (cfgvars.MaxFuzz+1))
-                                if Fuzz > 0:
-                                        if cfgvars.Defuzz == 'Centre':
-                                                DonorSite = str(int(DonorSite) + ((Fuzz+1)/2))
-                                                AcceptorSite = str(int(AcceptorSite) + ((Fuzz+1)/2))
-                                        elif cfgvars.Defuzz == 'Right':
-                                                DonorSite = str(int(DonorSite) + Fuzz)
-                                                AcceptorSite = str(int(AcceptorSite) + Fuzz)
-                                        else:
-                                                pass
-                        else:
-                                pass
-                else:
-                        if int(AcceptorSite) != int(DonorSite) + 1:
-                                Fuzz = FindFuzz(Donor, DonorSite, Acceptor, AcceptorSite, (cfgvars.MaxFuzz+1))
-                                if Fuzz > 0:
-                                        if cfgvars.Defuzz == 'Centre':
-                                                DonorSite = str(int(DonorSite) - (Fuzz/2))
-                                                AcceptorSite = str(int(AcceptorSite) - (Fuzz/2))
-                                        elif cfgvars.Defuzz == 'Left':
-                                                DonorSite = str(int(DonorSite) - Fuzz)
-                                                AcceptorSite = str(int(AcceptorSite) - Fuzz)
-                                        else:
-                                                pass
-                        else:
-                                pass
-        else:
-                pass
-        if Fuzz <= cfgvars.MaxFuzz:
-                if (Donor + "_to_" + Acceptor) not in Dict:
-                        Dict[Donor + "_to_" + Acceptor] = {}
-                else:
-                        pass
-                if cfgvars.ReadNamesEntry:
-                        if (DonorSite + "_to_" + AcceptorSite) not in Dict[Donor + "_to_" + Acceptor]:
-                                Dict[Donor + "_to_" + Acceptor][DonorSite + "_to_" + AcceptorSite] = [1, [ReadName]]
-                        else:
-                                Dict[Donor + "_to_" + Acceptor][DonorSite + "_to_" + AcceptorSite][0] += 1
-                                Dict[Donor + "_to_" + Acceptor][DonorSite + "_to_" + AcceptorSite][1].append(ReadName)
-                else:
-                        if (DonorSite + "_to_" + AcceptorSite) not in Dict[Donor + "_to_" + Acceptor]:
-                                Dict[Donor + "_to_" + Acceptor][DonorSite + "_to_" + AcceptorSite] = 1
-                        else:
-                                Dict[Donor + "_to_" + Acceptor][DonorSite + "_to_" + AcceptorSite] += 1
-        else:
-                pass
-
-##      ----------------------------------------------------------------------------------------------------------------
-##      FindFuzz() will determine the number of overlapping nucleotides in the donor region and the nucleotides
-##      preceeding the acceptor site.
-##      -----------------------------------------------------------------------------------------------------------------
-
-def FindFuzz(Donor, DonorSite, Acceptor, AcceptorSite, MaxFuzz):
-        F = 0
-        if "_RevStrand" in Donor:
-                Gene = '>' + Donor[:-10]
-                DonorSeq = Rev_Comp(cfgvars.Genes[Gene][int(DonorSite) - 1:int(DonorSite) - 1 + MaxFuzz])
-        else:
-                Gene = '>' + Donor
-                DonorSeq = cfgvars.Genes[Gene][int(DonorSite) - MaxFuzz:int(DonorSite)]
-        if "_RevStrand" in Acceptor:
-                Gene = '>' + Acceptor[:-10]
-                if int(AcceptorSite) + MaxFuzz > len(cfgvars.Genes[Gene]):
-                        UpstreamAcceptorSeq = Rev_Comp(cfgvars.Genes[Gene][int(AcceptorSite):])
-                else:
-                        UpstreamAcceptorSeq = Rev_Comp(cfgvars.Genes[Gene][int(AcceptorSite): int(AcceptorSite) + MaxFuzz])
-        else:
-                Gene = '>' + Acceptor
-                if int(AcceptorSite) - 1 - MaxFuzz < 0:
-                        UpstreamAcceptorSeq = cfgvars.Genes[Gene][0: int(AcceptorSite) - 1]
-                else:
-                        UpstreamAcceptorSeq = cfgvars.Genes[Gene][int(AcceptorSite) - 1 - MaxFuzz: int(AcceptorSite) - 1]
-        for i in range(len(UpstreamAcceptorSeq)):
-                try:
-                    if UpstreamAcceptorSeq[-i-1] == DonorSeq[-i-1]:
-                            F += 1
-                    else:
-                            break
-                except:
-                        break
-        return F
-
-##      -----------------------------------------------------------------------------------------------------------------
-##      AddInsToDict() takes the Donor and Acceptor sites, references and trimmed nucleotides for a given Insertion event
-##      and collate them into a Dictionary which will later be written to a results file.
-##      -----------------------------------------------------------------------------------------------------------------
-
-def AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, Dict, ReadName):
-                if Donor not in Dict:
-                        Dict[Donor] = {}
-                else:
-                        pass
-                if cfgvars.ReadNamesEntry:
-                        if (str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)) not in Dict[Donor]:
-                                Dict[Donor][str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)] = [1, [ReadName]]
-                        else:
-                                Dict[Donor][str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)][0] += 1
-                                Dict[Donor][str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)][1].append(ReadName)
-                else:
-                        if (str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)) not in Dict[Donor]:
-                                Dict[Donor][str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)] = 1
-                        else:
-                                Dict[Donor][str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)] += 1
-
-##      -------------------------------------------------------------------------------------------
-##      ResultsSort() is the backbone of the results compilation script.  It will take each line from the results
-##      output from ViReMa and determine the nature of every discovered event.  This includes recombinations, insertions, subsitutions, etc.
-##      The Code appended to the end of each line in the ViReMa output allows ResultsSort() to group particular events.
-##      The finer details are then established based upon parameters set in the command-line (e.g. MicroInDel length), and upon the
-##      information provided in the ViReMa output.
-##      -------------------------------------------------------------------------------------------
-
-def ResultsSort(File1):
-        from re import findall
-        from math import fabs
-
-        ##      -------------------------------------------------------------------------------------------
-        ##      WriteFinalDict() will read all the information collated in each Dictionary and write out the
-        ##      results to the results files.
-        ##      -------------------------------------------------------------------------------------------
-        
-        def WriteFinalDict(DictName, Mod):
-            
-                ##      ---------------------------------------------------------------
-                ##      WritetoBedFile() will append the entry to the optional BED File
-                ##      ---------------------------------------------------------------
-            
-                def WritetoBEDFile(Genes, Entry, TargetFile):
-                        # Genes is in format: 'Donor_to_Acceptor'
-                        # Entry is in format: [DonorSite, 'to', AcceptorSite, '#', Count]
-                        Genes = Genes.split("_to_")
-                        #print Genes, Entry, TargetFile
-                        if Genes[0][-10:] == "_RevStrand":
-                                            Genes[0] = Genes[0][:-10]
-                                            Strandedness = '-'
-                        else:
-                                            Strandedness = '+'
-                        BED_OUTPUT = "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % (str(Genes[0]), str(Entry[0]), str(Entry[2]), 'NAMES_TBD', str(Entry[4]), Strandedness, str(Entry[0]), str(Entry[2]))
-                        if TargetFile == VirusRecs:
-                                        if Genes[0] == Genes[1]:
-                                                VirusRecs_BED.write(BED_OUTPUT)
-                                        else:
-                                                pass
-                        elif TargetFile == VirusuIns:
-                                        VirusuRecs_BED.write(BED_OUTPUT)
-                        elif TargetFile == VirusuDels:
-                                        VirusuRecs_BED.write(BED_OUTPUT)
-                        elif TargetFile == HostRecs:
-                                        if Genes[0] == Genes[1]:
-                                                HostRecs_BED.write(BED_OUTPUT)
-                                        else:
-                                                pass
-                        elif TargetFile == HostuIns:
-                                        HostuRecs_BED.write(BED_OUTPUT)
-                        elif TargetFile == HostuDels:
-                                        HostuRecs_BED.write(BED_OUTPUT)
-                        else:
-                                        pass
-                ##      ---------------------------------------------------------------
-
-                for k in DictName:
-                        Libs = k.split("_to_")
-                        n = 0
-                        for i in Libs:
-                                if i[-10:] == "_RevStrand":
-                                        Libs[n] = Libs[n][:-10]
-                                n+=1
-                        if Mod == 'Recs':
-                                if Libs[0] in cfgvars.RefsLib1 and Libs[1] in cfgvars.RefsLib1:
-                                        TargetFile = VirusRecs
-                                elif Libs[0] in cfgvars.RefsLib2 and Libs[1] in cfgvars.RefsLib2:
-                                        TargetFile = HostRecs
-                                else:
-                                        TargetFile = VirustoHostRecs
-                        elif Mod == 'uDel':
-                                if Libs[0] in cfgvars.RefsLib1 and Libs[1] in cfgvars.RefsLib1:
-                                        TargetFile = VirusuDels
-                                elif Libs[0] in cfgvars.RefsLib2 and Libs[1] in cfgvars.RefsLib2:
-                                        TargetFile = HostuDels
-                                else:
-                                        pass                        
-                        elif Mod == 'uIns':
-                                if Libs[0] in cfgvars.RefsLib1:
-                                        TargetFile = VirusuIns
-                                else:
-                                        TargetFile = HostuIns
-                        elif Mod == 'Ins':
-                                if Libs[0] in cfgvars.RefsLib1:
-                                        TargetFile = VirusInsertions
-                                else:
-                                        TargetFile = HostInsertions
-                        elif Mod == 'Sub':
-                                if Libs[0] in cfgvars.RefsLib1:
-                                        TargetFile = VirusSubstitutions
-                                else:
-                                        TargetFile = HostSubstitutions
-                        Temp = []
-                        if cfgvars.ReadNamesEntry:
-                                for i in DictName[k]:
-                                        x = [(str(i) + "_#_" + str(DictName[k][i][0])).split("_"), DictName[k][i][1]]
-                                        Temp.append(x)
-                                Temp.sort(key=lambda a:int(a[0][4]), reverse=True)
-                                TargetFile.write("@NewLibrary: " + str(k) + "\n")
-                                for i in Temp:
-                                        j = '_'.join(i[0])
-                                        TargetFile.write(str(j) + "\n")
-                                        for Names in i[1]:
-                                                TargetFile.write(str(Names) + '\t')
-                                        TargetFile.write('\n')
-                                TargetFile.write("\n@EndofLibrary\n")
-                        else:
-                                for i in DictName[k]:
-                                        x = (str(i) + "_#_" + str(DictName[k][i])).split("_")
-                                        Temp.append(x)
-                                Temp.sort(key=lambda a:int(a[4]), reverse=True)
-                                TargetFile.write("@NewLibrary: " + str(k) + "\n")
-                                for i in Temp:
-                                        if cfgvars.BED:
-                                                if cfgvars.Lib2:
-                                                        if cfgvars.MicroInDel_Length > 0:
-                                                                BEDableTargetFiles = [VirusRecs, VirusuDels, HostRecs, HostuDels, VirusuIns, HostuIns]
-                                                        else:
-                                                                BEDableTargetFiles = [VirusRecs, HostRecs]
-                                                else:
-                                                        if cfgvars.MicroInDel_Length > 0:
-                                                                BEDableTargetFiles = [VirusRecs, VirusuDels, VirusuIns]
-                                                        else:
-                                                                BEDableTargetFiles = [VirusRecs]
-                                                if TargetFile in BEDableTargetFiles:
-                                                        WritetoBEDFile(k, i, TargetFile)
-                                                        
-                                                else:
-                                                        pass
-                                        else:
-                                                pass
-                                        j = '_'.join(i)
-                                        TargetFile.write(str(j) + "\t")
-                                TargetFile.write("\n@EndofLibrary\n")
-        
-        #Dictionaries 
-        InsDicts = {}
-        SubDicts = {}
-        uDelDicts = {}
-        uInsDicts = {}
-        RecDicts = {}
-
-        #Counts for events used for printed summary
-        Padcount = 0
-        Totalcount = 0
-        uCount = 0
-        InsCount = 0
-        SubCount = 0
-        CompoundCount = 0
-        RecombCount = 0
-        ErrorCount = 0
-        ViralRecombinationCount = 0
-        HostRecombinationCount = 0
-        ViraltoHostRecombinationCount = 0
-        UnknownRecombinationCount = 0
-        UnmappedReadsCount = 0
-        UnmappedReads = open(cfgvars.Output_Dir + cfgvars.FileTag + "UnMappedReads.txt","w")
-        SingleAlignment = open(cfgvars.Output_Dir + cfgvars.FileTag + "Single_Alignments.txt","w")
-        UnknownRecombinations = open(cfgvars.Output_Dir + cfgvars.FileTag + "Unknown_Recombinations.txt", "w")
-
-        with open(File1,"r") as InRecombs:
-            skip = InRecombs.readline()
-            skip = InRecombs.readline()
-            #Meat of script, reads each line from ViReMa.py output and stores details into dictionaries
-            wholeline = InRecombs.readline()
-            while wholeline:
-                Totalcount += 1
-                line = wholeline.split("\t")[:-1]
-                ReadName = line[0]
-                Code = ''.join(findall(r"\D", line[-1]))
-                Index = Indices(Code)
-                MCount = Code.count("M")
-                if "M" not in Code:
-                                #UnMapped Read
-                                UnmappedReads.write(wholeline)
-                                UnmappedReadsCount += 1
-                elif MCount == 1:
-                                #Singly mapped Read
-                                PadLongerThanSeed = False
-                                for i in Index[1]:
-                                        if len(line[i]) >= int(cfgvars.Seed):
-                                                PadLongerThanSeed = True
-                                        else:
-                                                pass
-                                if PadLongerThanSeed:
-                                        #Mapable region recombined
-                                        UnknownRecombinationCount += 1
-                                        UnknownRecombinations.write(wholeline)
-                                else:
-                                        #Single non-padded Alignment
-                                        SingleAlignment.write(wholeline)
-                                        Padcount += 1
-                else:
-                                #Multiple mappings, means either recombination, insertion, or substitution.
-                                n=0
-                                UnRec = ''
-                                for i in Index[0][:-1]:
-                                        Donor = line[i]
-                                        if "RevStrand" in line[i+1]:
-                                                DonorSite = line[i+1].split("_")[2]
-                                                Donor += "_RevStrand"
-                                        else:
-                                                DonorSite = line[i+1].split("_")[1]
-                                        if Index[0][n+1] == i + 2:
-                                                #Recombination Event
-                                                Acceptor = line[i+2]
-                                                if "RevStrand" in line[i+3]:
-                                                        AcceptorSite = line[i+3].split("_")[0]
-                                                        Acceptor += "_RevStrand"
-                                                else:
-                                                        AcceptorSite = line[i+3].split("_")[0]
-                                                if Donor == Acceptor and "_RevStrand" in Donor and fabs(int(DonorSite) - int(AcceptorSite) - 1) <= cfgvars.MicroInDel_Length:
-                                                                if int(DonorSite) - int(AcceptorSite) - 1 < 0:
-                                                                        #MicroInsertion on negative strand
-                                                                        uCount += 1
-                                                                        DonorA = ">" + Donor[:-10]
-                                                                        Insertion = cfgvars.Genes[DonorA][int(DonorSite) - 1:int(AcceptorSite)]
-                                                                        Insertion = Rev_Comp(Insertion)
-                                                                        NewAcceptorSite = str(int(DonorSite) - 1)
-                                                                        AddInsToDict(Donor, DonorSite, NewAcceptorSite, Insertion, uInsDicts, ReadName)
-                                                                elif int(DonorSite) - int(AcceptorSite) - 1 > 0:
-                                                                        #MicroDeletion on negative strand
-                                                                        uCount += 1
-                                                                        AddToDict(Donor, Acceptor, DonorSite, AcceptorSite, uDelDicts, ReadName)
-                                                elif Donor == Acceptor and fabs(int(DonorSite) - int(AcceptorSite) + 1) <= cfgvars.MicroInDel_Length:
-                                                                if int(DonorSite) - int(AcceptorSite) + 1 > 0:
-                                                                        #MicroInsertion
-                                                                        uCount += 1
-                                                                        DonorA = ">" + Donor
-                                                                        Insertion = cfgvars.Genes[DonorA][int(AcceptorSite) - 1:int(DonorSite)]
-                                                                        NewAcceptorSite = str(int(DonorSite) + 1)
-                                                                        AddInsToDict(Donor, DonorSite, NewAcceptorSite, Insertion, uInsDicts, ReadName)
-                                                                elif int(DonorSite) - int(AcceptorSite) + 1 < 0:
-                                                                        #MicroDeletion
-                                                                        uCount += 1
-                                                                        AddToDict(Donor, Acceptor, DonorSite, AcceptorSite, uDelDicts, ReadName)
-                                                else:
-                                                        #Direct Recombination Event
-                                                        RecombCount += 1
-                                                        AddToDict(Donor, Acceptor, DonorSite, AcceptorSite, RecDicts, ReadName)
-                                                        if Donor in cfgvars.RefsLib1 and Acceptor in cfgvars.RefsLib1:
-                                                                ViralRecombinationCount +=1
-                                                        elif Donor in cfgvars.RefsLib2 and Acceptor in cfgvars.RefsLib2:
-                                                                HostRecombinationCount += 1
-                                                        else:
-                                                                ViraltoHostRecombinationCount += 1
-                                        else:
-                                                #Insertion between mapped Segments
-                                                Acceptor = line[i+3]
-                                                Insertion = line[i+2]
-                                                if "RevStrand" in line[i+4]:
-                                                        AcceptorSite = line[i+4].split("_")[0]
-                                                        Acceptor += "_RevStrand"
-                                                else:
-                                                        AcceptorSite = line[i+4].split("_")[0]
-                                                if Acceptor == Donor and "_RevStrand" in Donor and int(DonorSite) == (int(AcceptorSite) + 1):
-                                                        #Simple Insertion Event in negative strand
-                                                        if len(Insertion) >= cfgvars.MicroInDel_Length:
-                                                                InsCount += 1
-                                                                AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, InsDicts, ReadName)
-                                                        else:
-                                                                #MicroInDel on negative strand 
-                                                                uCount += 1
-                                                                AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, uInsDicts, ReadName)
-                                                elif Acceptor == Donor and int(AcceptorSite) == (int(DonorSite) + 1):
-                                                        #Simple Insertion Event
-                                                        if len(Insertion) >= cfgvars.MicroInDel_Length:
-                                                                InsCount += 1
-                                                                AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, InsDicts, ReadName)
-                                                        else:
-                                                                uCount += 1
-                                                                AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, uInsDicts, ReadName)       
-                                                elif int(AcceptorSite) == (int(DonorSite) + len(Insertion) + 1) and Acceptor == Donor:
-                                                        #Direct Substitution
-                                                        if len(Insertion) <= cfgvars.Mismatches:
-                                                                #Mismatch, not Substitution
-                                                                MCount -= 1
-                                                                if MCount == 1:
-                                                                        #Singly mapped Read
-                                                                        PadLongerThanSeed = ''
-                                                                        for i in Index[1]:
-                                                                                if len(line[i]) >= int(cfgvars.Seed) or len(line[i]) >= int(cfgvars.Host_Seed):
-                                                                                        PadLongerThanSeed += 'X'
-                                                                                else:
-                                                                                        pass
-                                                                        if PadLongerThanSeed:
-                                                                                #Mapable region recombined
-                                                                                UnknownRecombinationCount += 1
-                                                                                UnknownRecombinations.write(wholeline)
-                                                                        else:
-                                                                                #Single non-padded Alignment
-                                                                                SingleAlignment.write(wholeline)
-                                                                                Padcount += 1
-                                                                else:
-                                                                        pass
-                                                                    
-                                                        else:
-                                                                SubCount += 1
-                                                                AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, SubDicts, ReadName)
-                                                elif int(DonorSite) == (int(AcceptorSite) + len(Insertion) + 1) and Acceptor == Donor and "_RevStrand" in Donor:
-                                                        #Direct Substitution on negative strand
-                                                        if len(Insertion) <= cfgvars.Mismatches:
-                                                                #Mismatch, not Substitution
-                                                                MCount -= 1
-                                                                if MCount == 1:
-                                                                        #Singly mapped Read
-                                                                        PadLongerThanSeed = ''
-                                                                        for i in Index[1]:
-                                                                                if len(line[i]) >= int(cfgvars.Seed) or len(line[i]) >= int(cfgvars.Host_Seed):
-                                                                                        PadLongerThanSeed += 'X'
-                                                                                else:
-                                                                                        pass
-                                                                        if PadLongerThanSeed:
-                                                                                #Mapable region recombined
-                                                                                UnknownRecombinationCount += 1
-                                                                                UnknownRecombinations.write(wholeline)
-                                                                        else:
-                                                                                #Single non-padded Alignment
-                                                                                SingleAlignment.write(wholeline)
-                                                                                Padcount += 1
-                                                                else:
-                                                                        pass
-                                                        else:
-                                                                SubCount += 1
-                                                                AddInsToDict(Donor, AcceptorSite, DonorSite, Insertion, SubDicts, ReadName)
-                                                else:
-                                                        if len(Insertion) >= int(cfgvars.Seed) or len(Insertion) >= int(cfgvars.Host_Seed):
-                                                                #Mapable Insertion/Recombination
-                                                                UnknownRecombinationCount += 1
-                                                                UnRec = 'Y'
-                                                        else:
-                                                                if cfgvars.Compound_Handling and len(Insertion) > int(cfgvars.Compound_Handling) and Donor == Acceptor and Donor in cfgvars.RefsLib1:
-                                                                        #Compound Recombination
-                                                                        CompoundCount += 1
-                                                                        CompTest = Compound_Handling_Script(Donor, DonorSite, Insertion, AcceptorSite, uDelDicts, RecDicts, ReadName)
-                                                                        if CompTest == "HIT":
-                                                                                RecombCount += 2
-                                                                                ViralRecombinationCount += 2
-                                                                                CompoundCount += 1
-                                                                        else:
-                                                                                #Unknown Compound
-                                                                                UnRec = 'Y'
-                                                                                UnknownRecombinationCount += 1
-                                                                else:
-                                                                        #Unknown Insertion.
-                                                                        UnknownRecombinationCount += 1
-                                                                        UnRec = 'Y'
-                                        n+=1 
-                                if UnRec:
-                                        UnknownRecombinations.write(wholeline)
-                                else:
-                                        pass
-                wholeline = InRecombs.readline()
-        
-        #Output Files for each type of event
-        VirusSubstitutions = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus_Substitutions.txt","w")
-        VirusInsertions = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus_Insertions.txt","w")
-        VirusRecs = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus_Recombination_Results.txt","w")
-        if cfgvars.MicroInDel_Length > 0:
-                VirusuDels = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus_MicroDeletions.txt","w")
-                VirusuIns = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus_MicroInsertions.txt","w")
-        else:
-                pass
-        if cfgvars.Lib2:
-                HostSubstitutions = open(cfgvars.Output_Dir + cfgvars.FileTag + "Host_Substitutions.txt","w")
-                HostInsertions = open(cfgvars.Output_Dir + cfgvars.FileTag + "Host_Insertions.txt","w")
-                HostRecs = open(cfgvars.Output_Dir + cfgvars.FileTag + "Host_Recombination_Results.txt","w")
-                if cfgvars.MicroInDel_Length > 0:
-                        HostuDels = open(cfgvars.Output_Dir + cfgvars.FileTag + "Host_MicroDeletions.txt","w")
-                        HostuIns = open(cfgvars.Output_Dir + cfgvars.FileTag + "Host_MicroInsertions.txt","w")
-                else:
-                        pass
-                VirustoHostRecs = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus-to-Host_Recombination_Results.txt","w")
-        else:
-                pass
-
-        if cfgvars.BED:
-                #Create optional BED files.
-                VirusRecs_BED = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Virus_Recombination_Results.bed","a")
-                VirusRecs_BED.write('track name=Virus_Recombinations description="Virus_Recombinations" graphType=junctions\n')
-                if cfgvars.MicroInDel_Length > 0:
-                        VirusuRecs_BED = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Virus_MicroRecombinations.bed","a")
-                        VirusuRecs_BED.write('track name=Virus_MicroInDels description="Virus_MicroInDels" graphType=junctions\n')
-                else:
-                        pass
-                if cfgvars.Lib2:
-                        HostRecs_BED = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Host_Recombination_Results.bed","a")
-                        HostRecs_BED.write('track name=Host_Recombinations description="Host_Recombinations" graphType=junctions\n')
-                        if cfgvars.MicroInDel_Length > 0:
-                                HostuRecs_BED = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Host_MicroRecombinations.bed","a")
-                                HostuRecs_BED.write('track name=Host_MicroInDels description="Host_MicroInDels" graphType=junctions\n')
-                        else:
-                                pass
-                else:
-                        pass
-                    
-        ##      Take final Dictionaries of recombination events are write out to files
-        print "Writing sorted results to individual output files..."
-        WriteFinalDict(RecDicts, 'Recs')
-        if cfgvars.MicroInDel_Length > 0:
-                WriteFinalDict(uDelDicts, 'uDel')
-                WriteFinalDict(uInsDicts, 'uIns')
-        else:
-                pass
-        WriteFinalDict(InsDicts, 'Ins')
-        WriteFinalDict(SubDicts, 'Sub')
-
-        ##      Print summary
-        print "---------------------------------------------------------------------------------------------------------------------"
-        print "Total of %s reads have been analysed:" % Totalcount
-        print "%s were single mapping reads with pads." % Padcount
-        print "%s Straight-forward Recombination Events detected"% RecombCount
-        print "of which %s were Viral Recombinations, %s were Host Recombinations and %s were Virus-to-Host Recombinations" % (ViralRecombinationCount, HostRecombinationCount, ViraltoHostRecombinationCount)
-        if cfgvars.MicroInDel_Length > 0:
-                print "%s were MicroIndels below a threshold of less than or equal to %s nucleotides." % (uCount, cfgvars.MicroInDel_Length)
-        else:
-                pass
-        print "%s UnIdentified Insertion Events." % InsCount
-        print "%s Nucleotide Subsitution events, including mismatches that preserve the gene length." % SubCount
-        if cfgvars.Compound_Handling:
-                print "%s Compound Recombination Events detected." % CompoundCount
-        else:
-                pass
-        print "%s events were Unknown or Ambiguous Recombination Events." % UnknownRecombinationCount
-        print "%s reads were completely unmapped." % UnmappedReadsCount
-
-        #Close all output files and finish
-        UnmappedReads.close()
-        InRecombs.close()
-        SingleAlignment.close()
-        UnknownRecombinations.close()
-        VirusRecs.close()
-        if cfgvars.MicroInDel_Length > 0:
-                VirusuIns.close()
-                VirusuDels.close()
-        else:
-                pass
-        VirusSubstitutions.close()
-        VirusInsertions.close()
-        if cfgvars.Lib2:
-                HostRecs.close()
-                VirustoHostRecs.close()
-                HostInsertions.close()
-                if cfgvars.MicroInDel_Length > 0:
-                        HostuDels.close()
-                        HostuIns.close()
-                else:
-                        pass
-                HostSubstitutions.close()
-        else:
-                pass
-        if cfgvars.BED:
-                VirusRecs_BED.close()
-                if cfgvars.MicroInDel_Length > 0:
-                        VirusuRecs_BED.close()
-                else:
-                        pass
-                if cfgvars.Lib2:
-                        HostRecs_BED.close()
-                        if cfgvars.MicroInDel_Length > 0:
-                                HostuRecs_BED.close()
-                        else:
-                                pass
-                else:
-                        pass
-                BEDGraph_Plot()
-        else:
-                pass
-
-##      -------------------------------------------------------------------------------------------
-##      This module can be run seperately from the main ViReMa script. This may be useful when tweeking variables such
-##      as the MicroInDel length or Compound_Handling, or when combining the results from multiple instances of ViReMa.
-##      Consequently, the following code takes arguments from command line, and sends them to the config file for cross-module access.
-##      Results Compilation is then initiated as normal.
-##      -------------------------------------------------------------------------------------------
-
-if __name__ == '__main__':
-        from os.path import exists
-        from os import makedirs
-        import argparse
-        parser = argparse.ArgumentParser()
-        parser.add_argument("Input_Data", help= "UnCompiled Results file from ViReMa run")
-        parser.add_argument("--Output_Tag", help= "Enter a tag name that will be appended to end of each output file.")
-        parser.add_argument("-DeDup", action='store_true', help="Remove potential PCR duplicates. Default is off.")
-        parser.add_argument("-ReadNamesEntry", action='store_true', help="Append Read Names contributing to each compiled result. Default is off.")
-        parser.add_argument("--Defuzz", help="Choose how to defuzz data:  '5' to report at 5' end of fuzzy region, '3' to report at 3' end, or '0' to report in centre of fuzzy region. Default is no fuzz handling (similar to choosing Right - see Routh et al).")
-        parser.add_argument("--MaxFuzz", help="Select maximum allowed length of fuzzy region. Recombination events with longer fuzzy regions will not be reported. Default is Seed Length.")
-        parser.add_argument("--MicroInDel_Length", help= "Size of MicroInDels - these are common artifacts of cDNA preparation.  See Routh et al JMB 2012. Default size is 0)")
-        parser.add_argument("--Compound_Handling", help= "Select this option for compound recombination event mapping (see manual for details). Enter number of nucleotides to map (must be less than Seed, and greater than number of nts in MicroInDel). Default is off.")
-        parser.add_argument("--Output_Dir", help= "Enter a directory name that all compiled output files will be saved in.")
-        parser.add_argument("-BED", action='store_true', help= "Output recombination data into BED files.")
-        args = parser.parse_args()
-        File1 = str(args.Input_Data)
-        with open(File1,"r") as InRecombs:
-                #Find arguments used in Mapping Phase from ViReMa.py
-                cfgvars.Lib1 = InRecombs.readline().rstrip()
-                CommandLineEntry = InRecombs.readline()[1:-3].split("', '")
-                if "--Host_Index" in CommandLineEntry:
-                        cfgvars.Lib2 = CommandLineEntry[CommandLineEntry.index("--Host_Index")+1]
-                else:
-                        cfgvars.Lib2 = None
-                if "--Seed" in CommandLineEntry:
-                        cfgvars.Seed = CommandLineEntry[CommandLineEntry.index("--Seed")+1]
-                else:
-                        cfgvars.Seed = '25'
-                if "--Host_Seed" in CommandLineEntry:
-                        cfgvars.Host_Seed = CommandLineEntry[CommandLineEntry.index("--Host_Seed")+1]
-                else:
-                        cfgvars.Host_Seed = cfgvars.Seed
-                if "--N" in CommandLineEntry:
-                        cfgvars.Mismatches = int(CommandLineEntry[CommandLineEntry.index("--N")+1])
-                else:
-                        cfgvars.Mismatches = 1
-        if args.Output_Tag:
-                cfgvars.FileTag = str(args.Output_Tag)
-        else:
-                cfgvars.FileTag = ''
-        if args.Defuzz == '3':
-                cfgvars.Defuzz = 'Right'
-        elif args.Defuzz == '5':
-                cfgvars.Defuzz = 'Left'
-        elif args.Defuzz == '0':
-                cfgvars.Defuzz = 'Centre'
-        else:
-                cfgvars.Defuzz = False
-        if args.DeDup:
-                cfgvars.DeDup = True
-        else:
-                cfgvars.DeDup = False
-        if args.ReadNamesEntry:
-                cfgvars.ReadNamesEntry = True
-        else:
-                cfgvars.ReadNamesEntry = False
-        if args.MaxFuzz:
-                cfgvars.MaxFuzz = int(args.MaxFuzz)
-        else:
-                cfgvars.MaxFuzz = int(cfgvars.Seed)
-        if args.Compound_Handling:
-                cfgvars.Compound_Handling = str(args.Compound_Handling)
-        else:
-                cfgvars.Compound_Handling = ''
-        if args.MicroInDel_Length:
-                cfgvars.MicroInDel_Length = int(args.MicroInDel_Length)
-        else:
-                cfgvars.MicroInDel_Length = 0
-        if args.BED:
-                cfgvars.BED = True
-        else:
-                cfgvars.BED = False
-        if args.Output_Dir:
-                if not exists(str(args.Output_Dir)):
-                        cfgvars.Output_Dir = str(args.Output_Dir) + '/'
-                        makedirs(cfgvars.Output_Dir)
-                else:
-                        print "Output Directory already exists!  Appending time to directory name to prevent overwrite."
-                        cfgvars.Output_Dir = str(args.Output_Dir) + str(int(time.time())) + '/'
-                        makedirs(cfgvars.Output_Dir)
-        if cfgvars.BED:
-                if not exists(cfgvars.Output_Dir + 'BED_Files/'):
-                        makedirs(cfgvars.Output_Dir + 'BED_Files/')
-                else:
-                        makedirs(cfgvars.Output_Dir + 'BED_Files_' + str(int(time.time())) + '/')
-                        print "WARNING: BED Folder already present in output directory!"
-        else:
-                pass
-        print "Finding reference gene data using Bowtie-Inspect"
-        cfgvars.RefsLib1, cfgvars.RefsLib2, cfgvars.Genes = ExtractRefData()
-        if cfgvars.DeDup:
-                UniquifyReport(File1, 'DeDuped_' + File1)
-                File1 = 'DeDuped_' + File1
-        else:
-                pass
-        print "Sorting Results and saving into individual outputs"
-        ResultsSort(File1)
-
-##      -------------------------------------------------------------------------------------------
-##      End
-##      -------------------------------------------------------------------------------------------
+#!/opt/anaconda1anaconda2anaconda3/bin/python
+
+##      Copyright (c) 2013-2014 Andrew Laurence Routh
+
+##      
+
+##      Permission is hereby granted, free of charge, to any person obtaining a copy
+
+##      of this software and associated documentation files (the "Software"), to deal
+
+##      in the Software without restriction, including without limitation the rights
+
+##      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+
+##      copies of the Software, and to permit persons to whom the Software is
+
+##      furnished to do so, subject to the following conditions:
+
+##      
+
+##      The above copyright notice and this permission notice shall be included in
+
+##      all copies or substantial portions of the Software.
+
+##      
+
+##      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+
+##      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+
+##      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+
+##      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+
+##      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+
+##      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+
+##      THE SOFTWARE.
+
+##
+
+##      -------------------------------------------------------------------------------------------
+
+if __name__ == '__main__':
+
+    print '\n-------------------------------------------------------------------------------------------'
+
+    print 'ViReMa_0.6 - Viral Recombination Mapper - Compilation Module'
+
+    print 'Last modified 6/05/2014'
+
+    print '-------------------------------------------------------------------------------------------'
+
+
+
+import ConfigViReMa as cfgvars
+
+from re import finditer
+
+import time
+
+
+
+##      ------------------------------------------------------------------------------------------------------------
+
+##      Compound_Handling_Script will determine whether trimmed nucleotides found between recombination
+
+##      sites are present between the donor and accpetor sites for these two recombination events.
+
+##      If so, they are assumed to have arisen due to multiple recombination events occuring within close proximity.
+
+##      This is only a good assumption in viral genomes (where the number if possible matches is low) and
+
+##      when there are sufficient nucleotides in the trimmed sequence. This number is set at the command line
+
+##      wih the option: --Compound_Handling.  A default value of 10 is recommended.  This value must be
+
+##      larger than the MicroInDel number.
+
+##      ------------------------------------------------------------------------------------------------------------
+
+
+
+def Compound_Handling_Script(Donor, DonorSite, Insertion, AcceptorSite, uDelDicts, RecDicts, ReadName):
+
+                if "_RevStrand" in Donor:
+
+                        DonorA = ">" + Donor[:-10]
+
+                        Insertion = Rev_Comp(Insertion)
+
+                        DonorSite, AcceptorSite = AcceptorSite, DonorSite
+
+                else:
+
+                        DonorA = ">" + Donor
+
+                Frag = cfgvars.Genes[DonorA][int(DonorSite):int(AcceptorSite)]
+
+                if Insertion in Frag:
+
+                        Hits = [m.start() for m in finditer(Insertion, Frag)]
+
+                        if len(Hits) == 1:
+
+                                if "_RevStrand" in Donor:
+
+                                        #Unique Compound Recombination Site Found
+
+                                        NewAcceptorSite = str(int(Hits[0]) + int(DonorSite) + 1)
+
+                                        if int(NewAcceptorSite) - int(DonorSite) - 1 <= cfgvars.MicroInDel_Length:
+
+                                                AddToDict(Donor, Donor, NewAcceptorSite, DonorSite, uDelDicts, ReadName)
+
+                                        else:
+
+                                                AddToDict(Donor, Donor, NewAcceptorSite, DonorSite, RecDicts, ReadName)
+
+                                        NewDonorSite = str(int(Hits[0]) + int(DonorSite) + len(Insertion) + 1) 
+
+                                        if int(AcceptorSite) - int(NewDonorSite) - 1 <= cfgvars.MicroInDel_Length:              
+
+                                                AddToDict(Donor, Donor, AcceptorSite, NewDonorSite, uDelDicts, ReadName)
+
+                                        else:
+
+                                                AddToDict(Donor, Donor, AcceptorSite, NewDonorSite, RecDicts, ReadName)
+
+                                else:
+
+                                        #Unique Compound Recombination Site Found
+
+                                        NewAcceptorSite = str(int(Hits[0]) + int(DonorSite) + 1)
+
+                                        if int(NewAcceptorSite) - int(DonorSite) - 1 <= cfgvars.MicroInDel_Length:
+
+                                                AddToDict(Donor, Donor, DonorSite, NewAcceptorSite, uDelDicts, ReadName)
+
+                                        else:
+
+                                                AddToDict(Donor, Donor, DonorSite, NewAcceptorSite, RecDicts, ReadName)
+
+                                        NewDonorSite = str(int(Hits[0]) + int(DonorSite) + len(Insertion) + 1) 
+
+                                        if int(AcceptorSite) - int(NewDonorSite) - 1 <= cfgvars.MicroInDel_Length:              
+
+                                                AddToDict(Donor, Donor, NewDonorSite, AcceptorSite, uDelDicts, ReadName)
+
+                                        else:
+
+                                                AddToDict(Donor, Donor, NewDonorSite, AcceptorSite, RecDicts, ReadName)
+
+                                return "HIT"
+
+                
+
+##      ----------------------------------------------------------------------------------------------------------
+
+##      UniquifyReport() removes identical results.  Reads giving identical results may be PCR duplicates.  
+
+##      Similarly, finding unique multiple unique reads over single recombination junctions validates recombinant
+
+##      ----------------------------------------------------------------------------------------------------------
+
+
+
+def UniquifyReport(FileIn, FileOut):
+
+        print "Removing potential PCR duplicates..."
+
+        TempSet = set()
+
+        Dict = []
+
+        n = 0
+
+        with open(FileIn, 'r') as InputData:
+
+                CLE = str(InputData.readline())
+
+                VirusLib = str(InputData.readline())
+
+                #commandline entry
+
+                x = InputData.readline()
+
+                while x:
+
+                        x = x.split('\t', 1)
+
+                        if x[1] not in TempSet:
+
+                                y = str(x[0]) + '\t' + str(x[1])
+
+                                Dict.append(y)
+
+                                TempSet.add(x[1])
+
+                        n += 1
+
+                        x = InputData.readline()
+
+                print "Total of %s reads in original dataset" % n
+
+        with open(FileOut, 'w') as DeDupedData:
+
+                n = 0
+
+                DeDupedData.write(CLE)
+
+                DeDupedData.write(VirusLib)
+
+                for i in Dict:
+
+                        DeDupedData.write(i)
+
+                        n += 1
+
+                print "%s reads remaining after removing potential PCR duplicates" % n
+
+
+
+##      ----------------------------------------------------------------------------------------
+
+##      Function BedGraph_Plot() will find regions deleted or duplicated due to recombination and return
+
+##      a string string of frequencies and nucleotide positions. 
+
+##      ----------------------------------------------------------------------------------------
+
+
+
+def BEDGraph_Plot():
+
+        DelCover = {}
+
+        InsCover = {}
+
+        with open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Virus_Recombination_Results.bed","r") as Input_Data:
+
+                TrackName = Input_Data.readline()
+
+                for i in cfgvars.RefsLib1:
+
+                        i = '>' + i
+
+                        if "_RevStrand" not in i:
+
+                                DelCover[i] = [0] * len(cfgvars.Genes[i])
+
+                                InsCover[i] = [0] * len(cfgvars.Genes[i])
+
+                for line in Input_Data:
+
+                        line = line.split()
+
+                        Gene_Name = '>' + line[0]
+
+                        Donorsite = int(line[1])
+
+                        Acceptorsite = int(line[2])
+
+                        Count = int(line[4])
+
+                        Strand = line[5]
+
+                        #DonorSums[Donorsite] += Count
+
+                        #AcceptorSums[Acceptorsite] += Count
+
+                        if Strand == '+':
+
+                                if Donorsite < Acceptorsite:
+
+                                        while Donorsite < Acceptorsite:
+
+                                                DelCover[Gene_Name][Donorsite] += Count
+
+                                                Donorsite +=1
+
+                                elif Acceptorsite < Donorsite:
+
+                                        while Acceptorsite < Donorsite:
+
+                                                InsCover[Gene_Name][Acceptorsite] += Count
+
+                                                Acceptorsite +=1
+
+        OutputFile = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Virus_Conservation.bedgraph","w")
+
+        OutputFile.write('track type=bedGraph name="Virus_Conservation" description="Virus_Conservation"\n')
+
+        for i in DelCover:
+
+                n = 0
+
+                for j in DelCover[i]:
+
+                        OutputFile.write('%s\t%s\t%s\t%s\n' % (str(i[1:]), str(n), str(n+1), str(j)))
+
+                        n += 1
+
+        OutputFile.close()
+
+        OutputFile = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Virus_Duplications.bedgraph","w")
+
+        OutputFile.write('track type=bedGraph name="Virus_Duplications" description="Virus_Duplications"n"\n')
+
+        for i in InsCover:
+
+                n = 0
+
+                for j in InsCover[i]:
+
+                        OutputFile.write('%s\t%s\t%s\t%s\n' % (str(i[1:]), str(n), str(n+1), '-' + str(j)))
+
+                        n += 1
+
+        OutputFile.close()
+
+
+
+##      ----------------------------------------------------------------------------------------
+
+##      Function Rev_Comp() will return the Reverse Complement of a given DNA string
+
+##      ----------------------------------------------------------------------------------------
+
+
+
+def Rev_Comp(Seq):
+
+        Seq = Seq.upper()
+
+        basecomplement = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A', 'N': 'N'}
+
+        letters = list(Seq)
+
+        letters = [basecomplement[base] for base in letters]
+
+        return ''.join(letters)[::-1]
+
+
+
+##      ----------------------------------------------------------------------------------------------------
+
+##      Indices will find the locations of pertinent information in the results file as directed by the Code
+
+##      ----------------------------------------------------------------------------------------------------
+
+    
+
+def Indices(List):
+
+        n = 1
+
+        Ms = []
+
+        Xs = []
+
+        for i in List:
+
+                if i == "M":
+
+                        Ms.append(n)
+
+                        n+=2
+
+                else:
+
+                        Xs.append(n)
+
+                        n+=1
+
+        return [Ms, Xs]
+
+
+
+##      -------------------------------------------------------------------------------------------------------
+
+##      ExtractRefData() will find the names of the genes used in the virus or host genome references.
+
+##      Bowtie-inspect must be in $PATH.
+
+##      -------------------------------------------------------------------------------------------------------
+
+
+
+def ExtractRefData():
+
+        import ConfigViReMa as cfgvars
+
+        from subprocess import check_output
+
+        cfgvars.RefsLib1 = set()
+
+        cfgvars.RefsLib2 = set()
+
+        print "Extracting Virus Gene Names..."
+
+        z = check_output(['bowtie-inspect', '-a', '1000000', cfgvars.Lib1]).split()
+
+        cfgvars.Genes = {}
+
+        def RefsAppend(Lib, i):
+
+                Name = i.rstrip()
+
+                Lib.add(Name[1:])
+
+                Lib.add(Name[1:] + "_RevStrand")
+
+                return Name
+
+            
+
+        for i in z:
+
+                if i[0] == '>':
+
+                        Name = RefsAppend(cfgvars.RefsLib1, i)
+
+                else:
+
+                        if cfgvars.Compound_Handling or cfgvars.Defuzz or cfgvars.MicroInDel_Length or cfgvars.BED:
+
+                                Temp = []
+
+                                Temp.append(i.rstrip())
+
+                                Gene = "".join(Temp)
+
+                                cfgvars.Genes[Name] = Gene
+
+        if cfgvars.Lib2:
+
+                        print "Extracting Host Gene Names..."
+
+                        z = check_output(['bowtie-inspect', '-a', '1000000', cfgvars.Lib2]).split()
+
+                        for i in z:
+
+                                if i[0] == '>':
+
+                                        Name = RefsAppend(cfgvars.RefsLib2, i)
+
+                                else:
+
+                                        if cfgvars.Compound_Handling or cfgvars.Defuzz or cfgvars.MicroInDel_Length or cfgvars.BED:
+
+                                                Temp = []
+
+                                                Temp.append(i.rstrip())
+
+                                                Gene = "".join(Temp)
+
+                                                cfgvars.Genes[Name] = Gene
+
+        else:
+
+                        pass
+
+        print "Finished extracting gene data"
+
+        return cfgvars.RefsLib1, cfgvars.RefsLib2, cfgvars.Genes
+
+
+
+##      -------------------------------------------------------------------------------------------------------
+
+##      ExtractRefDataBWA() will find the names of the genes used in the virus or host genome references.
+
+##      Input is typical FASTA file, as per the BWA command line.
+
+##      -------------------------------------------------------------------------------------------------------
+
+
+
+def ExtractRefDataBWA():
+
+        import ConfigViReMa as cfgvars
+
+        cfgvars.RefsLib1 = []
+
+        cfgvars.RefsLib2 = []
+
+        cfgvars.Genes = {}
+
+        print "Extracting Virus Gene Data..."
+
+        with open(cfgvars.Lib1,'r') as FASTAIN:
+
+                for line in FASTAIN:
+
+                        if line[0] == '>':
+
+                                Name = line.rstrip()
+
+                                cfgvars.RefsLib1.append(Name[1:])
+
+                                cfgvars.RefsLib1.append(Name[1:] + "_RevStrand")
+
+                        else:
+
+                                if cfgvars.Compound_Handling or cfgvars.Defuzz or cfgvars.MicroInDel_Length:
+
+                                        if Name in cfgvars.Genes:
+
+                                                cfgvars.Genes[Name] += line.rstrip()
+
+                                        else:
+
+                                                cfgvars.Genes[Name] = line.rstrip()
+
+
+
+        if cfgvars.Lib2:
+
+                print "Extracting Host Gene Data..."
+
+                with open(cfgvars.Lib2,'r') as FASTAIN:
+
+                        for line in FASTAIN:
+
+                                if line[0] == '>':
+
+                                        Name = line.rstrip()
+
+                                        cfgvars.RefsLib2.append(Name[1:])
+
+                                        cfgvars.RefsLib2.append(Name[1:] + "_RevStrand")
+
+                                else:
+
+                                        if cfgvars.Compound_Handling or cfgvars.Defuzz or cfgvars.MicroInDel_Length:
+
+                                                if Name in cfgvars.Genes:
+
+                                                        cfgvars.Genes[Name] += line.rstrip()
+
+                                                else:
+
+                                                        cfgvars.Genes[Name] = line.rstrip()
+
+        print "Finished extracting gene data"
+
+        return cfgvars.RefsLib1, cfgvars.RefsLib2, cfgvars.Genes
+
+    
+
+##      -------------------------------------------------------------------------------------------
+
+##      AddToDict() takes the Donor and Acceptor sites and references for a given recombination event,
+
+##      and collates them into a Dictionary which will later be written to a results file.
+
+##      -------------------------------------------------------------------------------------------
+
+
+
+def AddToDict(Donor, Acceptor, DonorSite, AcceptorSite, Dict, ReadName):
+
+        Fuzz = 0
+
+        if cfgvars.Defuzz:
+
+                if "_RevStrand" in Donor:
+
+                        if int(AcceptorSite) != int(DonorSite) - 1:
+
+                                Fuzz = FindFuzz(Donor, DonorSite, Acceptor, AcceptorSite, (cfgvars.MaxFuzz+1))
+
+                                if Fuzz > 0:
+
+                                        if cfgvars.Defuzz == 'Centre':
+
+                                                DonorSite = str(int(DonorSite) + ((Fuzz+1)/2))
+
+                                                AcceptorSite = str(int(AcceptorSite) + ((Fuzz+1)/2))
+
+                                        elif cfgvars.Defuzz == 'Right':
+
+                                                DonorSite = str(int(DonorSite) + Fuzz)
+
+                                                AcceptorSite = str(int(AcceptorSite) + Fuzz)
+
+                                        else:
+
+                                                pass
+
+                        else:
+
+                                pass
+
+                else:
+
+                        if int(AcceptorSite) != int(DonorSite) + 1:
+
+                                Fuzz = FindFuzz(Donor, DonorSite, Acceptor, AcceptorSite, (cfgvars.MaxFuzz+1))
+
+                                if Fuzz > 0:
+
+                                        if cfgvars.Defuzz == 'Centre':
+
+                                                DonorSite = str(int(DonorSite) - (Fuzz/2))
+
+                                                AcceptorSite = str(int(AcceptorSite) - (Fuzz/2))
+
+                                        elif cfgvars.Defuzz == 'Left':
+
+                                                DonorSite = str(int(DonorSite) - Fuzz)
+
+                                                AcceptorSite = str(int(AcceptorSite) - Fuzz)
+
+                                        else:
+
+                                                pass
+
+                        else:
+
+                                pass
+
+        else:
+
+                pass
+
+        if Fuzz <= cfgvars.MaxFuzz:
+
+                if (Donor + "_to_" + Acceptor) not in Dict:
+
+                        Dict[Donor + "_to_" + Acceptor] = {}
+
+                else:
+
+                        pass
+
+                if cfgvars.ReadNamesEntry:
+
+                        if (DonorSite + "_to_" + AcceptorSite) not in Dict[Donor + "_to_" + Acceptor]:
+
+                                Dict[Donor + "_to_" + Acceptor][DonorSite + "_to_" + AcceptorSite] = [1, [ReadName]]
+
+                        else:
+
+                                Dict[Donor + "_to_" + Acceptor][DonorSite + "_to_" + AcceptorSite][0] += 1
+
+                                Dict[Donor + "_to_" + Acceptor][DonorSite + "_to_" + AcceptorSite][1].append(ReadName)
+
+                else:
+
+                        if (DonorSite + "_to_" + AcceptorSite) not in Dict[Donor + "_to_" + Acceptor]:
+
+                                Dict[Donor + "_to_" + Acceptor][DonorSite + "_to_" + AcceptorSite] = 1
+
+                        else:
+
+                                Dict[Donor + "_to_" + Acceptor][DonorSite + "_to_" + AcceptorSite] += 1
+
+        else:
+
+                pass
+
+
+
+##      ----------------------------------------------------------------------------------------------------------------
+
+##      FindFuzz() will determine the number of overlapping nucleotides in the donor region and the nucleotides
+
+##      preceeding the acceptor site.
+
+##      -----------------------------------------------------------------------------------------------------------------
+
+
+
+def FindFuzz(Donor, DonorSite, Acceptor, AcceptorSite, MaxFuzz):
+
+        F = 0
+
+        if "_RevStrand" in Donor:
+
+                Gene = '>' + Donor[:-10]
+
+                DonorSeq = Rev_Comp(cfgvars.Genes[Gene][int(DonorSite) - 1:int(DonorSite) - 1 + MaxFuzz])
+
+        else:
+
+                Gene = '>' + Donor
+
+                DonorSeq = cfgvars.Genes[Gene][int(DonorSite) - MaxFuzz:int(DonorSite)]
+
+        if "_RevStrand" in Acceptor:
+
+                Gene = '>' + Acceptor[:-10]
+
+                if int(AcceptorSite) + MaxFuzz > len(cfgvars.Genes[Gene]):
+
+                        UpstreamAcceptorSeq = Rev_Comp(cfgvars.Genes[Gene][int(AcceptorSite):])
+
+                else:
+
+                        UpstreamAcceptorSeq = Rev_Comp(cfgvars.Genes[Gene][int(AcceptorSite): int(AcceptorSite) + MaxFuzz])
+
+        else:
+
+                Gene = '>' + Acceptor
+
+                if int(AcceptorSite) - 1 - MaxFuzz < 0:
+
+                        UpstreamAcceptorSeq = cfgvars.Genes[Gene][0: int(AcceptorSite) - 1]
+
+                else:
+
+                        UpstreamAcceptorSeq = cfgvars.Genes[Gene][int(AcceptorSite) - 1 - MaxFuzz: int(AcceptorSite) - 1]
+
+        for i in range(len(UpstreamAcceptorSeq)):
+
+                try:
+
+                    if UpstreamAcceptorSeq[-i-1] == DonorSeq[-i-1]:
+
+                            F += 1
+
+                    else:
+
+                            break
+
+                except:
+
+                        break
+
+        return F
+
+
+
+##      -----------------------------------------------------------------------------------------------------------------
+
+##      AddInsToDict() takes the Donor and Acceptor sites, references and trimmed nucleotides for a given Insertion event
+
+##      and collate them into a Dictionary which will later be written to a results file.
+
+##      -----------------------------------------------------------------------------------------------------------------
+
+
+
+def AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, Dict, ReadName):
+
+                if Donor not in Dict:
+
+                        Dict[Donor] = {}
+
+                else:
+
+                        pass
+
+                if cfgvars.ReadNamesEntry:
+
+                        if (str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)) not in Dict[Donor]:
+
+                                Dict[Donor][str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)] = [1, [ReadName]]
+
+                        else:
+
+                                Dict[Donor][str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)][0] += 1
+
+                                Dict[Donor][str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)][1].append(ReadName)
+
+                else:
+
+                        if (str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)) not in Dict[Donor]:
+
+                                Dict[Donor][str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)] = 1
+
+                        else:
+
+                                Dict[Donor][str(DonorSite) + "_" + Insertion + "_" + str(AcceptorSite)] += 1
+
+
+
+##      -------------------------------------------------------------------------------------------
+
+##      ResultsSort() is the backbone of the results compilation script.  It will take each line from the results
+
+##      output from ViReMa and determine the nature of every discovered event.  This includes recombinations, insertions, subsitutions, etc.
+
+##      The Code appended to the end of each line in the ViReMa output allows ResultsSort() to group particular events.
+
+##      The finer details are then established based upon parameters set in the command-line (e.g. MicroInDel length), and upon the
+
+##      information provided in the ViReMa output.
+
+##      -------------------------------------------------------------------------------------------
+
+
+
+def ResultsSort(File1):
+
+        from re import findall
+
+        from math import fabs
+
+
+
+        ##      -------------------------------------------------------------------------------------------
+
+        ##      WriteFinalDict() will read all the information collated in each Dictionary and write out the
+
+        ##      results to the results files.
+
+        ##      -------------------------------------------------------------------------------------------
+
+        
+
+        def WriteFinalDict(DictName, Mod):
+
+            
+
+                ##      ---------------------------------------------------------------
+
+                ##      WritetoBedFile() will append the entry to the optional BED File
+
+                ##      ---------------------------------------------------------------
+
+            
+
+                def WritetoBEDFile(Genes, Entry, TargetFile):
+
+                        # Genes is in format: 'Donor_to_Acceptor'
+
+                        # Entry is in format: [DonorSite, 'to', AcceptorSite, '#', Count]
+
+                        Genes = Genes.split("_to_")
+
+                        #print Genes, Entry, TargetFile
+
+                        if Genes[0][-10:] == "_RevStrand":
+
+                                            Genes[0] = Genes[0][:-10]
+
+                                            Strandedness = '-'
+
+                        else:
+
+                                            Strandedness = '+'
+
+                        BED_OUTPUT = "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % (str(Genes[0]), str(Entry[0]), str(Entry[2]), 'NAMES_TBD', str(Entry[4]), Strandedness, str(Entry[0]), str(Entry[2]))
+
+                        if TargetFile == VirusRecs:
+
+                                        if Genes[0] == Genes[1]:
+
+                                                VirusRecs_BED.write(BED_OUTPUT)
+
+                                        else:
+
+                                                pass
+
+                        elif TargetFile == VirusuIns:
+
+                                        VirusuRecs_BED.write(BED_OUTPUT)
+
+                        elif TargetFile == VirusuDels:
+
+                                        VirusuRecs_BED.write(BED_OUTPUT)
+
+                        elif TargetFile == HostRecs:
+
+                                        if Genes[0] == Genes[1]:
+
+                                                HostRecs_BED.write(BED_OUTPUT)
+
+                                        else:
+
+                                                pass
+
+                        elif TargetFile == HostuIns:
+
+                                        HostuRecs_BED.write(BED_OUTPUT)
+
+                        elif TargetFile == HostuDels:
+
+                                        HostuRecs_BED.write(BED_OUTPUT)
+
+                        else:
+
+                                        pass
+
+                ##      ---------------------------------------------------------------
+
+
+
+                for k in DictName:
+
+                        Libs = k.split("_to_")
+
+                        n = 0
+
+                        for i in Libs:
+
+                                if i[-10:] == "_RevStrand":
+
+                                        Libs[n] = Libs[n][:-10]
+
+                                n+=1
+
+                        if Mod == 'Recs':
+
+                                if Libs[0] in cfgvars.RefsLib1 and Libs[1] in cfgvars.RefsLib1:
+
+                                        TargetFile = VirusRecs
+
+                                elif Libs[0] in cfgvars.RefsLib2 and Libs[1] in cfgvars.RefsLib2:
+
+                                        TargetFile = HostRecs
+
+                                else:
+
+                                        TargetFile = VirustoHostRecs
+
+                        elif Mod == 'uDel':
+
+                                if Libs[0] in cfgvars.RefsLib1 and Libs[1] in cfgvars.RefsLib1:
+
+                                        TargetFile = VirusuDels
+
+                                elif Libs[0] in cfgvars.RefsLib2 and Libs[1] in cfgvars.RefsLib2:
+
+                                        TargetFile = HostuDels
+
+                                else:
+
+                                        pass                        
+
+                        elif Mod == 'uIns':
+
+                                if Libs[0] in cfgvars.RefsLib1:
+
+                                        TargetFile = VirusuIns
+
+                                else:
+
+                                        TargetFile = HostuIns
+
+                        elif Mod == 'Ins':
+
+                                if Libs[0] in cfgvars.RefsLib1:
+
+                                        TargetFile = VirusInsertions
+
+                                else:
+
+                                        TargetFile = HostInsertions
+
+                        elif Mod == 'Sub':
+
+                                if Libs[0] in cfgvars.RefsLib1:
+
+                                        TargetFile = VirusSubstitutions
+
+                                else:
+
+                                        TargetFile = HostSubstitutions
+
+                        Temp = []
+
+                        if cfgvars.ReadNamesEntry:
+
+                                for i in DictName[k]:
+
+                                        x = [(str(i) + "_#_" + str(DictName[k][i][0])).split("_"), DictName[k][i][1]]
+
+                                        Temp.append(x)
+
+                                Temp.sort(key=lambda a:int(a[0][4]), reverse=True)
+
+                                TargetFile.write("@NewLibrary: " + str(k) + "\n")
+
+                                for i in Temp:
+
+                                        j = '_'.join(i[0])
+
+                                        TargetFile.write(str(j) + "\n")
+
+                                        for Names in i[1]:
+
+                                                TargetFile.write(str(Names) + '\t')
+
+                                        TargetFile.write('\n')
+
+                                TargetFile.write("\n@EndofLibrary\n")
+
+                        else:
+
+                                for i in DictName[k]:
+
+                                        x = (str(i) + "_#_" + str(DictName[k][i])).split("_")
+
+                                        Temp.append(x)
+
+                                Temp.sort(key=lambda a:int(a[4]), reverse=True)
+
+                                TargetFile.write("@NewLibrary: " + str(k) + "\n")
+
+                                for i in Temp:
+
+                                        if cfgvars.BED:
+
+                                                if cfgvars.Lib2:
+
+                                                        if cfgvars.MicroInDel_Length > 0:
+
+                                                                BEDableTargetFiles = [VirusRecs, VirusuDels, HostRecs, HostuDels, VirusuIns, HostuIns]
+
+                                                        else:
+
+                                                                BEDableTargetFiles = [VirusRecs, HostRecs]
+
+                                                else:
+
+                                                        if cfgvars.MicroInDel_Length > 0:
+
+                                                                BEDableTargetFiles = [VirusRecs, VirusuDels, VirusuIns]
+
+                                                        else:
+
+                                                                BEDableTargetFiles = [VirusRecs]
+
+                                                if TargetFile in BEDableTargetFiles:
+
+                                                        WritetoBEDFile(k, i, TargetFile)
+
+                                                        
+
+                                                else:
+
+                                                        pass
+
+                                        else:
+
+                                                pass
+
+                                        j = '_'.join(i)
+
+                                        TargetFile.write(str(j) + "\t")
+
+                                TargetFile.write("\n@EndofLibrary\n")
+
+        
+
+        #Dictionaries 
+
+        InsDicts = {}
+
+        SubDicts = {}
+
+        uDelDicts = {}
+
+        uInsDicts = {}
+
+        RecDicts = {}
+
+
+
+        #Counts for events used for printed summary
+
+        Padcount = 0
+
+        Totalcount = 0
+
+        uCount = 0
+
+        InsCount = 0
+
+        SubCount = 0
+
+        CompoundCount = 0
+
+        RecombCount = 0
+
+        ErrorCount = 0
+
+        ViralRecombinationCount = 0
+
+        HostRecombinationCount = 0
+
+        ViraltoHostRecombinationCount = 0
+
+        UnknownRecombinationCount = 0
+
+        UnmappedReadsCount = 0
+
+        UnmappedReads = open(cfgvars.Output_Dir + cfgvars.FileTag + "UnMappedReads.txt","w")
+
+        SingleAlignment = open(cfgvars.Output_Dir + cfgvars.FileTag + "Single_Alignments.txt","w")
+
+        UnknownRecombinations = open(cfgvars.Output_Dir + cfgvars.FileTag + "Unknown_Recombinations.txt", "w")
+
+
+
+        with open(File1,"r") as InRecombs:
+
+            skip = InRecombs.readline()
+
+            skip = InRecombs.readline()
+
+            #Meat of script, reads each line from ViReMa.py output and stores details into dictionaries
+
+            wholeline = InRecombs.readline()
+
+            while wholeline:
+
+                Totalcount += 1
+
+                line = wholeline.split("\t")[:-1]
+
+                ReadName = line[0]
+
+                Code = ''.join(findall(r"\D", line[-1]))
+
+                Index = Indices(Code)
+
+                MCount = Code.count("M")
+
+                if "M" not in Code:
+
+                                #UnMapped Read
+
+                                UnmappedReads.write(wholeline)
+
+                                UnmappedReadsCount += 1
+
+                elif MCount == 1:
+
+                                #Singly mapped Read
+
+                                PadLongerThanSeed = False
+
+                                for i in Index[1]:
+
+                                        if len(line[i]) >= int(cfgvars.Seed):
+
+                                                PadLongerThanSeed = True
+
+                                        else:
+
+                                                pass
+
+                                if PadLongerThanSeed:
+
+                                        #Mapable region recombined
+
+                                        UnknownRecombinationCount += 1
+
+                                        UnknownRecombinations.write(wholeline)
+
+                                else:
+
+                                        #Single non-padded Alignment
+
+                                        SingleAlignment.write(wholeline)
+
+                                        Padcount += 1
+
+                else:
+
+                                #Multiple mappings, means either recombination, insertion, or substitution.
+
+                                n=0
+
+                                UnRec = ''
+
+                                for i in Index[0][:-1]:
+
+                                        Donor = line[i]
+
+                                        if "RevStrand" in line[i+1]:
+
+                                                DonorSite = line[i+1].split("_")[2]
+
+                                                Donor += "_RevStrand"
+
+                                        else:
+
+                                                DonorSite = line[i+1].split("_")[1]
+
+                                        if Index[0][n+1] == i + 2:
+
+                                                #Recombination Event
+
+                                                Acceptor = line[i+2]
+
+                                                if "RevStrand" in line[i+3]:
+
+                                                        AcceptorSite = line[i+3].split("_")[0]
+
+                                                        Acceptor += "_RevStrand"
+
+                                                else:
+
+                                                        AcceptorSite = line[i+3].split("_")[0]
+
+                                                if Donor == Acceptor and "_RevStrand" in Donor and fabs(int(DonorSite) - int(AcceptorSite) - 1) <= cfgvars.MicroInDel_Length:
+
+                                                                if int(DonorSite) - int(AcceptorSite) - 1 < 0:
+
+                                                                        #MicroInsertion on negative strand
+
+                                                                        uCount += 1
+
+                                                                        DonorA = ">" + Donor[:-10]
+
+                                                                        Insertion = cfgvars.Genes[DonorA][int(DonorSite) - 1:int(AcceptorSite)]
+
+                                                                        Insertion = Rev_Comp(Insertion)
+
+                                                                        NewAcceptorSite = str(int(DonorSite) - 1)
+
+                                                                        AddInsToDict(Donor, DonorSite, NewAcceptorSite, Insertion, uInsDicts, ReadName)
+
+                                                                elif int(DonorSite) - int(AcceptorSite) - 1 > 0:
+
+                                                                        #MicroDeletion on negative strand
+
+                                                                        uCount += 1
+
+                                                                        AddToDict(Donor, Acceptor, DonorSite, AcceptorSite, uDelDicts, ReadName)
+
+                                                elif Donor == Acceptor and fabs(int(DonorSite) - int(AcceptorSite) + 1) <= cfgvars.MicroInDel_Length:
+
+                                                                if int(DonorSite) - int(AcceptorSite) + 1 > 0:
+
+                                                                        #MicroInsertion
+
+                                                                        uCount += 1
+
+                                                                        DonorA = ">" + Donor
+
+                                                                        Insertion = cfgvars.Genes[DonorA][int(AcceptorSite) - 1:int(DonorSite)]
+
+                                                                        NewAcceptorSite = str(int(DonorSite) + 1)
+
+                                                                        AddInsToDict(Donor, DonorSite, NewAcceptorSite, Insertion, uInsDicts, ReadName)
+
+                                                                elif int(DonorSite) - int(AcceptorSite) + 1 < 0:
+
+                                                                        #MicroDeletion
+
+                                                                        uCount += 1
+
+                                                                        AddToDict(Donor, Acceptor, DonorSite, AcceptorSite, uDelDicts, ReadName)
+
+                                                else:
+
+                                                        #Direct Recombination Event
+
+                                                        RecombCount += 1
+
+                                                        AddToDict(Donor, Acceptor, DonorSite, AcceptorSite, RecDicts, ReadName)
+
+                                                        if Donor in cfgvars.RefsLib1 and Acceptor in cfgvars.RefsLib1:
+
+                                                                ViralRecombinationCount +=1
+
+                                                        elif Donor in cfgvars.RefsLib2 and Acceptor in cfgvars.RefsLib2:
+
+                                                                HostRecombinationCount += 1
+
+                                                        else:
+
+                                                                ViraltoHostRecombinationCount += 1
+
+                                        else:
+
+                                                #Insertion between mapped Segments
+
+                                                Acceptor = line[i+3]
+
+                                                Insertion = line[i+2]
+
+                                                if "RevStrand" in line[i+4]:
+
+                                                        AcceptorSite = line[i+4].split("_")[0]
+
+                                                        Acceptor += "_RevStrand"
+
+                                                else:
+
+                                                        AcceptorSite = line[i+4].split("_")[0]
+
+                                                if Acceptor == Donor and "_RevStrand" in Donor and int(DonorSite) == (int(AcceptorSite) + 1):
+
+                                                        #Simple Insertion Event in negative strand
+
+                                                        if len(Insertion) >= cfgvars.MicroInDel_Length:
+
+                                                                InsCount += 1
+
+                                                                AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, InsDicts, ReadName)
+
+                                                        else:
+
+                                                                #MicroInDel on negative strand 
+
+                                                                uCount += 1
+
+                                                                AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, uInsDicts, ReadName)
+
+                                                elif Acceptor == Donor and int(AcceptorSite) == (int(DonorSite) + 1):
+
+                                                        #Simple Insertion Event
+
+                                                        if len(Insertion) >= cfgvars.MicroInDel_Length:
+
+                                                                InsCount += 1
+
+                                                                AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, InsDicts, ReadName)
+
+                                                        else:
+
+                                                                uCount += 1
+
+                                                                AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, uInsDicts, ReadName)       
+
+                                                elif int(AcceptorSite) == (int(DonorSite) + len(Insertion) + 1) and Acceptor == Donor:
+
+                                                        #Direct Substitution
+
+                                                        if len(Insertion) <= cfgvars.Mismatches:
+
+                                                                #Mismatch, not Substitution
+
+                                                                MCount -= 1
+
+                                                                if MCount == 1:
+
+                                                                        #Singly mapped Read
+
+                                                                        PadLongerThanSeed = ''
+
+                                                                        for i in Index[1]:
+
+                                                                                if len(line[i]) >= int(cfgvars.Seed) or len(line[i]) >= int(cfgvars.Host_Seed):
+
+                                                                                        PadLongerThanSeed += 'X'
+
+                                                                                else:
+
+                                                                                        pass
+
+                                                                        if PadLongerThanSeed:
+
+                                                                                #Mapable region recombined
+
+                                                                                UnknownRecombinationCount += 1
+
+                                                                                UnknownRecombinations.write(wholeline)
+
+                                                                        else:
+
+                                                                                #Single non-padded Alignment
+
+                                                                                SingleAlignment.write(wholeline)
+
+                                                                                Padcount += 1
+
+                                                                else:
+
+                                                                        pass
+
+                                                                    
+
+                                                        else:
+
+                                                                SubCount += 1
+
+                                                                AddInsToDict(Donor, DonorSite, AcceptorSite, Insertion, SubDicts, ReadName)
+
+                                                elif int(DonorSite) == (int(AcceptorSite) + len(Insertion) + 1) and Acceptor == Donor and "_RevStrand" in Donor:
+
+                                                        #Direct Substitution on negative strand
+
+                                                        if len(Insertion) <= cfgvars.Mismatches:
+
+                                                                #Mismatch, not Substitution
+
+                                                                MCount -= 1
+
+                                                                if MCount == 1:
+
+                                                                        #Singly mapped Read
+
+                                                                        PadLongerThanSeed = ''
+
+                                                                        for i in Index[1]:
+
+                                                                                if len(line[i]) >= int(cfgvars.Seed) or len(line[i]) >= int(cfgvars.Host_Seed):
+
+                                                                                        PadLongerThanSeed += 'X'
+
+                                                                                else:
+
+                                                                                        pass
+
+                                                                        if PadLongerThanSeed:
+
+                                                                                #Mapable region recombined
+
+                                                                                UnknownRecombinationCount += 1
+
+                                                                                UnknownRecombinations.write(wholeline)
+
+                                                                        else:
+
+                                                                                #Single non-padded Alignment
+
+                                                                                SingleAlignment.write(wholeline)
+
+                                                                                Padcount += 1
+
+                                                                else:
+
+                                                                        pass
+
+                                                        else:
+
+                                                                SubCount += 1
+
+                                                                AddInsToDict(Donor, AcceptorSite, DonorSite, Insertion, SubDicts, ReadName)
+
+                                                else:
+
+                                                        if len(Insertion) >= int(cfgvars.Seed) or len(Insertion) >= int(cfgvars.Host_Seed):
+
+                                                                #Mapable Insertion/Recombination
+
+                                                                UnknownRecombinationCount += 1
+
+                                                                UnRec = 'Y'
+
+                                                        else:
+
+                                                                if cfgvars.Compound_Handling and len(Insertion) > int(cfgvars.Compound_Handling) and Donor == Acceptor and Donor in cfgvars.RefsLib1:
+
+                                                                        #Compound Recombination
+
+                                                                        CompoundCount += 1
+
+                                                                        CompTest = Compound_Handling_Script(Donor, DonorSite, Insertion, AcceptorSite, uDelDicts, RecDicts, ReadName)
+
+                                                                        if CompTest == "HIT":
+
+                                                                                RecombCount += 2
+
+                                                                                ViralRecombinationCount += 2
+
+                                                                                CompoundCount += 1
+
+                                                                        else:
+
+                                                                                #Unknown Compound
+
+                                                                                UnRec = 'Y'
+
+                                                                                UnknownRecombinationCount += 1
+
+                                                                else:
+
+                                                                        #Unknown Insertion.
+
+                                                                        UnknownRecombinationCount += 1
+
+                                                                        UnRec = 'Y'
+
+                                        n+=1 
+
+                                if UnRec:
+
+                                        UnknownRecombinations.write(wholeline)
+
+                                else:
+
+                                        pass
+
+                wholeline = InRecombs.readline()
+
+        
+
+        #Output Files for each type of event
+
+        VirusSubstitutions = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus_Substitutions.txt","w")
+
+        VirusInsertions = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus_Insertions.txt","w")
+
+        VirusRecs = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus_Recombination_Results.txt","w")
+
+        if cfgvars.MicroInDel_Length > 0:
+
+                VirusuDels = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus_MicroDeletions.txt","w")
+
+                VirusuIns = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus_MicroInsertions.txt","w")
+
+        else:
+
+                pass
+
+        if cfgvars.Lib2:
+
+                HostSubstitutions = open(cfgvars.Output_Dir + cfgvars.FileTag + "Host_Substitutions.txt","w")
+
+                HostInsertions = open(cfgvars.Output_Dir + cfgvars.FileTag + "Host_Insertions.txt","w")
+
+                HostRecs = open(cfgvars.Output_Dir + cfgvars.FileTag + "Host_Recombination_Results.txt","w")
+
+                if cfgvars.MicroInDel_Length > 0:
+
+                        HostuDels = open(cfgvars.Output_Dir + cfgvars.FileTag + "Host_MicroDeletions.txt","w")
+
+                        HostuIns = open(cfgvars.Output_Dir + cfgvars.FileTag + "Host_MicroInsertions.txt","w")
+
+                else:
+
+                        pass
+
+                VirustoHostRecs = open(cfgvars.Output_Dir + cfgvars.FileTag + "Virus-to-Host_Recombination_Results.txt","w")
+
+        else:
+
+                pass
+
+
+
+        if cfgvars.BED:
+
+                #Create optional BED files.
+
+                VirusRecs_BED = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Virus_Recombination_Results.bed","a")
+
+                VirusRecs_BED.write('track name=Virus_Recombinations description="Virus_Recombinations" graphType=junctions\n')
+
+                if cfgvars.MicroInDel_Length > 0:
+
+                        VirusuRecs_BED = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Virus_MicroRecombinations.bed","a")
+
+                        VirusuRecs_BED.write('track name=Virus_MicroInDels description="Virus_MicroInDels" graphType=junctions\n')
+
+                else:
+
+                        pass
+
+                if cfgvars.Lib2:
+
+                        HostRecs_BED = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Host_Recombination_Results.bed","a")
+
+                        HostRecs_BED.write('track name=Host_Recombinations description="Host_Recombinations" graphType=junctions\n')
+
+                        if cfgvars.MicroInDel_Length > 0:
+
+                                HostuRecs_BED = open(cfgvars.Output_Dir + cfgvars.FileTag + "BED_Files/Host_MicroRecombinations.bed","a")
+
+                                HostuRecs_BED.write('track name=Host_MicroInDels description="Host_MicroInDels" graphType=junctions\n')
+
+                        else:
+
+                                pass
+
+                else:
+
+                        pass
+
+                    
+
+        ##      Take final Dictionaries of recombination events are write out to files
+
+        print "Writing sorted results to individual output files..."
+
+        WriteFinalDict(RecDicts, 'Recs')
+
+        if cfgvars.MicroInDel_Length > 0:
+
+                WriteFinalDict(uDelDicts, 'uDel')
+
+                WriteFinalDict(uInsDicts, 'uIns')
+
+        else:
+
+                pass
+
+        WriteFinalDict(InsDicts, 'Ins')
+
+        WriteFinalDict(SubDicts, 'Sub')
+
+
+
+        ##      Print summary
+
+        print "---------------------------------------------------------------------------------------------------------------------"
+
+        print "Total of %s reads have been analysed:" % Totalcount
+
+        print "%s were single mapping reads with pads." % Padcount
+
+        print "%s Straight-forward Recombination Events detected"% RecombCount
+
+        print "of which %s were Viral Recombinations, %s were Host Recombinations and %s were Virus-to-Host Recombinations" % (ViralRecombinationCount, HostRecombinationCount, ViraltoHostRecombinationCount)
+
+        if cfgvars.MicroInDel_Length > 0:
+
+                print "%s were MicroIndels below a threshold of less than or equal to %s nucleotides." % (uCount, cfgvars.MicroInDel_Length)
+
+        else:
+
+                pass
+
+        print "%s UnIdentified Insertion Events." % InsCount
+
+        print "%s Nucleotide Subsitution events, including mismatches that preserve the gene length." % SubCount
+
+        if cfgvars.Compound_Handling:
+
+                print "%s Compound Recombination Events detected." % CompoundCount
+
+        else:
+
+                pass
+
+        print "%s events were Unknown or Ambiguous Recombination Events." % UnknownRecombinationCount
+
+        print "%s reads were completely unmapped." % UnmappedReadsCount
+
+
+
+        #Close all output files and finish
+
+        UnmappedReads.close()
+
+        InRecombs.close()
+
+        SingleAlignment.close()
+
+        UnknownRecombinations.close()
+
+        VirusRecs.close()
+
+        if cfgvars.MicroInDel_Length > 0:
+
+                VirusuIns.close()
+
+                VirusuDels.close()
+
+        else:
+
+                pass
+
+        VirusSubstitutions.close()
+
+        VirusInsertions.close()
+
+        if cfgvars.Lib2:
+
+                HostRecs.close()
+
+                VirustoHostRecs.close()
+
+                HostInsertions.close()
+
+                if cfgvars.MicroInDel_Length > 0:
+
+                        HostuDels.close()
+
+                        HostuIns.close()
+
+                else:
+
+                        pass
+
+                HostSubstitutions.close()
+
+        else:
+
+                pass
+
+        if cfgvars.BED:
+
+                VirusRecs_BED.close()
+
+                if cfgvars.MicroInDel_Length > 0:
+
+                        VirusuRecs_BED.close()
+
+                else:
+
+                        pass
+
+                if cfgvars.Lib2:
+
+                        HostRecs_BED.close()
+
+                        if cfgvars.MicroInDel_Length > 0:
+
+                                HostuRecs_BED.close()
+
+                        else:
+
+                                pass
+
+                else:
+
+                        pass
+
+                BEDGraph_Plot()
+
+        else:
+
+                pass
+
+
+
+##      -------------------------------------------------------------------------------------------
+
+##      This module can be run seperately from the main ViReMa script. This may be useful when tweeking variables such
+
+##      as the MicroInDel length or Compound_Handling, or when combining the results from multiple instances of ViReMa.
+
+##      Consequently, the following code takes arguments from command line, and sends them to the config file for cross-module access.
+
+##      Results Compilation is then initiated as normal.
+
+##      -------------------------------------------------------------------------------------------
+
+
+
+if __name__ == '__main__':
+
+        from os.path import exists
+
+        from os import makedirs
+
+        import argparse
+
+        parser = argparse.ArgumentParser()
+
+        parser.add_argument("Input_Data", help= "UnCompiled Results file from ViReMa run")
+
+        parser.add_argument("--Output_Tag", help= "Enter a tag name that will be appended to end of each output file.")
+
+        parser.add_argument("-DeDup", action='store_true', help="Remove potential PCR duplicates. Default is off.")
+
+        parser.add_argument("-ReadNamesEntry", action='store_true', help="Append Read Names contributing to each compiled result. Default is off.")
+
+        parser.add_argument("--Defuzz", help="Choose how to defuzz data:  '5' to report at 5' end of fuzzy region, '3' to report at 3' end, or '0' to report in centre of fuzzy region. Default is no fuzz handling (similar to choosing Right - see Routh et al).")
+
+        parser.add_argument("--MaxFuzz", help="Select maximum allowed length of fuzzy region. Recombination events with longer fuzzy regions will not be reported. Default is Seed Length.")
+
+        parser.add_argument("--MicroInDel_Length", help= "Size of MicroInDels - these are common artifacts of cDNA preparation.  See Routh et al JMB 2012. Default size is 0)")
+
+        parser.add_argument("--Compound_Handling", help= "Select this option for compound recombination event mapping (see manual for details). Enter number of nucleotides to map (must be less than Seed, and greater than number of nts in MicroInDel). Default is off.")
+
+        parser.add_argument("--Output_Dir", help= "Enter a directory name that all compiled output files will be saved in.")
+
+        parser.add_argument("-BED", action='store_true', help= "Output recombination data into BED files.")
+
+        args = parser.parse_args()
+
+        File1 = str(args.Input_Data)
+
+        with open(File1,"r") as InRecombs:
+
+                #Find arguments used in Mapping Phase from ViReMa.py
+
+                cfgvars.Lib1 = InRecombs.readline().rstrip()
+
+                CommandLineEntry = InRecombs.readline()[1:-3].split("', '")
+
+                if "--Host_Index" in CommandLineEntry:
+
+                        cfgvars.Lib2 = CommandLineEntry[CommandLineEntry.index("--Host_Index")+1]
+
+                else:
+
+                        cfgvars.Lib2 = None
+
+                if "--Seed" in CommandLineEntry:
+
+                        cfgvars.Seed = CommandLineEntry[CommandLineEntry.index("--Seed")+1]
+
+                else:
+
+                        cfgvars.Seed = '25'
+
+                if "--Host_Seed" in CommandLineEntry:
+
+                        cfgvars.Host_Seed = CommandLineEntry[CommandLineEntry.index("--Host_Seed")+1]
+
+                else:
+
+                        cfgvars.Host_Seed = cfgvars.Seed
+
+                if "--N" in CommandLineEntry:
+
+                        cfgvars.Mismatches = int(CommandLineEntry[CommandLineEntry.index("--N")+1])
+
+                else:
+
+                        cfgvars.Mismatches = 1
+
+        if args.Output_Tag:
+
+                cfgvars.FileTag = str(args.Output_Tag)
+
+        else:
+
+                cfgvars.FileTag = ''
+
+        if args.Defuzz == '3':
+
+                cfgvars.Defuzz = 'Right'
+
+        elif args.Defuzz == '5':
+
+                cfgvars.Defuzz = 'Left'
+
+        elif args.Defuzz == '0':
+
+                cfgvars.Defuzz = 'Centre'
+
+        else:
+
+                cfgvars.Defuzz = False
+
+        if args.DeDup:
+
+                cfgvars.DeDup = True
+
+        else:
+
+                cfgvars.DeDup = False
+
+        if args.ReadNamesEntry:
+
+                cfgvars.ReadNamesEntry = True
+
+        else:
+
+                cfgvars.ReadNamesEntry = False
+
+        if args.MaxFuzz:
+
+                cfgvars.MaxFuzz = int(args.MaxFuzz)
+
+        else:
+
+                cfgvars.MaxFuzz = int(cfgvars.Seed)
+
+        if args.Compound_Handling:
+
+                cfgvars.Compound_Handling = str(args.Compound_Handling)
+
+        else:
+
+                cfgvars.Compound_Handling = ''
+
+        if args.MicroInDel_Length:
+
+                cfgvars.MicroInDel_Length = int(args.MicroInDel_Length)
+
+        else:
+
+                cfgvars.MicroInDel_Length = 0
+
+        if args.BED:
+
+                cfgvars.BED = True
+
+        else:
+
+                cfgvars.BED = False
+
+        if args.Output_Dir:
+
+                if not exists(str(args.Output_Dir)):
+
+                        cfgvars.Output_Dir = str(args.Output_Dir) + '/'
+
+                        makedirs(cfgvars.Output_Dir)
+
+                else:
+
+                        print "Output Directory already exists!  Appending time to directory name to prevent overwrite."
+
+                        cfgvars.Output_Dir = str(args.Output_Dir) + str(int(time.time())) + '/'
+
+                        makedirs(cfgvars.Output_Dir)
+
+        if cfgvars.BED:
+
+                if not exists(cfgvars.Output_Dir + 'BED_Files/'):
+
+                        makedirs(cfgvars.Output_Dir + 'BED_Files/')
+
+                else:
+
+                        makedirs(cfgvars.Output_Dir + 'BED_Files_' + str(int(time.time())) + '/')
+
+                        print "WARNING: BED Folder already present in output directory!"
+
+        else:
+
+                pass
+
+        print "Finding reference gene data using Bowtie-Inspect"
+
+        cfgvars.RefsLib1, cfgvars.RefsLib2, cfgvars.Genes = ExtractRefData()
+
+        if cfgvars.DeDup:
+
+                UniquifyReport(File1, 'DeDuped_' + File1)
+
+                File1 = 'DeDuped_' + File1
+
+        else:
+
+                pass
+
+        print "Sorting Results and saving into individual outputs"
+
+        ResultsSort(File1)
+
+
+
+##      -------------------------------------------------------------------------------------------
+
+##      End
+
+##      -------------------------------------------------------------------------------------------
+
