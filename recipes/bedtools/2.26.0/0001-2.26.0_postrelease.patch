diff --git a/Makefile b/Makefile
index 91cbbd5..80c5656 100644
--- a/Makefile
+++ b/Makefile
@@ -18,7 +18,7 @@ export SRC_DIR	= src
 export UTIL_DIR	= src/utils
 export CXX		= g++
 ifeq ($(DEBUG),1)
-export CXXFLAGS = -Wall -O0 -g -fno-inline -fkeep-inline-functions -D_FILE_OFFSET_BITS=64 -fPIC -DDEBUG -D_DEBUG
+export CXXFLAGS = -Wall -Wextra -DDEBUG -D_DEBUG -g -O0 -D_FILE_OFFSET_BITS=64 -fPIC $(INCLUDES)
 else
 export CXXFLAGS = -Wall -O2 -D_FILE_OFFSET_BITS=64 -fPIC $(INCLUDES)
 endif
diff --git a/docs/content/history.rst b/docs/content/history.rst
index c59e84e..ac04a02 100644
--- a/docs/content/history.rst
+++ b/docs/content/history.rst
@@ -4,23 +4,24 @@ Release History
 
 Version 2.26.0 (7-July-2016)
 ============================
-1. Fixed a major memory leak when using ``-sorted``. Thanks to Emily Tsang and Steohen Montgomery.
+1. Fixed a major memory leak when using ``-sorted``. Thanks to Emily Tsang and Stephen Montgomery.
 2. Fixed a bug for BED files containing a single record with no newline. Thanks to @jmarshall.
-3. The ``getfasta`` tool includes name, chromosome and position in fasta headers when the ``-name`` option is used. Thanks to @rishavray.
-4. Fixed a bug that now forces the ``coverage`` tool to process every record in the ``-a`` file.
-5. Fixed a bug preventing proper processing of BED files with consecutive tabs.
-6. VCF files containing structural variants now infer SV length from either the SVLEN or END INFO fields. Thanks to Zev Kronenberg.
-7. Resolve off by one bugs when intersecting GFF or VCF files with BED files.
-8. The ``shuffle`` tool now uses roulette wheel sampling to shuffle to ``-incl`` regions based upon the size of the interval. Thanks to Zev Kronenberg and Michael Imbeault.
-9. Fixed a bug in ``coverage`` that prevented correct calculation of depth when using the ``-split`` option.
-10. The ``shuffle`` tool warns when an interval exceeds the maximum chromosome length.
-11. The ``complement`` tool better checks intervals against the chromosome lengths.
-12. Fixes for ``stddev``, ``min``, and ``max`` operations. Thanks to @jmarshall.
-13. Enabled ``stdev``, ``sstdev``, ``freqasc``, and ``freqdesc`` options for ``groupby``.
-14. Allow ``-s`` and ``-w`` to be used in any order for ``makewindows``.
-15. Added new ``-bedOut`` option to ``getfasta``.
-16. The ``-r`` option forces the ``-F`` value for ``intersect``.
-17. Add ``-pc`` option to the ``genomecov`` tool, allowing coverage to be calculated based upon paired-end fragments.
+3. Fixed a bug in the contigency table values for thr ``fisher`` tool.
+4. The ``getfasta`` tool includes name, chromosome and position in fasta headers when the ``-name`` option is used. Thanks to @rishavray.
+5. Fixed a bug that now forces the ``coverage`` tool to process every record in the ``-a`` file.
+6. Fixed a bug preventing proper processing of BED files with consecutive tabs.
+7. VCF files containing structural variants now infer SV length from either the SVLEN or END INFO fields. Thanks to Zev Kronenberg.
+8. Resolve off by one bugs when intersecting GFF or VCF files with BED files.
+9. The ``shuffle`` tool now uses roulette wheel sampling to shuffle to ``-incl`` regions based upon the size of the interval. Thanks to Zev Kronenberg and Michael Imbeault.
+10. Fixed a bug in ``coverage`` that prevented correct calculation of depth when using the ``-split`` option.
+11. The ``shuffle`` tool warns when an interval exceeds the maximum chromosome length.
+12. The ``complement`` tool better checks intervals against the chromosome lengths.
+13. Fixes for ``stddev``, ``min``, and ``max`` operations. Thanks to @jmarshall.
+14. Enabled ``stdev``, ``sstdev``, ``freqasc``, and ``freqdesc`` options for ``groupby``.
+15. Allow ``-s`` and ``-w`` to be used in any order for ``makewindows``.
+16. Added new ``-bedOut`` option to ``getfasta``.
+17. The ``-r`` option forces the ``-F`` value for ``intersect``.
+18. Add ``-pc`` option to the ``genomecov`` tool, allowing coverage to be calculated based upon paired-end fragments.
 
 
 Version 2.25.0 (3-Sept-2015)
diff --git a/docs/index.rst b/docs/index.rst
index 2d67581..67cdd91 100755
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -11,6 +11,7 @@ genomic file formats such as BAM, BED, GFF/GTF, VCF. While each individual tool
 *intersect* two interval files), quite sophisticated analyses can be conducted
 by combining multiple bedtools operations on the UNIX command line.
 
+**bedtools** is developed in the `Quinlan laboratory <http://quinlanlab.org>`_ at the `University of Utah <http://www.utah.edu/>`_ and benefits from fantastic contributions made by scientists worldwide.
 
 ==========================
 Tutorial
diff --git a/docs/templates/sidebar-intro.html b/docs/templates/sidebar-intro.html
index 262da46..dc430e7 100644
--- a/docs/templates/sidebar-intro.html
+++ b/docs/templates/sidebar-intro.html
@@ -8,7 +8,7 @@
   <li><a target="_blank" href="https://bedtools.googlecode.com">Old Releases @ Google Code</a></li>
   <li><a target="_blank" href="http://groups.google.com/group/bedtools-discuss">Mailing list @ Google Groups</a></li>
   <li><a target="_blank" href="http://www.biostars.org/show/tag/bedtools/">Queries @ Biostar</a></li>
-  <li><a target="_blank" href="http://quinlanlab.org">Quinlan lab @ UVa</a></li>
+  <li><a target="_blank" href="http://quinlanlab.org">Quinlan lab @ UU</a></li>
 
 </ul>
 
diff --git a/src/annotateBed/annotateBed.cpp b/src/annotateBed/annotateBed.cpp
index 23c775a..d462944 100644
--- a/src/annotateBed/annotateBed.cpp
+++ b/src/annotateBed/annotateBed.cpp
@@ -57,13 +57,13 @@ void BedAnnotate::PrintHeader() {
     // print a hash to indicate header and then write a tab
     // for each field in the main file.
     printf("#");
-    for (size_t i = 0; i < _bed->bedType; ++i)
+    for (size_t i = 0; i < _bed->bedType -1; ++i)
         printf("\t");
 
     // now print the label for each file.
     if (_reportBoth == false) {
         for (size_t i = 0; i < _annoTitles.size(); ++i)
-            printf("%s\t", _annoTitles[i].c_str());
+            printf("\t%s", _annoTitles[i].c_str());
         printf("\n");
     }
     else {
diff --git a/src/bedtools.cpp b/src/bedtools.cpp
index 088ea70..b03b072 100644
--- a/src/bedtools.cpp
+++ b/src/bedtools.cpp
@@ -34,8 +34,8 @@ using namespace std;
 // define our parameter checking macro
 #define PARAMETER_CHECK(param, paramLen, actualLen) (strncmp(argv[i], param, min(actualLen, paramLen))== 0) && (actualLen == paramLen)
 
-bool sub_main(const QuickString &subCmd);
-void showHelp(const QuickString &subCmd);
+bool sub_main(const string &subCmd);
+void showHelp(const string &subCmd);
 
 int annotate_main(int argc, char* argv[]);//
 int bamtobed_main(int argc, char* argv[]);//
@@ -92,7 +92,7 @@ int main(int argc, char *argv[])
     // make sure the user at least entered a sub_command
     if (argc < 2) return bedtools_help();
 
-    QuickString subCmd(argv[1]);
+    string subCmd(argv[1]);
     BedtoolsDriver btDriver;
     if (btDriver.supports(subCmd)) {
 
@@ -190,8 +190,13 @@ int main(int argc, char *argv[])
 
 int bedtools_help(void)
 {
-    cout  << PROGRAM_NAME  << ": flexible tools for genome arithmetic and DNA sequence analysis.\n";
-    cout << "usage:    bedtools <subcommand> [options]" << endl << endl;
+    cout  << PROGRAM_NAME  << " is a powerful toolset for genome arithmetic." << endl << endl;
+    cout << "Version:   " << VERSION << endl;
+    cout << "About:     developed in the quinlanlab.org and by many contributors worldwide." << endl;
+    cout << "Docs:      http://bedtools.readthedocs.io/" << endl;
+    cout << "Code:      https://github.com/arq5x/bedtools2" << endl;
+    cout << "Mail:      https://groups.google.com/forum/#!forum/bedtools-discuss" << endl << endl;
+    cout << "Usage:     bedtools <subcommand> [options]" << endl << endl;
 
     cout  << "The bedtools sub-commands include:" << endl;
     
@@ -287,7 +292,7 @@ int bedtools_faq(void)
     return 0;
 }
 
-void showHelp(const QuickString &subCmd) {
+void showHelp(const string &subCmd) {
 	if (subCmd == "intersect") {
 		intersect_help();
 	} else if (subCmd == "map") {
diff --git a/src/complementFile/complementFile.cpp b/src/complementFile/complementFile.cpp
index 803b7c5..5d3b384 100644
--- a/src/complementFile/complementFile.cpp
+++ b/src/complementFile/complementFile.cpp
@@ -38,7 +38,7 @@ void ComplementFile::processHits(RecordOutputMgr *outputMgr, RecordKeyVector &hi
 	const Record *rec = hits.getKey();
 
 	//test for chrom change.
-	const QuickString &newChrom = rec->getChrName();
+	const string &newChrom = rec->getChrName();
 	if (_currChrom != newChrom) {
 
 		outPutLastRecordInPrevChrom();
@@ -95,7 +95,7 @@ void ComplementFile::giveFinalReport(RecordOutputMgr *outputMgr) {
 
 void ComplementFile::outPutLastRecordInPrevChrom()
 {
-	const QuickString &chrom = _outRecord.getChrName();
+	const string &chrom = _outRecord.getChrName();
 
 	//do nothing if triggered by first record in DB. At this point,
 	//there was no prev chrom, so nothing is stored in the output Record yet.
@@ -106,7 +106,7 @@ void ComplementFile::outPutLastRecordInPrevChrom()
 	printRecord(maxChromSize);
 }
 
-bool ComplementFile::fastForward(const QuickString &newChrom) {
+bool ComplementFile::fastForward(const string &newChrom) {
 	if (!newChrom.empty() && !_genomeFile->hasChrom(newChrom)) return false;
 
 	int i= _currPosInGenomeList +1;
@@ -133,14 +133,14 @@ bool ComplementFile::fastForward(const QuickString &newChrom) {
 void ComplementFile::printRecord(int endPos)
 {
 	_outRecord.setStartPos(_currStartPos);
-	QuickString startStr;
-	startStr.append(_currStartPos);
-	_outRecord.setStartPosStr(startStr);
+	stringstream startStr;
+	startStr << _currStartPos;
+	_outRecord.setStartPosStr(startStr.str());
 
 	_outRecord.setEndPos(endPos);
-	QuickString endStr;
-	endStr.append(endPos);
-	_outRecord.setEndPosStr(endStr);
+	stringstream endStr;
+	endStr << endPos;
+	_outRecord.setEndPosStr(endStr.str());
 
 	_outputMgr->printRecord(&_outRecord);
 	_outputMgr->newline();
diff --git a/src/complementFile/complementFile.h b/src/complementFile/complementFile.h
index 3382dbd..a90b6c2 100644
--- a/src/complementFile/complementFile.h
+++ b/src/complementFile/complementFile.h
@@ -34,17 +34,17 @@ public:
 protected:
 	FileRecordMergeMgr *_frm;
 	Bed3Interval _outRecord;
-	QuickString _currChrom;
+	string _currChrom;
 	const NewGenomeFile *_genomeFile;
 	int _currStartPos;
 	RecordOutputMgr *_outputMgr;
-	const vector<QuickString> &_chromList;
+	const vector<string> &_chromList;
 	int _currPosInGenomeList;
 
 	virtual ContextComplement *upCast(ContextBase *context) { return static_cast<ContextComplement *>(context); }
 
 	void outPutLastRecordInPrevChrom();
-	bool fastForward(const QuickString &newChrom);
+	bool fastForward(const string &newChrom);
 	void printRecord(int endPos);
 
 };
diff --git a/src/coverageFile/coverageFile.cpp b/src/coverageFile/coverageFile.cpp
index 9473eeb..b01eda4 100644
--- a/src/coverageFile/coverageFile.cpp
+++ b/src/coverageFile/coverageFile.cpp
@@ -6,6 +6,7 @@
  */
 
 #include "coverageFile.h"
+#include <iomanip>
 
 CoverageFile::CoverageFile(ContextCoverage *context)
 : IntersectFile(context),
@@ -13,6 +14,7 @@ CoverageFile::CoverageFile(ContextCoverage *context)
  _depthArrayCapacity(0),
  _queryLen(0),
  _totalQueryLen(0),
+ _hitCount(0),
  _queryOffset(0),
  _floatValBuf(NULL)
 {
@@ -34,40 +36,38 @@ CoverageFile::~CoverageFile() {
 }
 
 
-void CoverageFile::processHits(RecordOutputMgr *outputMgr, RecordKeyVector &hits) {
-	   makeDepthCount(hits);
-	   _finalOutput.clear();
-
-	   switch(upCast(_context)->getCoverageType()) {
-	   case ContextCoverage::COUNT:
-		   doCounts(outputMgr, hits);
-		   break;
-
-	   case ContextCoverage::PER_BASE:
-		   doPerBase(outputMgr, hits);
-		   break;
-
-	   case ContextCoverage::MEAN:
-		   doMean(outputMgr, hits);
-		   break;
-
-	   case ContextCoverage::HIST:
-		   doHist(outputMgr, hits);
-		   break;
-
-	   case ContextCoverage::DEFAULT:
-	   default:
-		   doDefault(outputMgr, hits);
-		   break;
-
-	   }
-
+void CoverageFile::processHits(RecordOutputMgr *outputMgr, RecordKeyVector &hits) 
+{
+	makeDepthCount(hits);
+	_finalOutput.clear();
+
+	switch(upCast(_context)->getCoverageType()) {
+	case ContextCoverage::COUNT:
+	   doCounts(outputMgr, hits);
+	   break;
+
+	case ContextCoverage::PER_BASE:
+	   doPerBase(outputMgr, hits);
+	   break;
+
+	case ContextCoverage::MEAN:
+	   doMean(outputMgr, hits);
+	   break;
+
+	case ContextCoverage::HIST:
+	   doHist(outputMgr, hits);
+	   break;
+
+	case ContextCoverage::DEFAULT:
+	default:
+	   doDefault(outputMgr, hits);
+	   break;
+	}
 }
 
 void CoverageFile::cleanupHits(RecordKeyVector &hits) {
 	IntersectFile::cleanupHits(hits);
 	memset(_depthArray, 0, sizeof(size_t) * _queryLen);
-
 }
 
 void CoverageFile::giveFinalReport(RecordOutputMgr *outputMgr) {
@@ -77,19 +77,25 @@ void CoverageFile::giveFinalReport(RecordOutputMgr *outputMgr) {
 		return;
 	}
 
+	
 	for (depthMapType::iterator iter = _finalDepthMap.begin(); iter != _finalDepthMap.end(); iter++) {
 		size_t depth = iter->first;
 		size_t basesAtDepth = iter->second;
+		//cout << "x\n";
 		float depthPct = (float)basesAtDepth / (float)_totalQueryLen;
-
-		_finalOutput = "all\t";
-		_finalOutput.append(static_cast<uint32_t>(depth));
-		_finalOutput.append("\t");
-		_finalOutput.append(static_cast<uint32_t>(basesAtDepth));
-		_finalOutput.append("\t");
-		_finalOutput.append(static_cast<uint32_t>(_totalQueryLen));
-		_finalOutput.append("\t");
-		format(depthPct);
+		//cout << "y\n";
+		ostringstream s;
+		s << "all\t";
+		s << depth;
+		s << "\t";
+		s << basesAtDepth;
+		s << "\t";
+		s << _totalQueryLen;
+		s << "\t";
+		char *depthPctString;
+		asprintf(&depthPctString, "%0.7f", depthPct);
+		s << depthPctString;
+		_finalOutput = s.str();
 
 		outputMgr->printRecord(NULL, _finalOutput);
 	}
@@ -101,24 +107,57 @@ void CoverageFile::makeDepthCount(RecordKeyVector &hits) {
 	_queryLen = (size_t)(key->getEndPos() - _queryOffset);
 	_totalQueryLen += _queryLen;
 
-	//resize depth array if needed
+	// resize depth array if needed
 	if (_depthArrayCapacity < _queryLen) {
 		_depthArray = (size_t*)realloc(_depthArray, sizeof(size_t) * _queryLen);
 		_depthArrayCapacity = _queryLen;
 		memset(_depthArray, 0, sizeof(size_t) * _depthArrayCapacity);
 	}
-
-	//loop through hits, which may not be in sorted order, due to
-	//potential multiple databases, and increment the depth array as needed.
-	for (RecordKeyVector::const_iterator_type iter = hits.begin(); iter != hits.end(); iter = hits.next()) {
-		const Record *dbRec = *iter;
-		int dbStart = dbRec->getStartPos();
-		int dbEnd = dbRec->getEndPos();
-		int maxStart = max(_queryOffset, dbStart);
-		int minEnd = min(dbEnd, key->getEndPos());
-
-		for (int i=maxStart; i < minEnd; i++) {
-			_depthArray[i - _queryOffset]++;
+	_hitCount = 0;
+	// no -split
+	if (!(_context)->getObeySplits())
+	{
+		//loop through hits, which may not be in sorted order, due to
+		//potential multiple databases, and increment the depth array as needed.
+		for (RecordKeyVector::iterator_type iter = hits.begin(); iter != hits.end(); iter = hits.next()) 
+		{
+			const Record *dbRec = *iter;
+			int dbStart = dbRec->getStartPos();
+			int dbEnd = dbRec->getEndPos();
+			int maxStart = max(_queryOffset, dbStart);
+			int minEnd = min(dbEnd, key->getEndPos());
+
+			for (int i=maxStart; i < minEnd; i++) {
+				_depthArray[i - _queryOffset]++;
+			}
+			_hitCount++;
+		}
+	}
+	// -split
+	else
+	{
+		for (RecordKeyVector::iterator_type iter = hits.begin(); iter != hits.end(); iter = hits.next()) {
+			const Record *dbRec = *iter;
+			bool count_hit  = false;
+			for (size_t i = 0; i < dbRec->block_starts.size(); ++i)
+			{
+				int block_start = dbRec->block_starts[i];
+				int block_end = dbRec->block_ends[i];
+				int maxStart = max(_queryOffset, block_start);
+				int minEnd = min(block_end, key->getEndPos());
+				if ((minEnd - maxStart) > 0)
+				{
+					for (int i = maxStart; i < minEnd; i++) 
+					{
+						_depthArray[i - _queryOffset]++;
+					}
+					count_hit = true;
+				}
+			}
+			if (count_hit)
+			{
+				_hitCount++;
+			}
 		}
 	}
 }
@@ -135,19 +174,23 @@ size_t CoverageFile::countBasesAtDepth(size_t depth) {
 
 void CoverageFile::doCounts(RecordOutputMgr *outputMgr, RecordKeyVector &hits)
 {
-	_finalOutput = static_cast<uint32_t>(hits.size());
+	ostringstream s;
+	s << _hitCount;
+	_finalOutput.append(s.str());
 	outputMgr->printRecord(hits.getKey(), _finalOutput);
 }
 
 void CoverageFile::doPerBase(RecordOutputMgr *outputMgr, RecordKeyVector &hits)
 {
 	//loop through all bases in query, printing full record and metrics for each
-	const Record * queryRec = hits.getKey();
+	
+	Record * queryRec = hits.getKey();
 	for (size_t i= 0; i < _queryLen; i++) {
-		_finalOutput = static_cast<uint32_t>(i+1);
-		_finalOutput.append("\t");
-		_finalOutput.append(static_cast<uint32_t>(_depthArray[i]));
-
+		ostringstream s;
+		s << (i+1);
+		s << "\t";
+		s << _depthArray[i];
+		_finalOutput = s.str();
 		outputMgr->printRecord(queryRec, _finalOutput);
 	}
 }
@@ -158,7 +201,12 @@ void CoverageFile::doMean(RecordOutputMgr *outputMgr, RecordKeyVector &hits)
 	for (size_t i= 0; i < _queryLen; i++) {
 		sum += _depthArray[i];
 	}
-	format((float)sum / (float)_queryLen);
+	ostringstream s;
+	float mean = ((float)sum / (float)_queryLen);
+	char *meanString;
+	asprintf(&meanString, "%0.7f", mean);
+	s << meanString;
+	_finalOutput.append(s.str());
 	outputMgr->printRecord(hits.getKey(), _finalOutput);
 }
 
@@ -166,7 +214,6 @@ void CoverageFile::doMean(RecordOutputMgr *outputMgr, RecordKeyVector &hits)
 void CoverageFile::doHist(RecordOutputMgr *outputMgr, RecordKeyVector &hits)
 {
 	//make a map of depths to num bases with that depth
-
 	_currDepthMap.clear();
 	for (size_t i=0; i < _queryLen; i++) {
 		_currDepthMap[_depthArray[i]]++;
@@ -176,40 +223,38 @@ void CoverageFile::doHist(RecordOutputMgr *outputMgr, RecordKeyVector &hits)
 	for (depthMapType::iterator iter = _currDepthMap.begin(); iter != _currDepthMap.end(); iter++) {
 		size_t depth = iter->first;
 		size_t numBasesAtDepth = iter->second;
-		float coveredBases = (float)numBasesAtDepth / (float)_queryLen;
-
-		_finalOutput = static_cast<uint32_t>(depth);
-		_finalOutput.append("\t");
-		_finalOutput.append(static_cast<uint32_t>(numBasesAtDepth));
-		_finalOutput.append("\t");
-		_finalOutput.append(static_cast<uint32_t>(_queryLen));
-		_finalOutput.append("\t");
-		format(coveredBases);
-
+		float coveredFraction = (float)numBasesAtDepth / (float)_queryLen;
+
+		ostringstream s;
+		s << depth;
+		s << "\t";
+		s << numBasesAtDepth;
+		s << "\t";
+		s << _queryLen;
+		s << "\t";
+		char *coveredFractionString;
+		asprintf(&coveredFractionString, "%0.7f", coveredFraction);
+		s << coveredFractionString;
+		_finalOutput = s.str();
 		outputMgr->printRecord(hits.getKey(), _finalOutput);
 	}
-
 }
 
 void CoverageFile::doDefault(RecordOutputMgr *outputMgr, RecordKeyVector &hits)
 {
 	size_t nonZeroBases = _queryLen - countBasesAtDepth(0);
-	float coveredBases = (float)nonZeroBases / (float)_queryLen;
-
-	_finalOutput = static_cast<uint32_t>(hits.size());
-	_finalOutput.append("\t");
-	_finalOutput.append(static_cast<uint32_t>(nonZeroBases));
-	_finalOutput.append("\t");
-	_finalOutput.append(static_cast<uint32_t>(_queryLen));
-	_finalOutput.append("\t");
-	format(coveredBases);
-
+	float coveredFraction = (float)nonZeroBases / (float)_queryLen;
+
+	ostringstream s;
+	s << _hitCount;
+	s << "\t";
+	s << nonZeroBases;
+	s << "\t";
+	s << _queryLen;
+	s << "\t";
+	char *coveredFractionString;
+	asprintf(&coveredFractionString, "%0.7f", coveredFraction);
+	s << coveredFractionString;
+	_finalOutput = s.str();
 	outputMgr->printRecord(hits.getKey(), _finalOutput);
 }
-
-void CoverageFile::format(float val)
-{
-	memset(_floatValBuf, 0, floatValBufLen);
-	sprintf(_floatValBuf, "%0.7f", val);
-   _finalOutput.append(_floatValBuf);
-}
diff --git a/src/coverageFile/coverageFile.h b/src/coverageFile/coverageFile.h
index fa2c662..691b74f 100644
--- a/src/coverageFile/coverageFile.h
+++ b/src/coverageFile/coverageFile.h
@@ -8,6 +8,7 @@
 #ifndef COVERAGEFILE_H_
 #define COVERAGEFILE_H_
 
+#include <stdio.h> // for asprintf
 #include "intersectFile.h"
 #include "ContextCoverage.h"
 
@@ -21,12 +22,13 @@ public:
 
 
 protected:
-	QuickString _finalOutput;
+	string _finalOutput;
 
 	size_t *_depthArray;
 	size_t _depthArrayCapacity;
 	size_t _queryLen;
 	size_t _totalQueryLen;
+	size_t _hitCount;
 	int _queryOffset;
 	static const int DEFAULT_DEPTH_CAPACITY = 1024;
 	char *_floatValBuf;
@@ -47,9 +49,6 @@ protected:
 	void doMean(RecordOutputMgr *outputMgr, RecordKeyVector &hits);
 	void doHist(RecordOutputMgr *outputMgr, RecordKeyVector &hits);
 	void doDefault(RecordOutputMgr *outputMgr, RecordKeyVector &hits);
-
-	void format(float val);
-
 };
 
 
diff --git a/src/fisher/fisher.cpp b/src/fisher/fisher.cpp
index 7548f18..583b467 100644
--- a/src/fisher/fisher.cpp
+++ b/src/fisher/fisher.cpp
@@ -91,7 +91,7 @@ void Fisher::giveFinalReport(RecordOutputMgr *outputMgr)
 unsigned long Fisher::getTotalIntersection(RecordKeyVector &recList)
 {
     unsigned long intersection = 0;
-    const Record *key = recList.getKey();
+    Record *key = recList.getKey();
     int keyStart = key->getStartPos();
     int keyEnd = key->getEndPos();
 
@@ -99,7 +99,7 @@ unsigned long Fisher::getTotalIntersection(RecordKeyVector &recList)
     _qsizes.push_back((keyEnd - keyStart));
 
     int hitIdx = 0;
-    for (RecordKeyVector::const_iterator_type iter = recList.begin(); iter != recList.end(); iter = recList.next()) {
+    for (RecordKeyVector::iterator_type iter = recList.begin(); iter != recList.end(); iter = recList.next()) {
         int maxStart = max((*iter)->getStartPos(), keyStart);
         int minEnd = min((*iter)->getEndPos(), keyEnd);
         _qsizes.push_back((int)(minEnd - maxStart));
diff --git a/src/groupBy/Makefile b/src/groupBy/Makefile
index 9bb141a..44cd7aa 100644
--- a/src/groupBy/Makefile
+++ b/src/groupBy/Makefile
@@ -10,6 +10,7 @@ INCLUDES = -I$(UTILITIES_DIR)/Contexts/ \
 			-I$(UTILITIES_DIR)/general/ \
 			-I$(UTILITIES_DIR)/fileType/ \
 			-I$(UTILITIES_DIR)/lineFileUtilities/ \
+			-I$(UTILITIES_DIR)/stringUtilities/ \
 			-I$(UTILITIES_DIR)/gzstream/ \
            -I$(UTILITIES_DIR)/GenomeFile/ \
            -I$(UTILITIES_DIR)/BamTools/include \
diff --git a/src/groupBy/groupBy.cpp b/src/groupBy/groupBy.cpp
index 867f15f..1e1dbda 100644
--- a/src/groupBy/groupBy.cpp
+++ b/src/groupBy/groupBy.cpp
@@ -7,6 +7,8 @@
 #include "groupBy.h"
 #include "Tokenizer.h"
 #include "ParseTools.h"
+#include "stringUtilities.h"
+#include <utility>
 
 GroupBy::GroupBy(ContextGroupBy *context)
 : ToolBase(context),
@@ -29,8 +31,8 @@ bool GroupBy::init()
 	for (int i=0; i < numElems; i++) {
 		//if the item is a range, such as 3-5,
 		//must split that as well.
-		const QuickString &elem = groupColsTokens.getElem(i);
 
+		const string &elem = groupColsTokens.getElem(i);
 		if (strchr(elem.c_str(), '-')) {
 			Tokenizer rangeElems;
 			rangeElems.tokenize(elem, '-');
@@ -59,14 +61,19 @@ bool GroupBy::findNext(RecordKeyVector &hits)
 	assignPrevFields();
 	hits.setKey(_prevRecord);
 	hits.push_back(_prevRecord); //key should also be part of group for calculations
-	while (1) {
-		const Record *newRecord = getNextRecord();
-		if (newRecord == NULL) {
+	while (1) 
+	{
+		Record *newRecord = getNextRecord();
+		if (newRecord == NULL) 
+		{
 			_prevRecord = NULL;
 			break;
-		} else if (canGroup(newRecord)) {
+		} else if (canGroup(newRecord)) 
+		{
 			hits.push_back(newRecord);
-		} else {
+		} 
+		else 
+		{
 			_prevRecord = newRecord;
 			break;
 		}
@@ -77,15 +84,19 @@ bool GroupBy::findNext(RecordKeyVector &hits)
 void GroupBy::processHits(RecordOutputMgr *outputMgr, RecordKeyVector &hits)
 {
 
-	const Record *rec = hits.getKey();
-	const QuickString &opVal  = _context->getColumnOpsVal(hits);
-	if (upCast(_context)->printFullCols()) {
+	Record *rec = hits.getKey();
+	const string &opVal  = _context->getColumnOpsVal(hits);
+	if (upCast(_context)->printFullCols()) 
+	{
 		outputMgr->printRecord(rec, opVal);
-	} else {
-		QuickString outBuf;
-		for (int i=0; i < (int)_groupCols.size(); i++) {
+	} 
+	else 
+	{
+		string outBuf;
+		for (int i = 0; i < (int)_groupCols.size(); i++) 
+		{
 			outBuf.append(rec->getField(_groupCols[i]));
-			outBuf.append('\t');
+			outBuf.append("\t");
 		}
 		outBuf.append(opVal);
 		outputMgr->printRecord(NULL, outBuf);
@@ -95,7 +106,7 @@ void GroupBy::processHits(RecordOutputMgr *outputMgr, RecordKeyVector &hits)
 
 void GroupBy::cleanupHits(RecordKeyVector &hits)
 {
-	RecordKeyVector::const_iterator_type iter = hits.begin();
+	RecordKeyVector::iterator_type iter = hits.begin();
 	for (; iter != hits.end(); iter = hits.next()) 
 	{
 		_queryFRM->deleteRecord(*iter);	
@@ -103,12 +114,16 @@ void GroupBy::cleanupHits(RecordKeyVector &hits)
 	hits.clearAll();
 }
 
-const Record *GroupBy::getNextRecord() {
-	while (!_queryFRM->eof()) {
+Record *GroupBy::getNextRecord() {
+	while (!_queryFRM->eof()) 
+	{
 		Record *queryRecord = _queryFRM->getNextRecord();
-		if (queryRecord == NULL) {
+		if (queryRecord == NULL) 
+		{
 			continue;
-		} else {
+		} 
+		else 
+		{
 			return queryRecord;
 		}
 	}
@@ -121,19 +136,22 @@ void GroupBy::assignPrevFields() {
 	}
 }
 
-bool GroupBy::canGroup(const Record *newRecord) {
-
-	for (int i=0; i < (int)_groupCols.size(); i++) {
+bool GroupBy::canGroup(Record *newRecord) 
+{
+	for (int i = 0; i < (int)_groupCols.size(); i++) 
+	{
 		int fieldNum = _groupCols[i];
-		const QuickString &newField = newRecord->getField(fieldNum);
-		const QuickString &oldField = _prevFields[i];
-		if (upCast(_context)->ignoreCase()) {
-			if (oldField.stricmp(newField)) return false;
-		} else {
+		const string &newField = newRecord->getField(fieldNum);
+		const string &oldField = _prevFields[i];
+		if (upCast(_context)->ignoreCase()) 
+		{
+			if (toLower(oldField) != toLower(newField)) return false;
+		} 
+		else 
+		{
 			if (oldField != newField) return false;
 		}
 	}
 	return true;
-
 }
 
diff --git a/src/groupBy/groupBy.h b/src/groupBy/groupBy.h
index 2c96dc9..c44ba3c 100644
--- a/src/groupBy/groupBy.h
+++ b/src/groupBy/groupBy.h
@@ -27,11 +27,11 @@ protected:
 	virtual ContextGroupBy *upCast(ContextBase *context) { return static_cast<ContextGroupBy *>(context); }
 
 	vector<int> _groupCols;
-	vector<QuickString> _prevFields;
+	vector<string> _prevFields;
 	FileRecordMgr *_queryFRM;
-	const Record *_prevRecord;
-	const Record *getNextRecord();
-	bool canGroup(const Record *);
+	Record *_prevRecord;
+	Record *getNextRecord();
+	bool canGroup(Record *);
 	void assignPrevFields();
 };
 
diff --git a/src/intersectFile/intersectFile.cpp b/src/intersectFile/intersectFile.cpp
index 01bb222..45977fc 100644
--- a/src/intersectFile/intersectFile.cpp
+++ b/src/intersectFile/intersectFile.cpp
@@ -67,6 +67,7 @@ bool IntersectFile::findNext(RecordKeyVector &hits)
 
 void IntersectFile::processHits(RecordOutputMgr *outputMgr, RecordKeyVector &hits)
 {
+	RecordKeyVector::iterator_type hitListIter = hits.begin();
 	outputMgr->printRecord(hits);
 }
 
@@ -120,19 +121,16 @@ void IntersectFile::makeSweep() {
 void IntersectFile::checkSplits(RecordKeyVector &hitSet)
 {
 	if (upCast(_context)->getObeySplits()) {
-		RecordKeyVector keySet(hitSet.getKey());
-		RecordKeyVector resultSet(hitSet.getKey());
-		RecordKeyVector overlapSet(hitSet.getKey());
-		upCast(_context)->getSplitBlockInfo()->findBlockedOverlaps(keySet, hitSet, resultSet, overlapSet);
-		
+
 		// when using coverage, we need a list of the sub-intervals of coverage
 		// so that per-base depth can be properly calculated when obeying splits
 		if (_context->getProgram() == ContextBase::COVERAGE)
 		{
-			hitSet.swap(overlapSet);
+			upCast(_context)->getSplitBlockInfo()->findBlockedOverlaps(hitSet, true);
 		}
-		else {
-			hitSet.swap(resultSet);
+		else
+		{
+			upCast(_context)->getSplitBlockInfo()->findBlockedOverlaps(hitSet, false);
 		}
 	}
 }
diff --git a/src/intersectFile/intersectFile.h b/src/intersectFile/intersectFile.h
index f40e750..3c85f93 100644
--- a/src/intersectFile/intersectFile.h
+++ b/src/intersectFile/intersectFile.h
@@ -26,11 +26,11 @@ public:
     IntersectFile(ContextIntersect *context);
     virtual ~IntersectFile();
 	virtual bool init();
-	virtual bool findNext(RecordKeyVector &hits);
-	virtual void processHits(RecordOutputMgr *outputMgr, RecordKeyVector &hits);
-	virtual void cleanupHits(RecordKeyVector &hits);
+	virtual bool findNext(RecordKeyVector &);
+	virtual void processHits(RecordOutputMgr *, RecordKeyVector &);
+	virtual void cleanupHits(RecordKeyVector &);
 	virtual bool finalizeCalculations();
-	virtual void  giveFinalReport(RecordOutputMgr *outputMgr) {}
+	virtual void  giveFinalReport(RecordOutputMgr *) {}
 
 
 protected:
diff --git a/src/jaccard/jaccard.cpp b/src/jaccard/jaccard.cpp
index c99c117..2f61b86 100644
--- a/src/jaccard/jaccard.cpp
+++ b/src/jaccard/jaccard.cpp
@@ -57,13 +57,13 @@ void  Jaccard::giveFinalReport(RecordOutputMgr *outputMgr) {
 unsigned long Jaccard::getTotalIntersection(RecordKeyVector &hits)
 {
 	unsigned long intersection = 0;
-	const Record *key = hits.getKey();
+	Record *key = hits.getKey();
 	int keyStart = key->getStartPos();
 	int keyEnd = key->getEndPos();
 
 	int hitIdx = 0;
-	for (RecordKeyVector::const_iterator_type iter = hits.begin(); iter != hits.end(); iter = hits.next()) {
-		const Record *currRec = *iter;
+	for (RecordKeyVector::iterator_type iter = hits.begin(); iter != hits.end(); iter = hits.next()) {
+		Record *currRec = *iter;
 		int maxStart = max(currRec->getStartPos(), keyStart);
 		int minEnd = min(currRec->getEndPos(), keyEnd);
 		if (_context->getObeySplits()) {
diff --git a/src/jaccard/jaccard.h b/src/jaccard/jaccard.h
index e23ad9c..8c4f6db 100644
--- a/src/jaccard/jaccard.h
+++ b/src/jaccard/jaccard.h
@@ -15,11 +15,11 @@ class Jaccard : public IntersectFile {
 
 public:
 	Jaccard(ContextJaccard *context);
-	virtual bool findNext(RecordKeyVector &hits);
-	virtual void processHits(RecordOutputMgr *outputMgr, RecordKeyVector &hits) {}
-	virtual void cleanupHits(RecordKeyVector &hits);
+	virtual bool findNext(RecordKeyVector &);
+	virtual void processHits(RecordOutputMgr *, RecordKeyVector &) {}
+	virtual void cleanupHits(RecordKeyVector &);
 	virtual bool finalizeCalculations();
-	virtual void  giveFinalReport(RecordOutputMgr *outputMgr);
+	virtual void  giveFinalReport(RecordOutputMgr *);
 
 
 protected:
diff --git a/src/nekSandbox1/nekSandboxMain.cpp b/src/nekSandbox1/nekSandboxMain.cpp
index d228540..d9b298a 100644
--- a/src/nekSandbox1/nekSandboxMain.cpp
+++ b/src/nekSandbox1/nekSandboxMain.cpp
@@ -67,7 +67,7 @@ int nek_sandbox1_main(int argc,char** argv)
 //		printf("%s", sLine);
 //	}
 //	return 0;
-//	QuickString filename(argv[1]);
+//	string filename(argv[1]);
 //	istream *inputStream = NULL;
 //	if (filename  == "-") {
 //		inputStream = &cin;
@@ -91,7 +91,7 @@ int nek_sandbox1_main(int argc,char** argv)
 ////		exit(1);
 ////	}
 ////	}
-//    QuickString _bamHeader = _bamReader.GetHeaderText();
+//    string _bamHeader = _bamReader.GetHeaderText();
 //    BamTools::RefVector _references = _bamReader.GetReferenceData();
 //
 //    if (_bamHeader.empty() || _references.empty()) {
@@ -107,10 +107,10 @@ int nek_sandbox1_main(int argc,char** argv)
 //		exit(1);
 //	}
 //	string sLine;
-//	vector<QuickString> fields;
-//	QuickString chrName;
+//	vector<string> fields;
+//	string chrName;
 //
-//	vector<QuickString> chroms;
+//	vector<string> chroms;
 //	chroms.push_back("1");
 //	chroms.push_back("2");
 //	chroms.push_back("10");
@@ -127,7 +127,7 @@ int nek_sandbox1_main(int argc,char** argv)
 //			continue;
 //		}
 //		Tokenize(sLine.c_str(), fields);
-//		const QuickString &currChrom = fields[2];
+//		const string &currChrom = fields[2];
 //		if (currChrom == chroms[chromIdx]) {
 //			cout << sLine << endl;
 //			chromCounts[chromIdx]++;
@@ -157,7 +157,7 @@ int nek_sandbox1_main(int argc,char** argv)
 //	cout << "RecordType is : " << frm.getRecordType() << ", " << frm.getRecordTypeName() << "."  << endl;
 //
 //	bool headerFound = false;
-//	QuickString outbuf;
+//	string outbuf;
 //	while (!frm.eof()) {
 //		Record *record = frm.getNextRecord();
 //		if (!headerFound && frm.hasHeader()) {
diff --git a/src/regressTest/regressTestMain.cpp b/src/regressTest/regressTestMain.cpp
index 0377ca6..01a2816 100644
--- a/src/regressTest/regressTestMain.cpp
+++ b/src/regressTest/regressTestMain.cpp
@@ -3,7 +3,7 @@
 #include <cstring>
 #include <cstdlib>
 #include <cstdio>
-#include "QuickString.h"
+#include "string.h"
 
 void usage()  {
 	printf("Usage: bedtools regressTest sub-prog targetVersion configFile [optionsToTest]\n");
@@ -31,7 +31,7 @@ int regress_test_main(int argc, char **argv) {
 		usage();
 		exit(1);
 	}
-	QuickString program(argv[2]);
+	string program(argv[2]);
 
 	RegressTest *regressTest = new RegressTest();
 
diff --git a/src/shiftBed/shiftBed.cpp b/src/shiftBed/shiftBed.cpp
index 81022f8..50724ce 100644
--- a/src/shiftBed/shiftBed.cpp
+++ b/src/shiftBed/shiftBed.cpp
@@ -51,7 +51,7 @@ void BedShift::AddShift(BED &bed) {
 
   CHRPOS chromSize = (CHRPOS)_genome->getChromSize(bed.chrom);
 
-  float shift;
+  double shift;
 
   if (bed.strand == "-") {
     shift = _shiftMinus;
@@ -59,7 +59,7 @@ void BedShift::AddShift(BED &bed) {
     shift = _shiftPlus;
   }
   if (_fractional == true)
-    shift = shift * (float)bed.size();
+    shift = shift * (double)bed.size();
 
   if ((bed.start + shift) < 0)
     bed.start = 0;
diff --git a/src/shuffleBed/shuffleBed.cpp b/src/shuffleBed/shuffleBed.cpp
index 9b71125..2478ccc 100644
--- a/src/shuffleBed/shuffleBed.cpp
+++ b/src/shuffleBed/shuffleBed.cpp
@@ -73,14 +73,15 @@ BedShuffle::BedShuffle(string &bedFile, string &genomeFile,
         _haveExclude = true;
     }
     
-    if (_haveInclude) {
+    if (_haveInclude) 
+    {
         _include = new BedFile(includeFile);
-	_include->loadBedFileIntoVector();
-
-	for(std::vector<BED>::iterator it = _include->bedList.begin();
-	    it != _include->bedList.end(); it++){
-	  _cumLen += (*it).end - (*it).start;
-	}	
+        _include->loadBedFileIntoVector();
+        _include->assignWeightsBasedOnSize();
+        // for(std::vector<BED>::iterator it = _include->bedList.begin(); it != _include->bedList.end(); it++)
+        // {
+        //     _cumLen += (*it).end - (*it).start;
+        // }	
     }
 
     if (_haveExclude == true && _haveInclude == false)
@@ -451,37 +452,16 @@ void BedShuffle::ChoosePairedLocus(BEDPE &b) {
 }
 
 
-void BedShuffle::ChooseLocusFromInclusionFile(BED &bedEntry) {
-
-    string chrom    = bedEntry.chrom;
-    CHRPOS length   = bedEntry.end - bedEntry.start;
-
-    string randomChrom;
-    CHRPOS randomStart;
-    BED includeInterval;
-    
-    // choose an -incl interval randomly.
+void BedShuffle::ChooseLocusFromInclusionFile(BED &bedEntry) 
+{
+    // choose an -incl interval randomly, yet weighted by the size of the incl interval.
+    size_t length = (bedEntry.end - bedEntry.start);
+    double runif =((double)rand()/(double)RAND_MAX);
+    BED *includeInterval = _include->sizeWeightedSearch(runif);
     
-    bool nohit = true;
-    while(nohit){
-      
-      includeInterval = _include->bedList[rand() % _include->bedList.size()];
-      
-      double prop = double(includeInterval.end
-			   - includeInterval.start) / _cumLen;
-      double runif =((double)rand()/(double)RAND_MAX);
-
-      if(runif < prop){
-	nohit = false;
-      }
-      if(_sameChrom == true && (includeInterval.chrom != chrom)){
-	nohit = true;
-      }
-           
-    }
-
-    bedEntry.chrom = includeInterval.chrom;
-    randomStart    = includeInterval.start + rand() % (includeInterval.size());
+    // choose a random start within the -incl interval and reconstruct shuffled record
+    CHRPOS randomStart = includeInterval->start + (rand() % (includeInterval->size()));
+    bedEntry.chrom = includeInterval->chrom;
     bedEntry.start = randomStart;
     bedEntry.end   = randomStart + length;
 }
diff --git a/src/spacingFile/spacingFile.cpp b/src/spacingFile/spacingFile.cpp
index 87f7528..ca613ba 100644
--- a/src/spacingFile/spacingFile.cpp
+++ b/src/spacingFile/spacingFile.cpp
@@ -49,9 +49,14 @@ bool SpacingFile::findNext(RecordKeyVector &hits)
 			{
 				// do _currRec and _prevRec overlap?
 				if (_currRec->sameChromIntersects(_prevRec, false, false, 1E-9, 1E-9, false, false))
-					_distance.append(0);
+					_distance.append("0");
 				else
-					_distance.append(_currRec->getStartPos() - _prevRec->getEndPos());
+				{
+					int distance = _currRec->getStartPos() - _prevRec->getEndPos();
+					ostringstream s;
+					s << distance;
+					_distance.append(s.str());
+				}
 			}
 			// we have changed chromosomes
 			else if (_currRec->getChrName() != _prevRec->getChrName())
diff --git a/src/spacingFile/spacingFile.h b/src/spacingFile/spacingFile.h
index e1556c8..d7321b9 100644
--- a/src/spacingFile/spacingFile.h
+++ b/src/spacingFile/spacingFile.h
@@ -22,13 +22,13 @@ public:
     virtual void processHits(RecordOutputMgr *outputMgr, RecordKeyVector &hits);
     virtual void cleanupHits(RecordKeyVector &hits);
     virtual bool finalizeCalculations() { return true; }
-    virtual void  giveFinalReport(RecordOutputMgr *outputMgr) {}
+    virtual void  giveFinalReport(RecordOutputMgr *) {}
 
 
 protected:
-    const Record *_prevRec;
-    const Record *_currRec;
-    QuickString _distance;
+    Record *_prevRec;
+    Record *_currRec;
+    string _distance;
 
     FileRecordMgr *_inputFile;
     virtual ContextSpacing *upCast(ContextBase *context) { return static_cast<ContextSpacing *>(context); }
diff --git a/src/subtractFile/subtractFile.cpp b/src/subtractFile/subtractFile.cpp
index f763239..cd77cf7 100644
--- a/src/subtractFile/subtractFile.cpp
+++ b/src/subtractFile/subtractFile.cpp
@@ -59,7 +59,7 @@ void SubtractFile::subtractHits(RecordKeyVector &hits) {
 	}
 
 	//loop through hits. Track which bases in query were covered
-	const Record *keyRec = hits.getKey();
+	Record *keyRec = hits.getKey();
 	int keyStart = keyRec->getStartPos();
 	int keyEnd = keyRec->getEndPos();
 
@@ -71,8 +71,8 @@ void SubtractFile::subtractHits(RecordKeyVector &hits) {
 	//now loop through the hits, and cover corresponding query bases
 	//by setting them to false.
 	bool basesRemoved = false;
-	for (RecordKeyVector::const_iterator_type iter = hits.begin(); iter != hits.end(); iter = hits.next()) {
-		const Record *hitRec = *iter;
+	for (RecordKeyVector::iterator_type iter = hits.begin(); iter != hits.end(); iter = hits.next()) {
+		Record *hitRec = *iter;
 		int hitStart = hitRec->getStartPos();
 		int hitEnd = hitRec->getEndPos();
 
diff --git a/src/utils/BinTree/BinTree.cpp b/src/utils/BinTree/BinTree.cpp
index 18181e3..6f34d1d 100644
--- a/src/utils/BinTree/BinTree.cpp
+++ b/src/utils/BinTree/BinTree.cpp
@@ -49,7 +49,7 @@ void BinTree::getHits(Record *record, RecordKeyVector &hitSet)
 	if (record->isUnmapped()) {
 		return;
 	}
-    const QuickString &chr = record->getChrName();
+    const string &chr = record->getChrName();
 	mainMapType::iterator mainIter = _mainMap.find(chr);
 	if (mainIter == _mainMap.end()) {
 		//given chrom not even in map.
@@ -63,31 +63,31 @@ void BinTree::getHits(Record *record, RecordKeyVector &hitSet)
     binNumType endBin = ((endPos-1) >> _binFirstShift);
 
 
-	const allBinsType &bins = mainIter->second;
+	allBinsType &bins = mainIter->second;
 
     /* SYNOPSIS:
          1. We loop through each UCSC BIN level for feature A's chrom.
          2. For each BIN, we loop through each B feature and add it to
             hits if it meets all of the user's requests, which include:
-               (a) overlap fractio, (b) strandedness, (c) reciprocal overlap
+               (a) overlap fraction, (b) strandedness, (c) reciprocal overlap
     */
     for (binNumType i = 0; i < NUM_BIN_LEVELS; i++) {
         binNumType offset = _binOffsetsExtended[i];
         for (binNumType j = (startBin+offset); j <= (endBin+offset); j++)  {
 
         	// move to the next bin if this one is empty
-        	allBinsType::const_iterator allBinsIter = bins.find(j);
+        	allBinsType::iterator allBinsIter = bins.find(j);
         	if (allBinsIter == bins.end()) {
         		continue;
         	}
-        	const binType &bin = allBinsIter->second;
+        	binType &bin = allBinsIter->second;
 
-        	for (binType::const_iterator iter = bin.begin(); iter != bin.end(); iter++) {
-            	const Record *dbRec = *iter;
+        	for (binType::iterator iter = bin.begin(); iter != bin.end(); iter++) {
+            	Record *dbRec = *iter;
             	if (record->intersects(dbRec,
                                        _context->getSameStrand(),
                                        _context->getDiffStrand(),
-            			                     _context->getOverlapFractionA(),
+            			               _context->getOverlapFractionA(),
                                        _context->getOverlapFractionB(),
                                        _context->getReciprocalFraction(),
                                        _context->getEitherFraction()
@@ -106,10 +106,10 @@ void BinTree::getHits(Record *record, RecordKeyVector &hitSet)
 	}
 }
 
-bool BinTree::addRecordToTree(const Record *record)
+bool BinTree::addRecordToTree(Record *record)
 {
 	// Get chr, bin.
-	const QuickString &chr = record->getChrName();
+	const string &chr = record->getChrName();
 	binNumType startPos = (binNumType)(record->getStartPos());
 	binNumType endPos = (binNumType)(record->getEndPos());
 	binNumType binNum = getBin(startPos, endPos);
diff --git a/src/utils/BinTree/BinTree.h b/src/utils/BinTree/BinTree.h
index a688b92..e4c575f 100644
--- a/src/utils/BinTree/BinTree.h
+++ b/src/utils/BinTree/BinTree.h
@@ -13,7 +13,7 @@
 #include <set>
 #include <map>
 
-#include "QuickString.h"
+#include "string.h"
 #include "RecordKeyList.h"
 #include "ContextIntersect.h"
 
@@ -56,18 +56,18 @@ private:
 //	typedef const RecordListNode * innerListIterType;
 //	typedef innerListType * binType;
 //	typedef binType * allBinsType;
-//	typedef QuickString mainKeyType;
+//	typedef string mainKeyType;
 //	typedef map<mainKeyType, allBinsType> mainMapType;
 //	mainMapType _mainMap;
 
-	typedef vector<const Record *> binType;
+	typedef vector<Record *> binType;
 	typedef map<binNumType, binType> allBinsType; //for each bin number, have a RecordList
-	typedef map<QuickString, allBinsType> mainMapType; //for each chrom, a map of bin num to RecordLists.
+	typedef map<string, allBinsType> mainMapType; //for each chrom, a map of bin num to RecordLists.
 	mainMapType _mainMap;
 
 	map<binNumType, int> _binsHit;
 
-	bool addRecordToTree(const Record *);
+	bool addRecordToTree(Record *);
 	binNumType getBin(binNumType start, binNumType end) const;
 	binNumType getBin(const Record *record) const;
 
diff --git a/src/utils/Contexts/ContextBase.cpp b/src/utils/Contexts/ContextBase.cpp
index 21ea11f..3856851 100644
--- a/src/utils/Contexts/ContextBase.cpp
+++ b/src/utils/Contexts/ContextBase.cpp
@@ -13,6 +13,7 @@
 ContextBase::ContextBase()
 :
   _program(UNSPECIFIED_PROGRAM),
+  _files(NULL),
   _allFilesOpened(false),
   _genomeFile(NULL),
   _outputFileType(FileRecordTypeChecker::UNKNOWN_FILE_TYPE),
@@ -45,7 +46,7 @@ ContextBase::ContextBase()
   _reportDBfileNames(false),
   _printHeader(false),
   _printable(true),
-   _explicitBedOutput(false),
+  _explicitBedOutput(false),
   _queryFileIdx(-1),
   _bamHeaderAndRefIdx(-1),
   _maxNumDatabaseFields(0),
@@ -95,7 +96,6 @@ ContextBase::~ContextBase()
 {
 	delete _genomeFile;
 	_genomeFile = NULL;
-
 	delete _splitBlockInfo;
 	_splitBlockInfo = NULL;
 
@@ -103,7 +103,6 @@ ContextBase::~ContextBase()
 		cerr << _nameConventionWarningMsg << endl;
 	}
 
-
 	//close all files and delete FRM objects.
 	for (int i=0; i < (int)_files.size(); i++) {
 		_files[i]->close();
@@ -149,7 +148,7 @@ bool ContextBase::determineOutputType() {
 
 }
 
-void ContextBase::openGenomeFile(const QuickString &genomeFilename)
+void ContextBase::openGenomeFile(const string &genomeFilename)
 {
 	_genomeFile = new NewGenomeFile(genomeFilename.c_str());
 }
@@ -619,14 +618,14 @@ void ContextBase::setColumnOpsMethods(bool val)
 	_hasColumnOpsMethods = val;
 }
 
-const QuickString &ContextBase::getColumnOpsVal(RecordKeyVector &keyList) const {
+const string &ContextBase::getColumnOpsVal(RecordKeyVector &keyList) const {
 	if (!hasColumnOpsMethods()) {
 		return _nullStr;
 	}
 	return _keyListOps->getOpVals(keyList);
 }
 
-FileRecordMgr *ContextBase::getNewFRM(const QuickString &filename, int fileIdx) {
+FileRecordMgr *ContextBase::getNewFRM(const string &filename, int fileIdx) {
 
 	if (_useMergedIntervals) {
 		FileRecordMergeMgr *frm = new FileRecordMergeMgr(filename);
@@ -641,7 +640,7 @@ FileRecordMgr *ContextBase::getNewFRM(const QuickString &filename, int fileIdx)
 	}
 }
 
-bool ContextBase::parseIoBufSize(QuickString bufStr)
+bool ContextBase::parseIoBufSize(string bufStr)
 {
 	char lastChar = bufStr[bufStr.size()-1];
 	int multiplier = 1;
@@ -741,20 +740,20 @@ ContextBase::testType ContextBase::fileHasLeadingZeroInChromNames(int fileIdx) {
 
 
 
-void ContextBase::warn(const Record *record, const QuickString str1, const QuickString str2, const QuickString str3) {
-	QuickString msg;
+void ContextBase::warn(const Record *record, const string str1, const string str2, const string str3) {
+	string msg;
 	setErrorMsg(msg, true, record, str1, str2, str3);
 	cerr << msg << endl;
 }
 
-void ContextBase::die(const Record *record, const QuickString str1, const QuickString str2, const QuickString str3) {
-	QuickString msg;
+void ContextBase::die(const Record *record, const string str1, const string str2, const string str3) {
+	string msg;
 	setErrorMsg(msg, false, record, str1, str2, str3);
 	cerr << msg << endl;
 	exit(1);
 }
 
-void ContextBase::setErrorMsg(QuickString &msg, bool onlyWarn, const Record * record, QuickString str1, const QuickString str2, const QuickString str3) {
+void ContextBase::setErrorMsg(string &msg, bool onlyWarn, const Record * record, string str1, const string str2, const string str3) {
 	if (onlyWarn) {
 		msg = "\n***** WARNING: ";
 	} else {
@@ -769,7 +768,7 @@ void ContextBase::setErrorMsg(QuickString &msg, bool onlyWarn, const Record * re
 	}
 }
 
-void ContextBase::nameConventionWarning(const Record *record, const QuickString &filename, const QuickString &message)
+void ContextBase::nameConventionWarning(const Record *record, const string &filename, const string &message)
 {
 	 _nameConventionWarningMsg = "***** WARNING: File ";
 	 _nameConventionWarningMsg.append(filename);
diff --git a/src/utils/Contexts/ContextBase.h b/src/utils/Contexts/ContextBase.h
index 0cea2e9..6bac10f 100644
--- a/src/utils/Contexts/ContextBase.h
+++ b/src/utils/Contexts/ContextBase.h
@@ -44,16 +44,16 @@ public:
 	FileRecordMgr *getFile(int fileIdx) { return _files[fileIdx]; }
 	void setProgram(PROGRAM_TYPE program) { _program = program; }
 
-	void addInputFile(const QuickString &inputFile) { _fileNames.push_back(inputFile); }
+	void addInputFile(const string &inputFile) { _fileNames.push_back(inputFile); }
 
 	int getNumInputFiles() const { return _fileNames.size(); }
-	const QuickString &getInputFileName(int fileNum) const { return _fileNames[fileNum]; }
+	const string &getInputFileName(int fileNum) const { return _fileNames[fileNum]; }
 	ContextFileType getInputFileType(int fileNum) const { return _files[fileNum]->getFileType(); }
 	ContextRecordType getInputRecordType(int fileNum) const { return _files[fileNum]->getRecordType(); }
 
 	virtual bool determineOutputType();
 
-	const QuickString &getHeader(int fileIdx) { return _files[fileIdx]->getHeader(); }
+	const string &getHeader(int fileIdx) { return _files[fileIdx]->getHeader(); }
 	const BamTools::RefVector &getBamReferences(int fileIdx)  { return _files[fileIdx]->getBamReferences(); }
 	int getBamHeaderAndRefIdx(); //return idx of 1st query that is BAM. If none, first DB that is BAM.
 
@@ -61,7 +61,7 @@ public:
 	void setUseMergedIntervals(bool val) { _useMergedIntervals = val; }
 	FileRecordMergeMgr::WANTED_STRAND_TYPE getDesiredStrand() const { return _desiredStrand; }
 
-	void openGenomeFile(const QuickString &genomeFilename);
+	void openGenomeFile(const string &genomeFilename);
 	void openGenomeFile(const BamTools::RefVector &refVector);
 	bool hasGenomeFile() const { return _genomeFile != NULL; }
 	NewGenomeFile *getGenomeFile() const { return _genomeFile; }
@@ -78,8 +78,8 @@ public:
 	bool getShowHelp() const { return _showHelp; }
 	void setShowHelp(bool val) { _showHelp = val; }
 
-	const QuickString &getErrorMsg() const { return _errorMsg; }
-	void setErrorMessage(const QuickString &errorMsg) { _errorMsg = errorMsg; }
+	const string &getErrorMsg() const { return _errorMsg; }
+	void setErrorMessage(const string &errorMsg) { _errorMsg = errorMsg; }
 
 	//split handling.
 	bool getObeySplits() const {return _obeySplits; }
@@ -144,7 +144,7 @@ public:
     // are available.
     void setColumnOpsMethods(bool val);
     virtual bool hasColumnOpsMethods() const { return _hasColumnOpsMethods; }
-    const QuickString &getColumnOpsVal(RecordKeyVector &keyList) const;
+    const string &getColumnOpsVal(RecordKeyVector &keyList) const;
     //methods applicable only to column operations.
     int getReportPrecision() const { return _reportPrecision; }
 
@@ -155,21 +155,21 @@ public:
 protected:
 	PROGRAM_TYPE _program;
 
-	vector<QuickString> _fileNames;
+	vector<string> _fileNames;
 	vector<FileRecordMgr *> _files;
 	bool _allFilesOpened;
-	map<QuickString, PROGRAM_TYPE> _programNames;
-	QuickString _origProgramName;
+	map<string, PROGRAM_TYPE> _programNames;
+	string _origProgramName;
 
 	NewGenomeFile *_genomeFile;
 
 	ContextFileType _outputFileType;
 	bool _outputTypeDetermined;
 
-	map<int, QuickString> _headers;
+	map<int, string> _headers;
 	map<int, BamTools::RefVector> _references;
 
-	QuickString _errorMsg;
+	string _errorMsg;
 	vector<bool> _argsProcessed; //used for processing cmdLine args.
 	int _skipFirstArgs;
 	bool _showHelp;
@@ -204,7 +204,7 @@ protected:
     bool _runToQueryEnd;
     int _queryFileIdx;
     vector<int> _dbFileIdxs;
-    vector<QuickString> _dbNameTags;
+    vector<string> _dbNameTags;
     map<int, int> _fileIdsToDbIdxs;
     int _bamHeaderAndRefIdx;
     int _maxNumDatabaseFields;
@@ -221,7 +221,7 @@ protected:
 	//Members for column operations
 	bool _hasColumnOpsMethods;
 	KeyListOps *_keyListOps;
-	QuickString _nullStr; //placeholder return value when col ops aren't valid.
+	string _nullStr; //placeholder return value when col ops aren't valid.
 
 	//Members for merged records
 	FileRecordMergeMgr::WANTED_STRAND_TYPE _desiredStrand;
@@ -236,7 +236,7 @@ protected:
 	virtual bool parseCmdArgs(int argc, char **argv, int skipFirstArgs);
 	bool cmdArgsValid();
 	virtual bool openFiles();
-	virtual FileRecordMgr *getNewFRM(const QuickString &filename, int fileIdx);
+	virtual FileRecordMgr *getNewFRM(const string &filename, int fileIdx);
 
 	//set cmd line params and counter, i, as members so code
 	//is more readable (as opposed to passing all 3 everywhere).
@@ -285,7 +285,7 @@ protected:
 	virtual bool handle_sortout();
 	virtual bool handle_nonamecheck();
 	bool handle_prec();
-	bool parseIoBufSize(QuickString bufStr);
+	bool parseIoBufSize(string bufStr);
 
     testType fileHasChrInChromNames(int fileIdx);
     testType fileHasLeadingZeroInChromNames(int fileIdx);
@@ -293,16 +293,16 @@ protected:
     void setNoEnforceCoordSort(bool val) { _noEnforceCoordSort = val; }
     //Warning messages.
    bool _nameConventionWarningTripped;
-   QuickString _nameConventionWarningMsg;
-   void nameConventionWarning(const Record *record, const QuickString &filename, const QuickString &message);
+   string _nameConventionWarningMsg;
+   void nameConventionWarning(const Record *record, const string &filename, const string &message);
 
     //give warning but continue.
-    void warn(const Record *, const QuickString str1, const QuickString str2 = "", const QuickString str3 = "");
+    void warn(const Record *, const string str1, const string str2 = "", const string str3 = "");
     // Give error and exit.
-    void die(const Record *, const QuickString str1, const QuickString str2 = "", const QuickString str3 = "");
+    void die(const Record *, const string str1, const string str2 = "", const string str3 = "");
 
     //private error handler
-    void setErrorMsg(QuickString &msg, bool onlyWarn, const Record * record, QuickString str1, const QuickString str2, const QuickString str3);
+    void setErrorMsg(string &msg, bool onlyWarn, const Record * record, string str1, const string str2, const string str3);
 
     bool strandedToolSupported();
 
diff --git a/src/utils/Contexts/ContextClosest.cpp b/src/utils/Contexts/ContextClosest.cpp
index 2e774b3..4b8e60e 100644
--- a/src/utils/Contexts/ContextClosest.cpp
+++ b/src/utils/Contexts/ContextClosest.cpp
@@ -139,7 +139,7 @@ bool ContextClosest::handle_D() {
         _reportDistance = true;
         _signDistance = true;
         _haveStrandedDistMode = true;
-        QuickString modeStr(_argv[_i + 1]);
+        string modeStr(_argv[_i + 1]);
         if (modeStr == "ref") {
         	_strandedDistMode = REF_DIST;
         } else if (modeStr == "a") {
@@ -203,7 +203,7 @@ bool ContextClosest::handle_t()
 	bool tieError = false;
     if ((_i+1) < _argc) {
         _haveTieMode = true;
-        QuickString tieStr(_argv[_i+1]);
+        string tieStr(_argv[_i+1]);
         if (tieStr == "all") {
         	_tieMode = ALL_TIES;
         } else if (tieStr == "first") {
@@ -230,7 +230,7 @@ bool ContextClosest::handle_mdb()
 {
 	bool mdbError = false;
     if ((_i+1) < _argc) {
-        QuickString mdbStr(_argv[_i+1]);
+        string mdbStr(_argv[_i+1]);
         if (mdbStr == "each") {
         	_multiDbMode = EACH_DB;
         } else if (mdbStr == "all") {
diff --git a/src/utils/Contexts/ContextGroupBy.cpp b/src/utils/Contexts/ContextGroupBy.cpp
index 990e696..ebee7bb 100644
--- a/src/utils/Contexts/ContextGroupBy.cpp
+++ b/src/utils/Contexts/ContextGroupBy.cpp
@@ -122,16 +122,18 @@ bool ContextGroupBy::handle_ignorecase() {
 	return true;
 }
 
-const QuickString &ContextGroupBy::getDefaultHeader() {
+const string &ContextGroupBy::getDefaultHeader() {
 	//groupBy does not support multiple databases.
 	FileRecordMgr *frm = _files[0];
 	int numFields = frm->getNumFields();
 	_defaultHeader.clear();
+	ostringstream s;
 	for (int i=1; i <= numFields; i++) {
-		_defaultHeader.append("col_");
-		_defaultHeader.append(i);
-		_defaultHeader.append('\t');
+		s << "col_";
+		s << i;
+		s << "\t";
 	}
+	_defaultHeader.append(s.str());
 	//change last tab into newline
 	_defaultHeader[_defaultHeader.size()-1] = '\n';
 	return _defaultHeader;
diff --git a/src/utils/Contexts/ContextGroupBy.h b/src/utils/Contexts/ContextGroupBy.h
index 0e6b2d9..c189850 100644
--- a/src/utils/Contexts/ContextGroupBy.h
+++ b/src/utils/Contexts/ContextGroupBy.h
@@ -18,13 +18,13 @@ public:
 	virtual bool isValidState();
 
 	bool printFullCols() const { return _printFullCols; }
-	const QuickString &getGroupCols() const { return _groupStr; }
+	const string &getGroupCols() const { return _groupStr; }
 	bool ignoreCase() const { return _ignoreCase; }
-	const QuickString &getDefaultHeader();
+	const string &getDefaultHeader();
 
 protected:
-	QuickString _groupStr;
-	QuickString _defaultHeader;
+	string _groupStr;
+	string _defaultHeader;
 	bool _printFullCols;
 	bool _ignoreCase;
 
diff --git a/src/utils/Contexts/ContextIntersect.h b/src/utils/Contexts/ContextIntersect.h
index ef2c3e0..0bf575d 100644
--- a/src/utils/Contexts/ContextIntersect.h
+++ b/src/utils/Contexts/ContextIntersect.h
@@ -27,8 +27,8 @@ public:
 	void setQueryFileIdx(int idx) { _queryFileIdx = idx; }
 	int getNumDatabaseFiles() { return (int)_dbFileIdxs.size(); }
 	const vector<int> &getDbFileIdxs() const { return _dbFileIdxs; }
-	const QuickString &getQueryFileName() const { return _files[_queryFileIdx]->getFileName(); }
-	const QuickString &getDatabaseFileName(int idx) const { return _files[_dbFileIdxs[idx]]->getFileName(); }
+	const string &getQueryFileName() const { return _files[_queryFileIdx]->getFileName(); }
+	const string &getDatabaseFileName(int idx) const { return _files[_dbFileIdxs[idx]]->getFileName(); }
 	ContextFileType getQueryFileType() const { return _files[_queryFileIdx]->getFileType(); }
 	ContextFileType getDatabaseFileType(int idx) const { return _files[_dbFileIdxs[idx]]->getFileType(); }
 	ContextRecordType getQueryRecordType() const { return _files[_queryFileIdx]->getRecordType(); }
@@ -36,8 +36,8 @@ public:
 	int getMaxNumDatabaseFields() const { return _maxNumDatabaseFields; }
 	void setMaxNumDatabaseFields(int val) { _maxNumDatabaseFields = val; }
 	int getDbIdx(int fileId) { return _fileIdsToDbIdxs.find(fileId)->second; }
-	void addDatabaseNameTag(const QuickString &tag) { _dbNameTags.push_back(tag); }
-	const QuickString &getDatabaseNameTag(int dbIdx) const { return _dbNameTags[dbIdx]; }
+	void addDatabaseNameTag(const string &tag) { _dbNameTags.push_back(tag); }
+	const string &getDatabaseNameTag(int dbIdx) const { return _dbNameTags[dbIdx]; }
 
 	bool getAnyHit() const {return _anyHit; }
 	void setAnyHit(bool val) { _anyHit = val; }
diff --git a/src/utils/Contexts/Makefile b/src/utils/Contexts/Makefile
index 0f499ee..40aeec8 100644
--- a/src/utils/Contexts/Makefile
+++ b/src/utils/Contexts/Makefile
@@ -26,7 +26,7 @@ SOURCES= ContextBase.cpp ContextBase.h ContextIntersect.cpp ContextIntersect.h C
 	ContextGroupBy.cpp ContextGroupBy.cpp
 OBJECTS= ContextBase.o ContextIntersect.o ContextFisher.o ContextMap.o ContextSample.o ContextSpacing.o ContextMerge.o ContextJaccard.o ContextClosest.o \
 	ContextSubtract.o ContextCoverage.o ContextComplement.o ContextGroupBy.o
-_EXT_OBJECTS=ParseTools.o QuickString.o
+_EXT_OBJECTS=ParseTools.o string.o
 EXT_OBJECTS=$(patsubst %,$(OBJ_DIR)/%,$(_EXT_OBJECTS))
 BUILT_OBJECTS= $(patsubst %,$(OBJ_DIR)/%,$(OBJECTS))
 
diff --git a/src/utils/FileRecordTools/FileReaders/BamFileReader.cpp b/src/utils/FileRecordTools/FileReaders/BamFileReader.cpp
index f2344f0..1a2979f 100644
--- a/src/utils/FileRecordTools/FileReaders/BamFileReader.cpp
+++ b/src/utils/FileRecordTools/FileReaders/BamFileReader.cpp
@@ -47,7 +47,7 @@ bool BamFileReader::readEntry()
 	return false;
 }
 
-void BamFileReader::getChrName(QuickString &str) const
+void BamFileReader::getChrName(string &str) const
 {
 	int refId = _bamAlignment.RefID;
 	if (refId < 0) {
@@ -71,7 +71,7 @@ int BamFileReader::getEndPos() const
 	return _bamAlignment.GetEndPosition(false, false);
 }
 
-void BamFileReader::getName(QuickString &str) const
+void BamFileReader::getName(string &str) const
 {
 	if (!_useTags) {
 		str = _bamAlignment.SupportData.AllCharData.c_str();
@@ -86,7 +86,7 @@ void BamFileReader::getName(QuickString &str) const
     }
 }
 
-void BamFileReader::getScore(QuickString &str) const
+void BamFileReader::getScore(string &str) const
 {
 	int2str(_bamAlignment.MapQuality, str);
 }
@@ -99,7 +99,7 @@ char BamFileReader::getStrand() const
 	return '+';
 }
 
-void BamFileReader::getMateChrName(QuickString &str) const
+void BamFileReader::getMateChrName(string &str) const
 {
 	int refId = _bamAlignment.MateRefID;
 	if (refId < 0) {
diff --git a/src/utils/FileRecordTools/FileReaders/BamFileReader.h b/src/utils/FileRecordTools/FileReaders/BamFileReader.h
index c158a08..203bef0 100644
--- a/src/utils/FileRecordTools/FileReaders/BamFileReader.h
+++ b/src/utils/FileRecordTools/FileReaders/BamFileReader.h
@@ -9,7 +9,7 @@
 #define BAMFILEREADER_H_
 
 #include "FileReader.h"
-#include "QuickString.h"
+#include "string.h"
 #include "api/BamReader.h"
 #include "api/BamAux.h"
 
@@ -33,20 +33,20 @@ public:
 	virtual bool readEntry();
 
 	virtual bool hasHeader() const { return _bamReader->IsOpen(); } //any open Bam file automatically has a header
-	virtual const QuickString &getHeader() const { return _bamHeader; }
+	virtual const string &getHeader() const { return _bamHeader; }
 	const BamTools::RefVector &getReferences() const { return _references; }
 
 	const BamTools::BamAlignment &getAlignment() const { return _bamAlignment; }
 
 
-	void getChrName(QuickString &) const;
+	void getChrName(string &) const;
 	int getBamChrId() const;
 	int getStartPos() const;
 	int getEndPos() const;
-	void getName(QuickString &) const;
-	void getScore(QuickString &) const;
+	void getName(string &) const;
+	void getScore(string &) const;
 	char getStrand() const;
-	void getMateChrName(QuickString &str) const;
+	void getMateChrName(string &str) const;
 	virtual int getNumFields() const { return MINIMUM_VALID_BAM_FIELDS; }
 
 protected:
@@ -54,7 +54,7 @@ protected:
 	BamTools::BamReader *_bamReader;
 	BamTools::BamAlignment _bamAlignment;
 	bool _eof;
-	QuickString _bamHeader;
+	string _bamHeader;
 	BamTools::RefVector _references;
 	bool _useTags;
 
diff --git a/src/utils/FileRecordTools/FileReaders/BufferedStreamMgr.cpp b/src/utils/FileRecordTools/FileReaders/BufferedStreamMgr.cpp
index 6a338ce..5dc3176 100644
--- a/src/utils/FileRecordTools/FileReaders/BufferedStreamMgr.cpp
+++ b/src/utils/FileRecordTools/FileReaders/BufferedStreamMgr.cpp
@@ -10,7 +10,7 @@
 #include "InputStreamMgr.h"
 #include <fstream>
 
-BufferedStreamMgr::BufferedStreamMgr(const QuickString &filename)
+BufferedStreamMgr::BufferedStreamMgr(const string &filename)
 : 	_inputStreamMgr(NULL),
 	_mainBuf(NULL),
    	_filename(filename),
@@ -92,7 +92,7 @@ bool BufferedStreamMgr::getTypeData()
 	return true;
 }
 
-bool BufferedStreamMgr::getLine(QuickString &line)
+bool BufferedStreamMgr::getLine(string &line)
 {
 	line.clear();
 
diff --git a/src/utils/FileRecordTools/FileReaders/BufferedStreamMgr.h b/src/utils/FileRecordTools/FileReaders/BufferedStreamMgr.h
index eb9f6bd..2d4382c 100644
--- a/src/utils/FileRecordTools/FileReaders/BufferedStreamMgr.h
+++ b/src/utils/FileRecordTools/FileReaders/BufferedStreamMgr.h
@@ -9,13 +9,13 @@
 #define BUFFEREDSTREAMMGR_H_
 
 #include <iostream>
-#include "QuickString.h"
+#include "string.h"
 #include "FileRecordTypeChecker.h"
 #include "InputStreamMgr.h"
 
 class BufferedStreamMgr {
 public:
-	BufferedStreamMgr(const QuickString &filename);
+	BufferedStreamMgr(const string &filename);
 	~BufferedStreamMgr();
 
 	bool init();
@@ -23,7 +23,7 @@ public:
 	FileRecordTypeChecker & getTypeChecker() { return _typeChecker; }
 
 	bool eof() const { return _eof; }
-	bool getLine(QuickString &line);
+	bool getLine(string &line);
 	BamTools::BamReader *getBamReader() { return _inputStreamMgr->getBamReader(); }
 	static const int DEFAULT_MAIN_BUF_READ_SIZE = 1023;
 	void setIoBufSize(int val) { _useBufSize = val; }
@@ -33,14 +33,14 @@ private:
 	bufType *_mainBuf;
 
 	FileRecordTypeChecker _typeChecker;
-	QuickString _filename;
+	string _filename;
 
 	int _mainBufCurrStartPos;
 	int _mainBufCurrLen;
 	bool _eof;
 	int _useBufSize;
 	bool _streamFinished;
-	QuickString _currScanBuffer;
+	string _currScanBuffer;
 
 	//The minus ones in these constants are for leaving room for a null terminator after reading into buffers.
 	static const int GZIP_LINE_BUF_SIZE = 8191; // 8K
diff --git a/src/utils/FileRecordTools/FileReaders/FileReader.h b/src/utils/FileRecordTools/FileReaders/FileReader.h
index 48b861a..d05f97b 100644
--- a/src/utils/FileRecordTools/FileReaders/FileReader.h
+++ b/src/utils/FileRecordTools/FileReaders/FileReader.h
@@ -4,7 +4,7 @@
 #include <string>
 #include <fstream>
 #include <map>
-#include "QuickString.h"
+#include "string.h"
 //#include "ContextBase.h"
 
 #include "BufferedStreamMgr.h"
@@ -31,7 +31,7 @@ public:
 	virtual bool readEntry() =0; // this is an abstract base class.
 	virtual int getCurrChromdId() const { return _currChromId; }
 	virtual bool hasHeader() const = 0;
-	virtual const QuickString &getHeader() const =0;
+	virtual const string &getHeader() const =0;
 	virtual int getNumFields() const = 0;
 protected:
 	int _fileIdx;
diff --git a/src/utils/FileRecordTools/FileReaders/InputStreamMgr.cpp b/src/utils/FileRecordTools/FileReaders/InputStreamMgr.cpp
index b147b1d..e9836da 100644
--- a/src/utils/FileRecordTools/FileReaders/InputStreamMgr.cpp
+++ b/src/utils/FileRecordTools/FileReaders/InputStreamMgr.cpp
@@ -12,7 +12,7 @@
 
 const char *InputStreamMgr::FIFO_STRING_LITERAL = "/dev/fd";
 
-InputStreamMgr::InputStreamMgr(const QuickString &filename, bool buildScanBuffer)
+InputStreamMgr::InputStreamMgr(const string &filename, bool buildScanBuffer)
 :
  _filename(filename),
  _pushBackStreamBuf(NULL),
@@ -110,8 +110,8 @@ int InputStreamMgr::read(char *data, size_t dataSize)
 			//This part is tricky. They want less data than we saved. Give them what they
 			//requested, then delete from the front of the saveDataStr by using it's substr method.
 			memcpy(data, _saveDataStr.c_str(), dataSize);
-			QuickString newDataStr;
-			_saveDataStr.substr(newDataStr, dataSize, _saveDataStr.size() - dataSize);
+			string newDataStr;
+			newDataStr = _saveDataStr.substr(dataSize, _saveDataStr.size() - dataSize);
 			_saveDataStr = newDataStr;
 			return dataSize;
 		}
@@ -162,12 +162,10 @@ bool InputStreamMgr::populateScanBuffer()
 		}
 	}
 	_numBytesInBuffer = _scanBuffer.size();
-
 	//append it to the savedDataStr.
-	_scanBuffer.toStr(_saveDataStr, true);
+ 	_scanBuffer.toStr(_saveDataStr, true);
 	if (_numBytesInBuffer == 0) return false;
 	return true;
-
 }
 
 bool InputStreamMgr::detectBamOrBgzip(int &numChars, int currChar)
diff --git a/src/utils/FileRecordTools/FileReaders/InputStreamMgr.h b/src/utils/FileRecordTools/FileReaders/InputStreamMgr.h
index 13942d3..be406b4 100644
--- a/src/utils/FileRecordTools/FileReaders/InputStreamMgr.h
+++ b/src/utils/FileRecordTools/FileReaders/InputStreamMgr.h
@@ -10,7 +10,7 @@
 
 #include "PushBackStreamBuf.h"
 #include "InflateStreamBuf.h"
-#include "QuickString.h"
+#include "string.h"
 #include "api/BamReader.h"
 #include "api/internal/io/BgzfStream_p.h"
 
@@ -21,7 +21,7 @@ using namespace std;
 class InputStreamMgr {
 public:
 	 //Contsructor: 1st arg can be "-" for stdin. set 2nd arg false if fileType already known.
-	InputStreamMgr(const QuickString &filename, bool buildScanBuffer = true);
+	InputStreamMgr(const string &filename, bool buildScanBuffer = true);
 	~InputStreamMgr();
 	bool init();
 	int read(char *data, size_t dataSize);
@@ -31,24 +31,24 @@ public:
 	const BTlist<int> &getScanBuffer() const { return _scanBuffer; }
 	int getBufferLength() const { return _numBytesInBuffer; }
 	bool populateScanBuffer();
-	const QuickString &getSavedData() const { return _saveDataStr; }
+	const string &getSavedData() const { return _saveDataStr; }
 	bool isGzipped() const { return _isGzipped; }
 	bool isBGzipped() const { return _isBgzipped; }
 	bool isBam() const { return _isBam; }
 
 	bool isCompressed() const { return _isGzipped || _isBgzipped || _isBam; }
 	PushBackStreamBuf *getPushBackStreamBuf() const {return _pushBackStreamBuf; }
-//	void getSavedData(QuickString &str) const { str = _saveDataStr; }
+//	void getSavedData(string &str) const { str = _saveDataStr; }
 	BamTools::BamReader *getBamReader() { return _bamReader; }
 	bool resetStream();
 	bool getEofHit() { return _eofHit; }
 
 private:
-	QuickString _filename;
+	string _filename;
 	PushBackStreamBuf *_pushBackStreamBuf;
 	ifstream *_inputFileStream;
 	BTlist<int> _scanBuffer;
-	QuickString _saveDataStr;
+	string _saveDataStr;
 	InflateStreamBuf *_infStreamBuf;
 	istream * _finalInputStream;
 	istream *_oldInputStream;
diff --git a/src/utils/FileRecordTools/FileReaders/Makefile b/src/utils/FileRecordTools/FileReaders/Makefile
index 2fcacb2..4bb5908 100644
--- a/src/utils/FileRecordTools/FileReaders/Makefile
+++ b/src/utils/FileRecordTools/FileReaders/Makefile
@@ -7,12 +7,12 @@ UTILITIES_DIR = ../../../utils/
 INCLUDES = -I$(UTILITIES_DIR)/BamTools/include/ \
 			-I$(UTILITIES_DIR)/BamTools/src/ \
 			-I$(UTILITIES_DIR)/fileType/ \
-			 -I$(UTILITIES_DIR)/Contexts/ \
+			-I$(UTILITIES_DIR)/Contexts/ \
 			-I$(UTILITIES_DIR)/GenomeFile/ \
 			-I$(UTILITIES_DIR)/general/ \
 			-I$(UTILITIES_DIR)/gzstream/ \
-           -I$(UTILITIES_DIR)/version/ \
-           -I$(UTILITIES_DIR)/lineFileUtilities/ \
+            -I$(UTILITIES_DIR)/version/ \
+            -I$(UTILITIES_DIR)/lineFileUtilities/ \
 			
 
 # ----------------------------------
@@ -22,7 +22,7 @@ SOURCES= FileReader.h FileReader.cpp  \
 		SingleLineDelimTextFileReader.h SingleLineDelimTextFileReader.cpp BamFileReader.h BamFileReader.cpp \
 		BufferedStreamMgr.h BufferedStreamMgr.cpp InputStreamMgr.h InputStreamMgr.cpp
 OBJECTS= FileReader.o SingleLineDelimTextFileReader.o BamFileReader.o BufferedStreamMgr.o InputStreamMgr.o 
-_EXT_OBJECTS=ParseTools.o QuickString.o CompressionTools.o
+_EXT_OBJECTS=string.o CompressionTools.o
 EXT_OBJECTS=$(patsubst %,$(OBJ_DIR)/%,$(_EXT_OBJECTS))
 BUILT_OBJECTS= $(patsubst %,$(OBJ_DIR)/%,$(OBJECTS))
 
diff --git a/src/utils/FileRecordTools/FileReaders/Makefile~ b/src/utils/FileRecordTools/FileReaders/Makefile~
index 556c7f5..0a9b111 100644
--- a/src/utils/FileRecordTools/FileReaders/Makefile~
+++ b/src/utils/FileRecordTools/FileReaders/Makefile~
@@ -21,7 +21,7 @@ SOURCES= FileReader.h FileReader.cpp SingleLineDelimTransferBuffer.h SingleLineD
 		SingleLineDelimTextFileReader.h SingleLineDelimTextFileReader.cpp BamFileReader.h BamFileReader.cpp \
 		BufferedStreamMgr.h BufferedStreamMgr.cpp InputStreamMgr.h InputStreamMgr.cpp
 OBJECTS= FileReader.o SingleLineDelimTransferBuffer.o SingleLineDelimTextFileReader.o BamFileReader.o BufferedStreamMgr.o InputStreamMgr.o 
-_EXT_OBJECTS=ParseTools.o QuickString.o CompressionTools.o
+_EXT_OBJECTS=ParseTools.o string.o CompressionTools.o
 EXT_OBJECTS=$(patsubst %,$(OBJ_DIR)/%,$(_EXT_OBJECTS))
 BUILT_OBJECTS= $(patsubst %,$(OBJ_DIR)/%,$(OBJECTS))
 
diff --git a/src/utils/FileRecordTools/FileReaders/SingleLineDelimTextFileReader.cpp b/src/utils/FileRecordTools/FileReaders/SingleLineDelimTextFileReader.cpp
index 09fd483..8b158c0 100644
--- a/src/utils/FileRecordTools/FileReaders/SingleLineDelimTextFileReader.cpp
+++ b/src/utils/FileRecordTools/FileReaders/SingleLineDelimTextFileReader.cpp
@@ -1,5 +1,6 @@
 #include "SingleLineDelimTextFileReader.h"
 #include <iostream>
+#include <limits.h>
 #include "BufferedStreamMgr.h"
 #include "ParseTools.h"
 
@@ -76,23 +77,24 @@ bool SingleLineDelimTextFileReader::readEntry()
 }
 
 
-void SingleLineDelimTextFileReader::getField(int fieldNum, QuickString &str) const {
+void SingleLineDelimTextFileReader::getField(int fieldNum, string &str) const {
 	int startPos = _delimPositions[fieldNum] +1;
 	int endPos = _delimPositions[fieldNum+1];
 	str.assign(_sLine.c_str() + startPos, endPos - startPos);
 }
 
 
-void SingleLineDelimTextFileReader::getField(int fieldNum, int &val) {
-	getField(fieldNum, _tempChrPosStr);
-	val = str2chrPos(_tempChrPosStr.c_str());
+void SingleLineDelimTextFileReader::getField(int fieldNum, int &val) const {
+	string temp;
+	getField(fieldNum, temp);
+	val = str2chrPos(temp.c_str());
 }
 
 void SingleLineDelimTextFileReader::getField(int fieldNum, char &val) const {
 	val = _sLine[_delimPositions[fieldNum] +1];
 }
 
-void SingleLineDelimTextFileReader::appendField(int fieldNum, QuickString &str) const {
+void SingleLineDelimTextFileReader::appendField(int fieldNum, string &str) const {
 	int startPos = _delimPositions[fieldNum] +1;
 	int endPos = _delimPositions[fieldNum+1];
 	str.append(_sLine.c_str() + startPos, endPos - startPos);
@@ -101,9 +103,9 @@ void SingleLineDelimTextFileReader::appendField(int fieldNum, QuickString &str)
 bool SingleLineDelimTextFileReader::detectAndHandleHeader()
 {
 	//not sure why the linker is giving me a hard time about
-	//passing a non-const QuickString to isHeaderLine, but
+	//passing a non-const string to isHeaderLine, but
 	//this const ref is a workaround.
-	const QuickString &sLine2 = _sLine;
+	const string &sLine2 = _sLine;
 	if (!isHeaderLine(sLine2) && (!(_inheader && _lineNum==1))) {
 		return false;
 	}
@@ -148,10 +150,10 @@ bool SingleLineDelimTextFileReader::findDelimiters() {
 
 int SingleLineDelimTextFileReader::getVcfSVlen() {
 	// tokenize the INFO field
-	QuickString info_str;
+	string info_str;
 	vector<string> infofields;
 	getField(VCF_TAG_FIELD, info_str);
-	Tokenize(info_str.str(), infofields, ';');
+	Tokenize(info_str, infofields, ';');
 
 	// FOO=BAR;BIZ=BAM;SVLEN=100;END=200
 	for (vector<string>::iterator f = infofields.begin(); f != infofields.end(); ++f) {
@@ -177,7 +179,7 @@ int SingleLineDelimTextFileReader::getVcfSVlen() {
         		}
         	}
         	else if (keytoval.at(0) == "END") {
-        		QuickString start_str;
+        		string start_str;
         		getField(1, start_str);
         		// length is END - POS + 1
         		return str2chrPos(keytoval.at(1)) - str2chrPos(start_str) + 1;
diff --git a/src/utils/FileRecordTools/FileReaders/SingleLineDelimTextFileReader.h b/src/utils/FileRecordTools/FileReaders/SingleLineDelimTextFileReader.h
index 6b55772..d404664 100644
--- a/src/utils/FileRecordTools/FileReaders/SingleLineDelimTextFileReader.h
+++ b/src/utils/FileRecordTools/FileReaders/SingleLineDelimTextFileReader.h
@@ -10,7 +10,7 @@
 
 #include <algorithm>
 #include "FileReader.h"
-#include "QuickString.h"
+#include "string.h"
 #include "lineFileUtilities.h"
 
 class SingleLineDelimTextFileReader : public FileReader {
@@ -24,24 +24,24 @@ public:
 
 	virtual bool readEntry();
 	virtual int getNumFields() const { return _numFields; }
-	virtual void getField(int numField, QuickString &val) const;
-	virtual void getField(int numField, int &val); //this signaiture isn't const because it operates on an internal QuickString for speed.
+	virtual void getField(int numField, string &val) const;
+	virtual void getField(int numField, int &val) const; //this signaiture isn't const because it operates on an internal string for speed.
 	virtual void getField(int fieldNum, char &val) const;
-	virtual void appendField(int fieldNum, QuickString &str) const;
-	virtual const QuickString &getHeader() const { return _header; }
+	virtual void appendField(int fieldNum, string &str) const;
+	virtual const string &getHeader() const { return _header; }
 	virtual bool hasHeader() const { return _fullHeaderFound; }
 	virtual void setInHeader(bool val) { _inheader = val; }
 
 protected:
 	int _numFields;
 	char _delimChar;
-	QuickString _header;
+	string _header;
 	bool _fullHeaderFound;
 	int _currDataPos;
-	QuickString _sLine;
+	string _sLine;
 	int *_delimPositions;
-	QuickString _currChromStr;
-	QuickString _tempChrPosStr;
+	string _currChromStr;
+	string _tempChrPosStr;
 	int _lineNum;
 	bool _inheader;
 	bool detectAndHandleHeader();
diff --git a/src/utils/FileRecordTools/FileRecordMergeMgr.cpp b/src/utils/FileRecordTools/FileRecordMergeMgr.cpp
index 40e42b3..9654009 100644
--- a/src/utils/FileRecordTools/FileRecordMergeMgr.cpp
+++ b/src/utils/FileRecordTools/FileRecordMergeMgr.cpp
@@ -8,7 +8,7 @@
 
 #include "FileRecordMergeMgr.h"
 
-FileRecordMergeMgr::FileRecordMergeMgr(const QuickString & filename)
+FileRecordMergeMgr::FileRecordMergeMgr(const string & filename)
 : FileRecordMgr(filename),
   _desiredStrand(ANY_STRAND),
   _maxDistance(0)
@@ -64,7 +64,7 @@ Record *FileRecordMergeMgr::getNextRecord(RecordKeyVector *recList)
 	_mustBeReverse = _desiredStrand == SAME_STRAND_REVERSE || (_desiredStrand == SAME_STRAND_EITHER && (startRecord->getStrandVal() == Record::REVERSE));
 	bool mustKeepOpposite = (_desiredStrand == SAME_STRAND_EITHER);
 
-	const QuickString &currChrom = startRecord->getChrName();
+	const string &currChrom = startRecord->getChrName();
 	_foundChroms.insert(currChrom);
 
 	bool madeComposite = false;
@@ -97,7 +97,7 @@ Record *FileRecordMergeMgr::getNextRecord(RecordKeyVector *recList)
 		bool mustDelete = (mustMatchStrand && nextRecord->getStrandVal() == Record::UNKNOWN);
 
 		//check that we are still on the same chromosome.
-		const QuickString &newChrom = nextRecord->getChrName();
+		const string &newChrom = nextRecord->getChrName();
 		if (newChrom != currChrom) { //hit a different chromosome.
 			//haven't seen this chromosome before, sort order is already enforced in the base class method.
 			if (!mustDelete) {
@@ -205,7 +205,7 @@ bool FileRecordMergeMgr::eof(){
 
 void FileRecordMergeMgr::deleteAllMergedItemsButKey(RecordKeyVector &recList) {
 	//if the key is also in the list, this method won't delete it.
-	for (RecordKeyVector::const_iterator_type iter = recList.begin(); iter != recList.end(); iter = recList.next()) {
+	for (RecordKeyVector::iterator_type iter = recList.begin(); iter != recList.end(); iter = recList.next()) {
 		if (*iter == recList.getKey()) {
 			continue;
 		}
diff --git a/src/utils/FileRecordTools/FileRecordMergeMgr.h b/src/utils/FileRecordTools/FileRecordMergeMgr.h
index ce6cfcf..cd64b7d 100644
--- a/src/utils/FileRecordTools/FileRecordMergeMgr.h
+++ b/src/utils/FileRecordTools/FileRecordMergeMgr.h
@@ -14,7 +14,7 @@
 class FileRecordMergeMgr : public FileRecordMgr {
 
 public:
-	FileRecordMergeMgr(const QuickString & filename);
+	FileRecordMergeMgr(const string & filename);
 
 	//////////////////////////////////////////////////////////////////////////////////
 	//
diff --git a/src/utils/FileRecordTools/FileRecordMgr.cpp b/src/utils/FileRecordTools/FileRecordMgr.cpp
index 59dd433..e8bfbd9 100644
--- a/src/utils/FileRecordTools/FileRecordMgr.cpp
+++ b/src/utils/FileRecordTools/FileRecordMgr.cpp
@@ -4,7 +4,7 @@
 #include "Record.h"
 #include "NewGenomeFile.h"
 
-FileRecordMgr::FileRecordMgr(const QuickString &filename)
+FileRecordMgr::FileRecordMgr(const string &filename)
 : _fileIdx(-1),
   _filename(filename),
   _bufStreamMgr(NULL),
@@ -31,16 +31,10 @@ FileRecordMgr::FileRecordMgr(const QuickString &filename)
  {
 }
 
-FileRecordMgr::~FileRecordMgr(){
-
-	delete _bufStreamMgr;
-	_bufStreamMgr = NULL;
-
-	close(); //just make sure file was closed.
-	delete _fileReader;
-	_fileReader = NULL;
-
-	delete _recordMgr;
+FileRecordMgr::~FileRecordMgr()
+{
+	close(); 
+	//delete _recordMgr;
 	_recordMgr = NULL;
 }
 
@@ -137,11 +131,12 @@ Record *FileRecordMgr::getNextRecord(RecordKeyVector *keyList)
 	if (keyList != NULL) {
 		keyList->setKey(record);
 	}
+	record->setFileRecordManager(this);
 	return record;
 }
 
 void FileRecordMgr::assignChromId(Record *record) {
-	const QuickString &currChrom = record->getChrName();
+	const string &currChrom = record->getChrName();
 	if (currChrom != _prevChrom  && _hasGenomeFile) {
 		_prevChromId = _genomeFile->getChromId(currChrom);
 		record->setChromId(_prevChromId);
@@ -160,7 +155,7 @@ void FileRecordMgr::testInputSortOrder(Record *record)
 	}
 
 
-	const QuickString &currChrom = record->getChrName();
+	const string &currChrom = record->getChrName();
 	int currStart = record->getStartPos();
 	if (record->isZeroLength()) {
 		currStart++;
diff --git a/src/utils/FileRecordTools/FileRecordMgr.h b/src/utils/FileRecordTools/FileRecordMgr.h
index 872f0d1..0a38722 100644
--- a/src/utils/FileRecordTools/FileRecordMgr.h
+++ b/src/utils/FileRecordTools/FileRecordMgr.h
@@ -9,7 +9,7 @@
 #define FILERECORDMGR_H_
 
 #include <string>
-#include "QuickString.h"
+#include "string.h"
 #include <set>
 //#include "DualQueue.h"
 
@@ -32,7 +32,7 @@ class NewGenomeFile;
 
 class FileRecordMgr {
 public:
-	FileRecordMgr(const QuickString & filename);
+	FileRecordMgr(const string & filename);
 	virtual ~FileRecordMgr();
 	bool open(bool inheader=false);
 	void close();
@@ -51,9 +51,9 @@ public:
 
 
 
-	const QuickString &getFileName() const { return _filename;}
+	const string &getFileName() const { return _filename;}
 	bool hasHeader() const { return _fileReader->hasHeader(); }
-	const QuickString &getHeader() const { return _fileReader->getHeader(); }
+	const string &getHeader() const { return _fileReader->getHeader(); }
 
 	bool recordsHaveName() const {
 		return _bufStreamMgr->getTypeChecker().recordTypeHasName(_recordType);
@@ -111,7 +111,7 @@ public:
 
 protected:
 	int _fileIdx;
-	QuickString _filename;
+	string _filename;
 	BufferedStreamMgr *_bufStreamMgr;
 
 	FileReader *_fileReader;
@@ -123,8 +123,8 @@ protected:
 	bool _useFullBamTags;
 
 	//members for enforcing sorted order.
-	set<QuickString> _foundChroms;
-	QuickString _prevChrom;
+	set<string> _foundChroms;
+	string _prevChrom;
 	int _prevStart;
 	int _prevChromId;
 
diff --git a/src/utils/FileRecordTools/Makefile b/src/utils/FileRecordTools/Makefile
index d152c38..1b88d1e 100644
--- a/src/utils/FileRecordTools/Makefile
+++ b/src/utils/FileRecordTools/Makefile
@@ -5,14 +5,14 @@ UTILITIES_DIR = ../../utils/
 # define our includes
 # -------------------
 INCLUDES = -I$(UTILITIES_DIR)/fileType/ \
-			-I$(UTILITIES_DIR)/FileRecordTools/FileReaders/ \
-           -I$(UTILITIES_DIR)/FileRecordTools/Records/ \
-           -I$(UTILITIES_DIR)/GenomeFile/ \
-           -I$(UTILITIES_DIR)/general/ \
-			-I$(UTILITIES_DIR)/lineFileUtilities/ \
- 			-I$(UTILITIES_DIR)/BamTools/include \
-			-I$(UTILITIES_DIR)/BamTools/src/ \
-           -I$(UTILITIES_DIR)/version/
+	-I$(UTILITIES_DIR)/FileRecordTools/FileReaders/ \
+	-I$(UTILITIES_DIR)/FileRecordTools/Records/ \
+	-I$(UTILITIES_DIR)/GenomeFile/ \
+	-I$(UTILITIES_DIR)/general/ \
+	-I$(UTILITIES_DIR)/lineFileUtilities/ \
+	-I$(UTILITIES_DIR)/BamTools/include \
+	-I$(UTILITIES_DIR)/BamTools/src/ \
+	-I$(UTILITIES_DIR)/version/
 			
 
 SUBDIRS = ./FileReaders \
@@ -25,7 +25,7 @@ SUBDIRS = ./FileReaders \
 SOURCES= FileRecordMgr.cpp FileRecordMgr.h FileRecordMergeMgr.cpp FileRecordMergeMgr.h
 OBJECTS= FileRecordMgr.o FileRecordMergeMgr.o
 _EXT_OBJECTS=SingleLineDelimTextFileReader.o BamFileReader.o Bed3Interval.o Bed6Interval.o BedPlusInterval.o Bed12Interval.o BamRecord.o \
-	SingleLineDelimTransferBuffer.o FileRecordTypeChecker.o QuickString.o ParseTools.o RecordKeyList.o BufferedStreamMgr.o
+	SingleLineDelimTransferBuffer.o FileRecordTypeChecker.o string.o ParseTools.o RecordKeyList.o BufferedStreamMgr.o
 EXT_OBJECTS=$(patsubst %,$(OBJ_DIR)/%,$(_EXT_OBJECTS))
 BUILT_OBJECTS= $(patsubst %,$(OBJ_DIR)/%,$(OBJECTS))
 
diff --git a/src/utils/FileRecordTools/Records/BamRecord.cpp b/src/utils/FileRecordTools/Records/BamRecord.cpp
index deb032b..643cd44 100644
--- a/src/utils/FileRecordTools/Records/BamRecord.cpp
+++ b/src/utils/FileRecordTools/Records/BamRecord.cpp
@@ -1,3 +1,4 @@
+
 /*
  * BamRecord.cpp
  *
@@ -117,78 +118,82 @@ void BamRecord::clear()
 
 }
 
-void BamRecord::print(QuickString &outBuf, RecordKeyVector *keyList) const
+void BamRecord::print(string &outBuf, RecordKeyVector *keyList) const
 {
-        Bed6Interval::print(outBuf);
+	Bed6Interval::print(outBuf);
     printRemainingBamFields(outBuf, keyList);
 }
 
-void BamRecord::print(QuickString &outBuf, int start, int end, RecordKeyVector *keyList) const
+void BamRecord::print(string &outBuf, int start, int end, RecordKeyVector *keyList) const
 {
-        Bed6Interval::print(outBuf, start, end);
+	Bed6Interval::print(outBuf, start, end);
     printRemainingBamFields(outBuf, keyList);
 }
 
-void BamRecord::print(QuickString &outBuf, const QuickString & start, const QuickString & end, RecordKeyVector *keyList) const
+void BamRecord::print(string &outBuf, const string & start, const string & end, RecordKeyVector *keyList) const
 {
-        Bed6Interval::print(outBuf, start, end);
+	Bed6Interval::print(outBuf, start, end);
     printRemainingBamFields(outBuf, keyList);
 }
 
-void BamRecord::printNull(QuickString &outBuf) const
+void BamRecord::printNull(string &outBuf) const
 {
         Bed6Interval::printNull(outBuf);
         outBuf.append("\t.\t.\t.\t.\t.\t.", 12);
 }
 
-void BamRecord::printRemainingBamFields(QuickString &outBuf, RecordKeyVector *keyList) const
+void BamRecord::printRemainingBamFields(string &outBuf, RecordKeyVector *keyList) const
 {
-        outBuf.append('\t');
-        outBuf.append(_startPosStr);
-        outBuf.append('\t');
-        outBuf.append(_endPos);
-        outBuf.append("\t0,0,0", 6);
-        outBuf.append('\t');
-
-        int numBlocks = (int)keyList->size();
-
-        if (numBlocks > 0) {
-                outBuf.append(numBlocks);
-
-                vector<int> blockLengths;
-                vector<int> blockStarts;
-                for (RecordKeyVector::const_iterator_type iter = keyList->begin(); iter != keyList->end(); iter = keyList->next()) {
-                        const Record *block = *iter;
-                        blockLengths.push_back(block->getEndPos() - block->getStartPos());
-                        blockStarts.push_back(block->getStartPos() - _startPos);
-                }
-
-                outBuf.append('\t');
-                for (int i=0; i < (int)blockLengths.size(); i++) {
-                        outBuf.append(blockLengths[i]);
-                        outBuf.append(',');
-                }
-                outBuf.append('\t');
-                for (int i=0; i < (int)blockStarts.size(); i++) {
-                        outBuf.append( blockStarts[i]);
-                        outBuf.append(',');
-                }
-        }
-        else {
-                outBuf.append("1\t0,\t0,");
-        }
+	ostringstream s;
+    s << "\t";
+    s << _startPosStr;
+    s << "\t";
+    s << _endPos;
+    s << "\t0,0,0";
+    s << "\t";
+
+    int numBlocks = (int)keyList->size();
+
+    if (numBlocks > 0) {
+            s << numBlocks;
+
+            vector<int> blockLengths;
+            vector<int> blockStarts;
+            for (RecordKeyVector::iterator_type iter = keyList->begin(); iter != keyList->end(); iter = keyList->next()) {
+                    const Record *block = *iter;
+                    blockLengths.push_back(block->getEndPos() - block->getStartPos());
+                    blockStarts.push_back(block->getStartPos() - _startPos);
+            }
+
+            s << "\t";
+            for (int i=0; i < (int)blockLengths.size(); i++) {
+                    s << blockLengths[i];
+                    s << ',';
+            }
+            s << "\t";
+            for (int i=0; i < (int)blockStarts.size(); i++) {
+                    s <<  blockStarts[i];
+                    s << ',';
+            }
+    }
+    else {
+            s << "1\t0,\t0,";
+    }
+    outBuf.append(s.str());
 }
 
-void BamRecord::printUnmapped(QuickString &outBuf) const {
-        outBuf.append(_chrName.empty() ? "." : _chrName);
-        outBuf.append("\t-1\t-1\t");
-        outBuf.append(_name.empty() ? "." : _name);
-        outBuf.append('\t');
-        outBuf.append(_score.empty() ? "." : _score);
-        outBuf.append("\t.\t-1\t-1\t-1\t0,0,0\t0\t.\t."); // dot for strand, -1 for blockStarts and blockEnd
+void BamRecord::printUnmapped(string &outBuf) const {
+	ostringstream s;
+    s << (_chrName.empty() ? "." : _chrName);
+    s << "\t-1\t-1\t";
+    s << (_name.empty() ? "." : _name);
+    s << "\t";
+    s << (_score.empty() ? "." : _score);
+    s << "\t.\t-1\t-1\t-1\t0,0,0\t0\t.\t."; // dot for strand, -1 for blockStarts and blockEnd
+    outBuf.append(s.str());
 }
 
-const QuickString &BamRecord::getField(int fieldNum) const
+const string &BamRecord::getField(int fieldNum) const
 {
 	// Unlike other records, Bam records should return the fields specified in
 	// in the BAM spec. In order, they are:
@@ -265,10 +270,13 @@ void BamRecord::buildCigarStr() {
 	_cigarStr.clear();
 	_cigarStr.reserve(2 * cigarVecLen);
 
+	std::ostringstream tmp;
 	for (size_t i=0; i < cigarVecLen; i++) {
-		_cigarStr.append(cigarData[i].Type);
-		_cigarStr.append(cigarData[i].Length);
+		tmp << cigarData[i].Type;
+		tmp << cigarData[i].Length;
 	}
+	_cigarStr = tmp.str();
+
 }
 
 
diff --git a/src/utils/FileRecordTools/Records/BamRecord.h b/src/utils/FileRecordTools/Records/BamRecord.h
index eb80a2c..a9c1aab 100644
--- a/src/utils/FileRecordTools/Records/BamRecord.h
+++ b/src/utils/FileRecordTools/Records/BamRecord.h
@@ -10,7 +10,7 @@
 
 #include "Bed6Interval.h"
 #include "ParseTools.h"
-#include "QuickString.h"
+#include "string.h"
 #include "api/BamAlignment.h"
 
 class FileReader;
@@ -42,21 +42,21 @@ public:
 	using Bed6Interval::print;
 
 
-	virtual void print(QuickString &outBuf, int start, int end, RecordKeyVector *keyList) const;
-	virtual void print(QuickString &outBuf, RecordKeyVector *keyList) const;
-	virtual void print(QuickString &outBuf, const QuickString & start, const QuickString & end, RecordKeyVector *keyList) const;
-	virtual void printNull(QuickString &outBuf) const;
-	virtual void printRemainingBamFields(QuickString &outBuf, RecordKeyVector *keyList) const;
-	virtual void printUnmapped(QuickString &outBuf) const;
+	virtual void print(string &outBuf, int start, int end, RecordKeyVector *keyList) const;
+	virtual void print(string &outBuf, RecordKeyVector *keyList) const;
+	virtual void print(string &outBuf, const string & start, const string & end, RecordKeyVector *keyList) const;
+	virtual void printNull(string &outBuf) const;
+	virtual void printRemainingBamFields(string &outBuf, RecordKeyVector *keyList) const;
+	virtual void printUnmapped(string &outBuf) const;
 
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::BAM_RECORD_TYPE; }
-	const QuickString &getCigarStr() const { return _cigarStr; }
+	const string &getCigarStr() const { return _cigarStr; }
 	const vector<BamTools::CigarOp> &getCigarData() const { return _bamAlignment.CigarData; }
 
 	const BamTools::BamAlignment &getAlignment() const { return _bamAlignment; }
 	int getBamChromId() const { return _bamChromId; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual int getNumFields() const  { return 12; }
 	static bool isNumericField(int fieldNum);
 
@@ -67,12 +67,12 @@ protected:
 	int _bamChromId; //different from chromId, because BAM file may be in different order
 	//than the genomeFile.
 
-	QuickString _cigarStr; //stored for fast retrieval in column ops
-	QuickString _mateChrName;
-	QuickString _matePos;
-	QuickString _insertSize;
-	QuickString _queryBases;
-	QuickString _qualities;
+	string _cigarStr; //stored for fast retrieval in column ops
+	string _mateChrName;
+	string _matePos;
+	string _insertSize;
+	string _queryBases;
+	string _qualities;
 
 	virtual ~BamRecord();
 	void printRemainingBamFields();
diff --git a/src/utils/FileRecordTools/Records/Bed12Interval.cpp b/src/utils/FileRecordTools/Records/Bed12Interval.cpp
index 4f91aca..e41c64b 100644
--- a/src/utils/FileRecordTools/Records/Bed12Interval.cpp
+++ b/src/utils/FileRecordTools/Records/Bed12Interval.cpp
@@ -58,68 +58,68 @@ void Bed12Interval::clear() {
 
 }
 
-void Bed12Interval::print(QuickString &outBuf) const
+void Bed12Interval::print(string &outBuf) const
 {
 	Bed6Interval::print(outBuf);
 
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_thickStartStr);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_thickEndStr);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_itemRGB);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_blockCountStr);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_blockSizes);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_blockStarts);
 }
 
-void Bed12Interval::print(QuickString &outBuf, int start, int end) const
+void Bed12Interval::print(string &outBuf, int start, int end) const
 {
 	Bed6Interval::print(outBuf, start, end);
 
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_thickStartStr);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_thickEndStr);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_itemRGB);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_blockCountStr);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_blockSizes);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_blockStarts);
 }
 
-void Bed12Interval::print(QuickString &outBuf, const QuickString & start, const QuickString & end) const
+void Bed12Interval::print(string &outBuf, const string & start, const string & end) const
 {
 	Bed6Interval::print(outBuf, start, end);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_thickStartStr);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_thickEndStr);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_itemRGB);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_blockCountStr);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_blockSizes);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_blockStarts);
 }
 
 
-void Bed12Interval::printNull(QuickString &outBuf) const
+void Bed12Interval::printNull(string &outBuf) const
 {
 	Bed6Interval::printNull(outBuf);
 
 	outBuf.append("\t.\t.\t.\t.\t.\t.", 12);
 }
 
-const QuickString &Bed12Interval::getField(int fieldNum) const
+const string &Bed12Interval::getField(int fieldNum) const
 {
 	switch (fieldNum) {
 	case 7:
@@ -178,7 +178,7 @@ int Bed12Interval::getLength(bool obeySplits) const {
 		return _endPos - _startPos;
 	} else {
 		vector<int> vBlockSizes;
-		Tokenize(_blockSizes.str(), vBlockSizes, ',');
+		Tokenize(_blockSizes, vBlockSizes, ',');
 	    return accumulate(vBlockSizes.begin(), vBlockSizes.end(), 0);
 	}
 }
diff --git a/src/utils/FileRecordTools/Records/Bed12Interval.h b/src/utils/FileRecordTools/Records/Bed12Interval.h
index c1c97b7..5d90759 100644
--- a/src/utils/FileRecordTools/Records/Bed12Interval.h
+++ b/src/utils/FileRecordTools/Records/Bed12Interval.h
@@ -21,10 +21,10 @@ public:
 	Bed12Interval();
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
 	virtual void clear();
-	virtual void print(QuickString &outBuf) const;
-	virtual void print(QuickString &outBuf, int start, int end) const;
-	virtual void print(QuickString &outBuf, const QuickString & start, const QuickString & end) const;
-	virtual void printNull(QuickString &outBuf) const;
+	virtual void print(string &outBuf) const;
+	virtual void print(string &outBuf, int start, int end) const;
+	virtual void print(string &outBuf, const string & start, const string & end) const;
+	virtual void printNull(string &outBuf) const;
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::BED12_RECORD_TYPE; }
 
 	const Bed12Interval &operator=(const Bed12Interval &other);
@@ -35,25 +35,22 @@ public:
 	virtual int getThickEnd() const { return _thickEnd; }
 	virtual void setThickEnd(int thickEnd) { _thickEnd = thickEnd; }
 
-	virtual const QuickString & getItemRGB() const { return _itemRGB; }
-	virtual void setItemRGB(const QuickString & rgb) { _itemRGB = rgb; }
+	virtual const string & getItemRGB() const { return _itemRGB; }
 	virtual void setItemRGB(const string & rgb) { _itemRGB = rgb; }
 	virtual void setItemRGB(const char *rgb) { _itemRGB = rgb; }
 
 	virtual int getBlockCount() const { return _blockCount; }
 	virtual void setBlockCount(int blockCount) { _blockCount = blockCount; }
 
-	virtual const QuickString & getBlockSizes() const { return _blockSizes; }
-	virtual void setBlockSizes(const QuickString & blockSizes) { _blockSizes = blockSizes; }
+	virtual const string & getBlockSizes() const { return _blockSizes; }
 	virtual void setBlockSizes(const string & blockSizes) { _blockSizes = blockSizes; }
 	virtual void setBlockSizes(const char *blockSizes) { _blockSizes = blockSizes; }
 
-	virtual const QuickString & getBlockStarts() const { return _blockStarts; }
-	virtual void setBlockStarts(const QuickString & blockStarts) { _blockStarts = blockStarts; }
+	virtual const string & getBlockStarts() const { return _blockStarts; }
 	virtual void setBlockStarts(const string & blockStarts) { _blockStarts = blockStarts; }
 	virtual void setBlockStarts(const char *blockStarts) { _blockStarts = blockStarts; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual int getNumFields() const  { return 12; }
 	static bool isNumericField(int fieldNum);
 	int getLength(bool obeySplits) const;
@@ -64,15 +61,15 @@ protected:
 
 	int _thickStart;
 	int _thickEnd;
-	QuickString _itemRGB;
+	string _itemRGB;
 	int _blockCount;
-	QuickString _blockSizes;
-	QuickString _blockStarts;
+	string _blockSizes;
+	string _blockStarts;
 
 	//store int values as their originial strings for faster outputting.
-	QuickString _thickStartStr;
-	QuickString _thickEndStr;
-	QuickString _blockCountStr;
+	string _thickStartStr;
+	string _thickEndStr;
+	string _blockCountStr;
 };
 
 
diff --git a/src/utils/FileRecordTools/Records/Bed3Interval.cpp b/src/utils/FileRecordTools/Records/Bed3Interval.cpp
index 036d0c6..d2d3441 100644
--- a/src/utils/FileRecordTools/Records/Bed3Interval.cpp
+++ b/src/utils/FileRecordTools/Records/Bed3Interval.cpp
@@ -31,38 +31,42 @@ bool Bed3Interval::initFromFile(SingleLineDelimTextFileReader *fileReader)
 	return true;
 }
 
-void Bed3Interval::print(QuickString &outBuf) const
+void Bed3Interval::print(string &outBuf) const
 {
-	outBuf.append(_chrName);
-	outBuf.append('\t');
-	outBuf.append(_startPos);
-	outBuf.append('\t');
-	outBuf.append(_endPos);
+	ostringstream s;
+	s << _chrName;
+	s << "\t";
+	s << _startPos;
+	s << "\t";
+	s << _endPos;
+	outBuf.append(s.str());
 }
 
-void Bed3Interval::print(QuickString &outBuf, int start, int end) const
+void Bed3Interval::print(string &outBuf, int start, int end) const
 {
-	outBuf.append(_chrName);
-	outBuf.append('\t');
-	outBuf.append(start);
-	outBuf.append('\t');
-	outBuf.append(end);
+	ostringstream s;
+	s << _chrName;
+	s << "\t";
+	s << start;
+	s << "\t";
+	s << end;
+	outBuf.append(s.str());
 }
 
-void Bed3Interval::print(QuickString &outBuf, const QuickString & start, const QuickString & end) const
+void Bed3Interval::print(string &outBuf, const string & start, const string & end) const
 {
 	outBuf.append(_chrName);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(start);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(end);
 }
 
-void Bed3Interval::printNull(QuickString &outBuf) const {
+void Bed3Interval::printNull(string &outBuf) const {
 	outBuf.append(".\t-1\t-1", 7);
 }
 
-const QuickString &Bed3Interval::getField(int fieldNum) const
+const string &Bed3Interval::getField(int fieldNum) const
 {
 	switch (fieldNum) {
 	case 1:
diff --git a/src/utils/FileRecordTools/Records/Bed3Interval.h b/src/utils/FileRecordTools/Records/Bed3Interval.h
index 2e9a878..fcc1b1c 100644
--- a/src/utils/FileRecordTools/Records/Bed3Interval.h
+++ b/src/utils/FileRecordTools/Records/Bed3Interval.h
@@ -10,7 +10,7 @@
 
 #include "Record.h"
 #include "ParseTools.h"
-#include "QuickString.h"
+#include "string.h"
 
 class FileReader;
 class SingleLineDelimTextFileReader;
@@ -23,13 +23,13 @@ public:
 	Bed3Interval();
 	bool initFromFile(FileReader *);
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
-	virtual void print(QuickString &outBuf) const;
-	virtual void print(QuickString &outBuf, int start, int end) const;
-	virtual void print(QuickString &outBuf, const QuickString & start, const QuickString & end) const;
-	virtual void printNull(QuickString &outBuf) const;
+	virtual void print(string &outBuf) const;
+	virtual void print(string &outBuf, int start, int end) const;
+	virtual void print(string &outBuf, const string & start, const string & end) const;
+	virtual void printNull(string &outBuf) const;
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::BED3_RECORD_TYPE; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual int getNumFields() const  { return 3; }
 
 	static bool isNumericField(int fieldNum);
diff --git a/src/utils/FileRecordTools/Records/Bed4Interval.cpp b/src/utils/FileRecordTools/Records/Bed4Interval.cpp
index 4d16b75..6d47e5f 100644
--- a/src/utils/FileRecordTools/Records/Bed4Interval.cpp
+++ b/src/utils/FileRecordTools/Records/Bed4Interval.cpp
@@ -20,35 +20,35 @@ bool Bed4Interval::initFromFile(SingleLineDelimTextFileReader *fileReader)
 	return baseRetFlag;
 }
 
-void Bed4Interval::print(QuickString &outBuf) const
+void Bed4Interval::print(string &outBuf) const
 {
 	Bed3Interval::print(outBuf);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
 }
 
-void Bed4Interval::print(QuickString &outBuf, int start, int end) const
+void Bed4Interval::print(string &outBuf, int start, int end) const
 {
 	Bed3Interval::print(outBuf, start, end);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
 }
 
-void Bed4Interval::print(QuickString &outBuf, const QuickString & start, const QuickString & end) const
+void Bed4Interval::print(string &outBuf, const string & start, const string & end) const
 {
 	Bed3Interval::print(outBuf, start, end);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
 }
 
-void Bed4Interval::printNull(QuickString &outBuf) const
+void Bed4Interval::printNull(string &outBuf) const
 {
 	Bed3Interval::printNull(outBuf);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(".");
 }
 
-const QuickString &Bed4Interval::getField(int fieldNum) const
+const string &Bed4Interval::getField(int fieldNum) const
 {
 	switch (fieldNum) {
 	case 4:
diff --git a/src/utils/FileRecordTools/Records/Bed4Interval.h b/src/utils/FileRecordTools/Records/Bed4Interval.h
index b038446..2e6bb94 100644
--- a/src/utils/FileRecordTools/Records/Bed4Interval.h
+++ b/src/utils/FileRecordTools/Records/Bed4Interval.h
@@ -20,13 +20,13 @@ public:
 
 	Bed4Interval();
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
-	virtual void print(QuickString &outBuf) const;
-	virtual void print(QuickString &outBuf, int start, int end) const;
-	virtual void print(QuickString &outBuf, const QuickString & start, const QuickString & end) const;
-	virtual void printNull(QuickString &outBuf) const;
+	virtual void print(string &outBuf) const;
+	virtual void print(string &outBuf, int start, int end) const;
+	virtual void print(string &outBuf, const string & start, const string & end) const;
+	virtual void printNull(string &outBuf) const;
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::BED4_RECORD_TYPE; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual int getNumFields() const  { return 4; }
 	static bool isNumericField(int fieldNum);
 
diff --git a/src/utils/FileRecordTools/Records/Bed5Interval.cpp b/src/utils/FileRecordTools/Records/Bed5Interval.cpp
index 130a788..8f80d50 100644
--- a/src/utils/FileRecordTools/Records/Bed5Interval.cpp
+++ b/src/utils/FileRecordTools/Records/Bed5Interval.cpp
@@ -21,41 +21,41 @@ bool Bed5Interval::initFromFile(SingleLineDelimTextFileReader *fileReader)
 	return baseRetFlag;
 }
 
-void Bed5Interval::print(QuickString &outBuf) const
+void Bed5Interval::print(string &outBuf) const
 {
 	Bed3Interval::print(outBuf);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_score);
 }
 
-void Bed5Interval::print(QuickString &outBuf, int start, int end) const
+void Bed5Interval::print(string &outBuf, int start, int end) const
 {
 	Bed3Interval::print(outBuf, start, end);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_score);
 }
 
-void Bed5Interval::print(QuickString &outBuf, const QuickString & start, const QuickString & end) const
+void Bed5Interval::print(string &outBuf, const string & start, const string & end) const
 {
 	Bed3Interval::print(outBuf, start, end);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_score);
 }
 
 
-void Bed5Interval::printNull(QuickString &outBuf) const
+void Bed5Interval::printNull(string &outBuf) const
 {
 	Bed3Interval::printNull(outBuf);
 	outBuf.append("\t.\t-1", 5);
 }
 
-const QuickString &Bed5Interval::getField(int fieldNum) const
+const string &Bed5Interval::getField(int fieldNum) const
 {
 	switch (fieldNum) {
 	case 4:
diff --git a/src/utils/FileRecordTools/Records/Bed5Interval.h b/src/utils/FileRecordTools/Records/Bed5Interval.h
index 2064d35..906a3c1 100644
--- a/src/utils/FileRecordTools/Records/Bed5Interval.h
+++ b/src/utils/FileRecordTools/Records/Bed5Interval.h
@@ -19,13 +19,13 @@ public:
 
 	Bed5Interval();
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
-	virtual void print(QuickString &outBuf) const;
-	virtual void print(QuickString &outBuf, int start, int end) const;
-	virtual void print(QuickString &outBuf, const QuickString & start, const QuickString & end) const;
-	virtual void printNull(QuickString &outBuf) const;
+	virtual void print(string &outBuf) const;
+	virtual void print(string &outBuf, int start, int end) const;
+	virtual void print(string &outBuf, const string & start, const string & end) const;
+	virtual void printNull(string &outBuf) const;
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::BED5_RECORD_TYPE; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual int getNumFields() const  { return 5; }
 	static bool isNumericField(int fieldNum);
 
diff --git a/src/utils/FileRecordTools/Records/Bed6Interval.cpp b/src/utils/FileRecordTools/Records/Bed6Interval.cpp
index 5bc783c..7cf744b 100644
--- a/src/utils/FileRecordTools/Records/Bed6Interval.cpp
+++ b/src/utils/FileRecordTools/Records/Bed6Interval.cpp
@@ -23,48 +23,48 @@ bool Bed6Interval::initFromFile(SingleLineDelimTextFileReader *fileReader)
 	return baseRetFlag;
 }
 
-void Bed6Interval::print(QuickString &outBuf) const
+void Bed6Interval::print(string &outBuf) const
 {
 	Bed3Interval::print(outBuf);
 
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_score);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_strand);
 }
 
-void Bed6Interval::print(QuickString &outBuf, int start, int end) const
+void Bed6Interval::print(string &outBuf, int start, int end) const
 {
 	Bed3Interval::print(outBuf, start, end);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_score);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_strand);
 }
 
-void Bed6Interval::print(QuickString &outBuf, const QuickString & start, const QuickString & end) const
+void Bed6Interval::print(string &outBuf, const string & start, const string & end) const
 {
 	Bed3Interval::print(outBuf, start, end);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_score);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_strand);
 }
 
 
-void Bed6Interval::printNull(QuickString &outBuf) const
+void Bed6Interval::printNull(string &outBuf) const
 {
 	Bed3Interval::printNull(outBuf);
 	outBuf.append("\t.\t-1\t.", 7);
 }
 
-const QuickString &Bed6Interval::getField(int fieldNum) const
+const string &Bed6Interval::getField(int fieldNum) const
 {
 	switch (fieldNum) {
 	case 4:
diff --git a/src/utils/FileRecordTools/Records/Bed6Interval.h b/src/utils/FileRecordTools/Records/Bed6Interval.h
index 023683f..d6787ca 100644
--- a/src/utils/FileRecordTools/Records/Bed6Interval.h
+++ b/src/utils/FileRecordTools/Records/Bed6Interval.h
@@ -19,13 +19,13 @@ public:
 
 	Bed6Interval();
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
-	virtual void print(QuickString &outBuf) const;
-	virtual void print(QuickString &outBuf, int start, int end) const;
-	virtual void print(QuickString &outBuf, const QuickString & start, const QuickString & end) const;
-	virtual void printNull(QuickString &outBuf) const;
+	virtual void print(string &outBuf) const;
+	virtual void print(string &outBuf, int start, int end) const;
+	virtual void print(string &outBuf, const string & start, const string & end) const;
+	virtual void printNull(string &outBuf) const;
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::BED6_RECORD_TYPE; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual int getNumFields() const  { return 6; }
 	static bool isNumericField(int fieldNum);
 
diff --git a/src/utils/FileRecordTools/Records/BedGraphInterval.cpp b/src/utils/FileRecordTools/Records/BedGraphInterval.cpp
index 9cfda48..781f7d9 100644
--- a/src/utils/FileRecordTools/Records/BedGraphInterval.cpp
+++ b/src/utils/FileRecordTools/Records/BedGraphInterval.cpp
@@ -20,35 +20,35 @@ bool BedGraphInterval::initFromFile(SingleLineDelimTextFileReader *fileReader)
 	return baseRetFlag;
 }
 
-void BedGraphInterval::print(QuickString &outBuf) const
+void BedGraphInterval::print(string &outBuf) const
 {
 	Bed3Interval::print(outBuf);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
 }
 
-void BedGraphInterval::print(QuickString &outBuf, int start, int end) const
+void BedGraphInterval::print(string &outBuf, int start, int end) const
 {
 	Bed3Interval::print(outBuf, start, end);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
 }
 
-void BedGraphInterval::print(QuickString &outBuf, const QuickString & start, const QuickString & end) const
+void BedGraphInterval::print(string &outBuf, const string & start, const string & end) const
 {
 	Bed3Interval::print(outBuf, start, end);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
 }
 
 
-void BedGraphInterval::printNull(QuickString &outBuf) const
+void BedGraphInterval::printNull(string &outBuf) const
 {
 	Bed3Interval::printNull(outBuf);
 	outBuf.append("\t.", 2);
 }
 
-const QuickString &BedGraphInterval::getField(int fieldNum) const
+const string &BedGraphInterval::getField(int fieldNum) const
 {
 	switch (fieldNum) {
 	case 4:
diff --git a/src/utils/FileRecordTools/Records/BedGraphInterval.h b/src/utils/FileRecordTools/Records/BedGraphInterval.h
index 5db6fea..767b3a0 100644
--- a/src/utils/FileRecordTools/Records/BedGraphInterval.h
+++ b/src/utils/FileRecordTools/Records/BedGraphInterval.h
@@ -19,13 +19,13 @@ public:
 
 	BedGraphInterval();
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
-	virtual void print(QuickString &outBuf) const;
-	virtual void print(QuickString &outBuf, int start, int end) const;
-	virtual void print(QuickString &outBuf, const QuickString & start, const QuickString & end) const;
-	virtual void printNull(QuickString &outBuf) const;
+	virtual void print(string &outBuf) const;
+	virtual void print(string &outBuf, int start, int end) const;
+	virtual void print(string &outBuf, const string & start, const string & end) const;
+	virtual void printNull(string &outBuf) const;
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::BEDGRAPH_RECORD_TYPE; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual int getNumFields() const  { return 4; }
 
 	static bool isNumericField(int fieldNum);
diff --git a/src/utils/FileRecordTools/Records/BedPlusInterval.cpp b/src/utils/FileRecordTools/Records/BedPlusInterval.cpp
index da6ae96..3750751 100644
--- a/src/utils/FileRecordTools/Records/BedPlusInterval.cpp
+++ b/src/utils/FileRecordTools/Records/BedPlusInterval.cpp
@@ -35,29 +35,32 @@ void BedPlusInterval::clear() {
 	_plusFields.clear();
 }
 
-void BedPlusInterval::print(QuickString &outBuf) const
+void BedPlusInterval::print(string &outBuf) const
 {
 	Bed3Interval::print(outBuf);
+	outBuf.append("\t");
 	printBed6PlusFields(outBuf);
 	_plusFields.printFields(outBuf);
 }
 
-void BedPlusInterval::print(QuickString &outBuf, int start, int end) const
+void BedPlusInterval::print(string &outBuf, int start, int end) const
 {
 	Bed3Interval::print(outBuf, start, end);
+	outBuf.append("\t");
 	printBed6PlusFields(outBuf);
 	_plusFields.printFields(outBuf);
 }
 
-void BedPlusInterval::print(QuickString &outBuf, const QuickString & start, const QuickString & end) const
+void BedPlusInterval::print(string &outBuf, const string & start, const string & end) const
 {
 	Bed3Interval::print(outBuf, start, end);
+	outBuf.append("\t");
 	printBed6PlusFields(outBuf);
 	_plusFields.printFields(outBuf);
 }
 
 
-void BedPlusInterval::printNull(QuickString &outBuf) const
+void BedPlusInterval::printNull(string &outBuf) const
 {
 	Bed3Interval::printNull(outBuf);
 	printBed6PlusNullFields(outBuf);
@@ -66,7 +69,7 @@ void BedPlusInterval::printNull(QuickString &outBuf) const
 	}
 }
 
-const QuickString &BedPlusInterval::getField(int fieldNum) const
+const string &BedPlusInterval::getField(int fieldNum) const
 {
 	if (fieldNum > _numFixedFields) {
 		return _plusFields.getField(fieldNum);
@@ -94,19 +97,18 @@ bool BedPlusInterval::isNumericField(int fieldNum) {
 	return Bed3Interval::isNumericField(fieldNum);
 }
 
-void BedPlusInterval::printBed6PlusFields(QuickString &outBuf) const {
+void BedPlusInterval::printBed6PlusFields(string &outBuf) const {
 	if (_numFixedFields != defaultNumFixedFields) {
-		outBuf.append('\t');
 		outBuf.append(_name);
-		outBuf.append('\t');
+		outBuf.append("\t");
 		outBuf.append(_score);
-		outBuf.append('\t');
+		outBuf.append("\t");
 		outBuf.append(_strand);
+		outBuf.append("\t");
 	}
-
 }
 
-void BedPlusInterval::printBed6PlusNullFields(QuickString &outBuf) const {
+void BedPlusInterval::printBed6PlusNullFields(string &outBuf) const {
 	if (_numFixedFields != defaultNumFixedFields) {
 		outBuf.append("\t.\t.\t.");
 	}
diff --git a/src/utils/FileRecordTools/Records/BedPlusInterval.h b/src/utils/FileRecordTools/Records/BedPlusInterval.h
index bf75db7..0eb0b42 100644
--- a/src/utils/FileRecordTools/Records/BedPlusInterval.h
+++ b/src/utils/FileRecordTools/Records/BedPlusInterval.h
@@ -22,13 +22,13 @@ public:
 	void setNumFixedFields(int numFields);
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
 	virtual void clear();
-	virtual void print(QuickString &outBuf) const;
-	virtual void print(QuickString &outBuf, int start, int end) const;
-	virtual void print(QuickString &outBuf, const QuickString & start, const QuickString & end) const;
-	virtual void printNull(QuickString &outBuf) const;
+	virtual void print(string &outBuf) const;
+	virtual void print(string &outBuf, int start, int end) const;
+	virtual void print(string &outBuf, const string & start, const string & end) const;
+	virtual void printNull(string &outBuf) const;
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::BED_PLUS_RECORD_TYPE; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual int getNumFields() const  { return _numFixedFields + _plusFields.size(); }
 
 	virtual void setNumPrintFields(int num) { _numPrintFields = num; }
@@ -42,8 +42,8 @@ protected:
 	PlusFields _plusFields;
 	int _numPrintFields;
 
-	void printBed6PlusFields(QuickString &outBuf) const;
-	void printBed6PlusNullFields(QuickString &outBuf) const;
+	void printBed6PlusFields(string &outBuf) const;
+	void printBed6PlusNullFields(string &outBuf) const;
 
 };
 
diff --git a/src/utils/FileRecordTools/Records/BlockMgr.cpp b/src/utils/FileRecordTools/Records/BlockMgr.cpp
index eb63972..bfccc60 100644
--- a/src/utils/FileRecordTools/Records/BlockMgr.cpp
+++ b/src/utils/FileRecordTools/Records/BlockMgr.cpp
@@ -48,8 +48,6 @@ void BlockMgr::getBlocks(RecordKeyVector &keyList, bool &mustDelete)
 	}
 }
 
-
-
 void BlockMgr::getBlocksFromBed12(RecordKeyVector &keyList, bool &mustDelete)
 {
 	const Bed12Interval *keyRecord = static_cast<const Bed12Interval *>(keyList.getKey());
@@ -72,7 +70,7 @@ void BlockMgr::getBlocksFromBed12(RecordKeyVector &keyList, bool &mustDelete)
     	int startPos = keyRecord->getStartPos() + str2chrPos(_blockStartTokens.getElem(i).c_str());
     	int endPos = startPos + str2chrPos(_blockSizeTokens.getElem(i).c_str());
 
-    	const Record *record = allocateAndAssignRecord(keyRecord, startPos, endPos);
+    	Record *record = allocateAndAssignRecord(keyRecord, startPos, endPos);
     	keyList.push_back(record);
     }
     mustDelete = true;
@@ -128,22 +126,12 @@ Record *BlockMgr::allocateAndAssignRecord(const Record *keyRecord, int startPos,
 	record->setChromId(keyRecord->getChromId());
 	record->setStartPos(startPos);
 	record->setEndPos(endPos);
-	QuickString startPosStr;
-	QuickString endPosStr;
-	startPosStr.append(startPos);
-	endPosStr.append(endPos);
-	record->setStartPosStr(startPosStr);
-	record->setEndPosStr(endPosStr);
-	record->setName(keyRecord->getName());
-	record->setScore(keyRecord->getScore());
-	record->setStrand(keyRecord->getStrand());
-
 	return record;
 }
 
 int BlockMgr::getTotalBlockLength(RecordKeyVector &keyList) {
 	int sum = 0;
-	for (RecordKeyVector::const_iterator_type iter = keyList.begin(); iter != keyList.end(); iter = keyList.next()) {
+	for (RecordKeyVector::iterator_type iter = keyList.begin(); iter != keyList.end(); iter = keyList.next()) {
 		const Record *record = *iter;
 		sum += record->getEndPos() - record->getStartPos();
 	}
@@ -152,28 +140,25 @@ int BlockMgr::getTotalBlockLength(RecordKeyVector &keyList) {
 
 void BlockMgr::deleteBlocks(RecordKeyVector &keyList)
 {
-	for (RecordKeyVector::const_iterator_type iter = keyList.begin(); iter != keyList.end(); iter = keyList.next()) {
+	for (RecordKeyVector::iterator_type iter = keyList.begin(); iter != keyList.end(); iter = keyList.next()) {
 		_blockRecordsMgr->deleteRecord(*iter);
 	}
 	keyList.clearVector();
-
 }
 
 
-int BlockMgr::findBlockedOverlaps(RecordKeyVector &keyList, RecordKeyVector &hitList, 
-	                              RecordKeyVector &resultList, RecordKeyVector &overlapList)
+int BlockMgr::findBlockedOverlaps(RecordKeyVector &hitList, bool useOverlappingSubBlocks)
 {
-	bool deleteKeyBlocks = false;
-	if (keyList.empty()) {
-		//get all the blocks for the query record, put them in it's list.
-		getBlocks(keyList, deleteKeyBlocks);
-	}
+	RecordKeyVector keyList(hitList.getKey());
+	bool deleteKeyBlocks = true;
+	getBlocks(keyList, deleteKeyBlocks);
+	
 	_overlapBases.clear();
 	int keyBlocksSumLength = getTotalBlockLength(keyList);
 
 	//Loop through every database record the query intersected with
-	RecordKeyVector::const_iterator_type hitListIter = hitList.begin();
-	for (; hitListIter != hitList.end(); hitListIter = hitList.next()) 
+	RecordKeyVector::iterator_type hitListIter = hitList.begin();
+	for (; hitListIter != hitList.end();) 
 	{
 		RecordKeyVector hitBlocks(*hitListIter);
 		bool deleteHitBlocks = false;
@@ -183,46 +168,78 @@ int BlockMgr::findBlockedOverlaps(RecordKeyVector &keyList, RecordKeyVector &hit
 		bool hitHasOverlap = false;
 
 		//loop through every block of the database record.
-		RecordKeyVector::const_iterator_type hitBlockIter = hitBlocks.begin();
+		RecordKeyVector::iterator_type hitBlockIter = hitBlocks.begin();
 		for (; hitBlockIter != hitBlocks.end(); hitBlockIter = hitBlocks.next()) 
 		{
 			//loop through every block of the query record.
-			RecordKeyVector::const_iterator_type keyListIter = keyList.begin();
+			RecordKeyVector::iterator_type keyListIter = keyList.begin();
 			for (; keyListIter != keyList.end(); keyListIter = keyList.next()) 
 			{
 				const Record *keyBlock = *keyListIter;
 				const Record *hitBlock = *hitBlockIter;
-
 				int maxStart = max(keyBlock->getStartPos(), hitBlock->getStartPos());
-				int minEnd = min(keyBlock->getEndPos(), hitBlock->getEndPos());
+				int minEnd   = min(keyBlock->getEndPos(), hitBlock->getEndPos());
 				int overlap  = minEnd - maxStart;
-				if (overlap > 0) {
+				if (overlap > 0) 
+				{
 					hitHasOverlap = true;
-					overlapList.push_back(allocateAndAssignRecord(keyList.getKey(), maxStart, minEnd));
 					totalHitOverlap += overlap;
+					if (useOverlappingSubBlocks == true)
+					{
+						(*hitListIter)->block_starts.push_back(maxStart);
+						(*hitListIter)->block_ends.push_back(minEnd);
+					}
 				}
 			}
 		}
-		if (hitHasOverlap) {
-			if ((float) totalHitOverlap / (float)keyBlocksSumLength >= _overlapFraction) {
-				if (_hasReciprocal &&
-						((float)totalHitOverlap / (float)hitBlockSumLength >= _overlapFraction)) {
+		if (hitHasOverlap && useOverlappingSubBlocks == false) 
+		{
+			bool enoughKeyOverlap = (float) totalHitOverlap / (float) keyBlocksSumLength >= _overlapFraction;
+			bool enoughHitOverlap = (float) totalHitOverlap / (float) hitBlockSumLength  >= _overlapFraction;
+
+			if (enoughKeyOverlap) 
+			{
+				if (_hasReciprocal && enoughHitOverlap)
+				{
+					//(*hitListIter)->setValid(true);
 					_overlapBases.push_back(totalHitOverlap);
-					resultList.push_back(*hitListIter);
-				} else if (!_hasReciprocal) {
+					hitListIter = hitList.next();
+				} 
+				else if (_hasReciprocal && !enoughHitOverlap)
+				{
+					hitList.erase();
+					//(*hitListIter)->setValid(false);
+				} 
+				else if (!_hasReciprocal) 
+				{
+					//(*hitListIter)->setValid(true);
 					_overlapBases.push_back(totalHitOverlap);
-					resultList.push_back(*hitListIter);
+					hitListIter = hitList.next();
 				}
 			}
+			else 
+			{
+				hitList.erase();
+				//(*hitListIter)->setValid(false);
+			}
+		}
+		else if (!hitHasOverlap && useOverlappingSubBlocks == false) 
+		{
+			hitList.erase();
+			//(*hitListIter)->setValid(false);
 		}
-		if (deleteHitBlocks) {
+		else {
+			hitListIter = hitList.next();
+		}
+		if (deleteHitBlocks)
+		{
 			deleteBlocks(hitBlocks);
 		}
-	}
-	if (deleteKeyBlocks) {
+	} // end for loop through main hits
+	if (deleteKeyBlocks) 
+	{
 		deleteBlocks(keyList);
 	}
-	resultList.setKey(keyList.getKey());
-	return (int)resultList.size();
+	return (int)hitList.size();
 }
 
diff --git a/src/utils/FileRecordTools/Records/BlockMgr.h b/src/utils/FileRecordTools/Records/BlockMgr.h
index fce996a..4fe739c 100644
--- a/src/utils/FileRecordTools/Records/BlockMgr.h
+++ b/src/utils/FileRecordTools/Records/BlockMgr.h
@@ -34,10 +34,12 @@ public:
 	// Determine which hits in the hitList intersect the hits in the keyList by comparing all blocks in each
 	// and checking that their total intersection meets any overlapFraction and reciprocal criteria compared to
 	// the total block lengths of the hitList and keyList. All hits that pass will be in the resultList.
+	//
+	// If useOverlappingSubBlocks is true, resultList will contain the sub-intervals of the hit blocks 
+	// that overlap the query blocks.
+	//
 	// Return value is the number of hits in the result set.
-
-	int findBlockedOverlaps(RecordKeyVector &keyList, RecordKeyVector &hitList, 
-							RecordKeyVector &resultList, RecordKeyVector &overlapList);
+	int findBlockedOverlaps(RecordKeyVector &hitList, bool useOverlappingSubBlocks);
 
 	//these are setting options for splitting BAM records
 	void setBreakOnDeletionOps(bool val) { _breakOnDeletionOps = val; }
diff --git a/src/utils/FileRecordTools/Records/GffPlusRecord.cpp b/src/utils/FileRecordTools/Records/GffPlusRecord.cpp
index d09bc48..c155b2c 100644
--- a/src/utils/FileRecordTools/Records/GffPlusRecord.cpp
+++ b/src/utils/FileRecordTools/Records/GffPlusRecord.cpp
@@ -25,26 +25,26 @@ void GffPlusRecord::clear() {
 	_plusFields.clear();
 }
 
-void GffPlusRecord::print(QuickString &outBuf) const
+void GffPlusRecord::print(string &outBuf) const
 {
 	GffRecord::print(outBuf);
 	_plusFields.printFields(outBuf);
 }
 
-void GffPlusRecord::print(QuickString &outBuf, int start, int end) const
+void GffPlusRecord::print(string &outBuf, int start, int end) const
 {
 	GffRecord::print(outBuf, start, end);
 	_plusFields.printFields(outBuf);
 }
 
-void GffPlusRecord::print(QuickString &outBuf, const QuickString & start, const QuickString & end) const
+void GffPlusRecord::print(string &outBuf, const string & start, const string & end) const
 {
 	GffRecord::print(outBuf, start, end);
 	_plusFields.printFields(outBuf);
 }
 
 
-void GffPlusRecord::printNull(QuickString &outBuf) const
+void GffPlusRecord::printNull(string &outBuf) const
 {
 	GffRecord::printNull(outBuf);
 	for (int i=_numFields; i < _numPrintFields; i++) {
@@ -52,7 +52,7 @@ void GffPlusRecord::printNull(QuickString &outBuf) const
 	}
 }
 
-const QuickString &GffPlusRecord::getField(int fieldNum) const
+const string &GffPlusRecord::getField(int fieldNum) const
 {
 	if (fieldNum > _numFields) {
 		return _plusFields.getField(fieldNum);
diff --git a/src/utils/FileRecordTools/Records/GffPlusRecord.h b/src/utils/FileRecordTools/Records/GffPlusRecord.h
index e485b43..ac72b89 100644
--- a/src/utils/FileRecordTools/Records/GffPlusRecord.h
+++ b/src/utils/FileRecordTools/Records/GffPlusRecord.h
@@ -21,13 +21,13 @@ public:
 	virtual ~GffPlusRecord();
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
 	virtual void clear();
-	virtual void print(QuickString &outBuf) const;
-	virtual void print(QuickString &outBuf, int start, int end) const;
-	virtual void print(QuickString &outBuf, const QuickString & start, const QuickString & end) const;
-	virtual void printNull(QuickString &outBuf) const;
+	virtual void print(string &outBuf) const;
+	virtual void print(string &outBuf, int start, int end) const;
+	virtual void print(string &outBuf, const string & start, const string & end) const;
+	virtual void printNull(string &outBuf) const;
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::GFF_PLUS_RECORD_TYPE; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual int getNumFields() const  { return GffRecord::getNumFields() + _plusFields.size(); }
 
 	virtual void setNumPrintFields(int num) { _numPrintFields = num; }
diff --git a/src/utils/FileRecordTools/Records/GffRecord.cpp b/src/utils/FileRecordTools/Records/GffRecord.cpp
index d111ad9..11f3d77 100644
--- a/src/utils/FileRecordTools/Records/GffRecord.cpp
+++ b/src/utils/FileRecordTools/Records/GffRecord.cpp
@@ -50,68 +50,70 @@ bool GffRecord::initFromFile(SingleLineDelimTextFileReader *fileReader)
 	return true;
 }
 
-void GffRecord::print(QuickString &outBuf) const
+void GffRecord::print(string &outBuf) const
 {
-	outBuf.append(_chrName);
-	outBuf.append('\t');
-	outBuf.append(_source);
-	outBuf.append('\t');
-	outBuf.append(_name);
-	outBuf.append('\t');
-	outBuf.append(_startPosStr);
-	outBuf.append('\t');
-	outBuf.append(_endPosStr);
-	outBuf.append('\t');
-
+	ostringstream s;	
+	s << _chrName;
+	s << "\t";
+	s << _source;
+	s << "\t";
+	s << _name;
+	s << "\t";
+	s << _startPosStr;
+	s << "\t";
+	s << _endPosStr;
+	s << "\t";
+	outBuf.append(s.str());
 	printRemainingFields(outBuf);
 }
 
-void GffRecord::print(QuickString &outBuf, int start, int end) const
+void GffRecord::print(string &outBuf, int start, int end) const
 {
-	outBuf.append(_chrName);
-	outBuf.append('\t');
-	outBuf.append(_source);
-	outBuf.append('\t');
-	outBuf.append(_name);
-	outBuf.append('\t');
-	outBuf.append(start);
-	outBuf.append('\t');
-	outBuf.append(end);
-	outBuf.append('\t');
-
+	ostringstream s;	
+	s << _chrName;
+	s << "\t";
+	s << _source;
+	s << "\t";
+	s << _name;
+	s << "\t";
+	s << start;
+	s << "\t";
+	s << end;
+	s << "\t";
+	outBuf.append(s.str());
 	printRemainingFields(outBuf);
 }
 
-void GffRecord::print(QuickString &outBuf, const QuickString & start, const QuickString & end) const
+void GffRecord::print(string &outBuf, const string & start, const string & end) const
 {
 	outBuf.append(_chrName);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_source);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_name);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(start);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(end);
-	outBuf.append('\t');
+	outBuf.append("\t");
 
 	printRemainingFields(outBuf);
 }
 
-void GffRecord::printRemainingFields(QuickString &outBuf) const
+void GffRecord::printRemainingFields(string &outBuf) const
 {
 	outBuf.append(_score);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_strand);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_frame);
 	if (_numFields == 9) {
-		outBuf.append('\t');
+		outBuf.append("\t");
 		outBuf.append(_group);
 	}
 }
 
-void GffRecord::printNull(QuickString &outBuf) const
+void GffRecord::printNull(string &outBuf) const
 {
 	outBuf.append(".\t.\t.\t-1\t-1\t.\t.\t.", 17);
 	if (_numFields > 8) {
@@ -119,7 +121,7 @@ void GffRecord::printNull(QuickString &outBuf) const
 	}
 }
 
-const QuickString &GffRecord::getField(int fieldNum) const
+const string &GffRecord::getField(int fieldNum) const
 {
 	if (fieldNum == 9 && _numFields == 9) {
 		return _group;
diff --git a/src/utils/FileRecordTools/Records/GffRecord.h b/src/utils/FileRecordTools/Records/GffRecord.h
index 40b0d77..040406b 100644
--- a/src/utils/FileRecordTools/Records/GffRecord.h
+++ b/src/utils/FileRecordTools/Records/GffRecord.h
@@ -20,28 +20,28 @@ public:
 	virtual ~GffRecord();
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
 	virtual void clear();
-	virtual void print(QuickString &outBuf) const;
-	virtual void print(QuickString &outBuf, int start, int end) const;
-	virtual void print(QuickString &outBuf, const QuickString & start, const QuickString & end) const;
-	virtual void printNull(QuickString &outBuf) const;
+	virtual void print(string &outBuf) const;
+	virtual void print(string &outBuf, int start, int end) const;
+	virtual void print(string &outBuf, const string & start, const string & end) const;
+	virtual void printNull(string &outBuf) const;
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::GFF_RECORD_TYPE; }
-	virtual const QuickString &getSource() const { return _source; }
-	virtual const QuickString &getFrame() const { return _frame; }
-	virtual const QuickString &getGroup() const { return _group; }
+	virtual const string &getSource() const { return _source; }
+	virtual const string &getFrame() const { return _frame; }
+	virtual const string &getGroup() const { return _group; }
 	virtual int getNumFields() const { return _numFields; }
 	virtual void setNumFields(int val) { _numFields = val; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	static bool isNumericField(int fieldNum);
 	virtual bool isZeroBased() const {return false;};
 
 protected:
-	void printRemainingFields(QuickString &outbuf) const;
+	void printRemainingFields(string &outbuf) const;
 
 	int _numFields;
-	QuickString _source;
-	QuickString _frame;
-	QuickString _group;
+	string _source;
+	string _frame;
+	string _group;
 
 };
 
diff --git a/src/utils/FileRecordTools/Records/Makefile b/src/utils/FileRecordTools/Records/Makefile
index 9de60d3..e6be94b 100644
--- a/src/utils/FileRecordTools/Records/Makefile
+++ b/src/utils/FileRecordTools/Records/Makefile
@@ -5,14 +5,14 @@ UTILITIES_DIR = ../../../utils/
 # define our includes
 # -------------------
 INCLUDES = -I$(UTILITIES_DIR)/lineFileUtilities/ \
-           -I$(UTILITIES_DIR)/FileRecordTools/FileReaders/ \
-			-I$(UTILITIES_DIR)/general/ \
-			-I$(UTILITIES_DIR)/fileType/ \
-			-I$(UTILITIES_DIR)/Contexts/ \
-			-I$(UTILITIES_DIR)/GenomeFile/ \
-			-I$(UTILITIES_DIR)/BamTools/include \
-			-I$(UTILITIES_DIR)/BamTools/src/ \
-           -I$(UTILITIES_DIR)/version/
+		-I$(UTILITIES_DIR)/FileRecordTools/FileReaders/ \
+		-I$(UTILITIES_DIR)/general/ \
+		-I$(UTILITIES_DIR)/fileType/ \
+		-I$(UTILITIES_DIR)/Contexts/ \
+		-I$(UTILITIES_DIR)/GenomeFile/ \
+		-I$(UTILITIES_DIR)/BamTools/include \
+		-I$(UTILITIES_DIR)/BamTools/src/ \
+		-I$(UTILITIES_DIR)/version/
 			
 
 # ----------------------------------
@@ -27,7 +27,7 @@ SOURCES = Record.cpp EmptyRecord.cpp Bed3Interval.cpp \
 	RecordMgr.cpp RecordList.cpp RecordKeyList.cpp RecordKeyVector.cpp
 OBJECTS= Record.o EmptyRecord.o Bed3Interval.o Bed4Interval.o BedGraphInterval.o Bed5Interval.o Bed6Interval.o PlusFields.o BedPlusInterval.o Bed12Interval.o BamRecord.o \
 	GffRecord.o GffPlusRecord.o VcfRecord.o  NoPosPlusRecord.o BlockMgr.o StrandQueue.o RecordMgr.o RecordList.o RecordKeyList.o RecordKeyVector.o
-_EXT_OBJECTS=ParseTools.o QuickString.o ChromIdLookup.o
+_EXT_OBJECTS=ParseTools.o string.o ChromIdLookup.o
 EXT_OBJECTS=$(patsubst %,$(OBJ_DIR)/%,$(_EXT_OBJECTS))
 BUILT_OBJECTS= $(patsubst %,$(OBJ_DIR)/%,$(OBJECTS))
 
diff --git a/src/utils/FileRecordTools/Records/NoPosPlusRecord.cpp b/src/utils/FileRecordTools/Records/NoPosPlusRecord.cpp
index 08ceccc..af9ad5e 100644
--- a/src/utils/FileRecordTools/Records/NoPosPlusRecord.cpp
+++ b/src/utils/FileRecordTools/Records/NoPosPlusRecord.cpp
@@ -26,12 +26,12 @@ void NoPosPlusRecord::clear() {
 	_plusFields.clear();
 }
 
-void NoPosPlusRecord::print(QuickString &outBuf) const
+void NoPosPlusRecord::print(string &outBuf) const
 {
 	_plusFields.printFields(outBuf);
 }
 
-const QuickString &NoPosPlusRecord::getField(int fieldNum) const
+const string &NoPosPlusRecord::getField(int fieldNum) const
 {
 	return _plusFields.getField(fieldNum);
 }
diff --git a/src/utils/FileRecordTools/Records/NoPosPlusRecord.h b/src/utils/FileRecordTools/Records/NoPosPlusRecord.h
index b3293ef..c953d00 100644
--- a/src/utils/FileRecordTools/Records/NoPosPlusRecord.h
+++ b/src/utils/FileRecordTools/Records/NoPosPlusRecord.h
@@ -22,10 +22,10 @@ public:
 	bool initFromFile(FileReader *);
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
 	virtual void clear();
-	virtual void print(QuickString &outBuf) const;
+	virtual void print(string &outBuf) const;
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::NO_POS_PLUS_RECORD_TYPE; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual int getNumFields() const  { return defaultNumFixedFields + (int)_plusFields.size(); }
 
 	static bool isNumericField(int fieldNum);
diff --git a/src/utils/FileRecordTools/Records/PlusFields.cpp b/src/utils/FileRecordTools/Records/PlusFields.cpp
index b272b71..19cd4ad 100644
--- a/src/utils/FileRecordTools/Records/PlusFields.cpp
+++ b/src/utils/FileRecordTools/Records/PlusFields.cpp
@@ -26,15 +26,14 @@ void PlusFields::clear() {
 	}
 }
 
-const QuickString &PlusFields::getField(int fieldNum) const
+const string &PlusFields::getField(int fieldNum) const
 {
 	return _fields[fieldNum - _numOffsetFields - 1];
 }
 
-void PlusFields::printFields(QuickString &outBuf) const {
+void PlusFields::printFields(string &outBuf) const {
 	for (size_t i=0; i < size(); i++) {
-		outBuf.append('\t');
 		outBuf.append(_fields[i]);
+		if (i < size() - 1) outBuf.append("\t");
 	}
-
 }
diff --git a/src/utils/FileRecordTools/Records/PlusFields.h b/src/utils/FileRecordTools/Records/PlusFields.h
index c077a57..a6e7014 100644
--- a/src/utils/FileRecordTools/Records/PlusFields.h
+++ b/src/utils/FileRecordTools/Records/PlusFields.h
@@ -8,7 +8,8 @@
 #ifndef PLUSFIELDS_H_
 #define PLUSFIELDS_H_
 
-#include "QuickString.h"
+#include "string.h"
+#include <string>
 #include <vector>
 
 using namespace std;
@@ -23,14 +24,14 @@ public:
 	void setNumOffsetFields(int numOffsetFields) { _numOffsetFields = numOffsetFields; }
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
 	virtual void clear();
-	virtual void printFields(QuickString &outBuf) const;
+	virtual void printFields(string &outBuf) const;
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual size_t size() const { return _fields.size(); }
 
 
 protected:
-	vector<QuickString> _fields;
+	vector<string> _fields;
 	int _numOffsetFields; //could be 3 for BedPlus, but GFF has 8 or 9
 };
 
diff --git a/src/utils/FileRecordTools/Records/Record.cpp b/src/utils/FileRecordTools/Records/Record.cpp
index b6a2da7..33c06c9 100644
--- a/src/utils/FileRecordTools/Records/Record.cpp
+++ b/src/utils/FileRecordTools/Records/Record.cpp
@@ -9,11 +9,14 @@ Record::Record()
   _strandVal(UNKNOWN),
   _zeroLength(false),
   _isUnmapped(false),
-  _isMateUnmapped(false)
-{
-}
+  _isMateUnmapped(false),
+  _isValidHit(true),
+  _frm(NULL)
+{}
 
-Record::~Record() {
+Record::~Record()
+{
+	//_frm->deleteRecord(this);
 }
 
 const Record &Record::operator=(const Record &other)
@@ -44,6 +47,7 @@ void Record::clear() {
 	_zeroLength = false;
 	_isUnmapped = false;
 	_isMateUnmapped = false;
+	_isValidHit = false;
 }
 
 bool Record::operator < (const Record &other) const
@@ -243,13 +247,13 @@ void Record::undoZeroLength()
 
 ostream &operator << (ostream &out, const Record &record)
 {
-	QuickString outBuf;
+	string outBuf;
 	record.print(outBuf);
 	out << outBuf;
 	return out;
 }
 
-const QuickString &Record::getField(int fieldNum) const
+const string &Record::getField(int fieldNum) const
 {
     cerr << endl << "*****" << endl
          << "*****ERROR: requested column " << fieldNum <<
@@ -278,7 +282,7 @@ bool Record::hasLeadingZeroInChromName(bool chrKnown) const {
 }
 
 void Record::print(FILE *fp, bool newline) const {
-	QuickString buf;
+	string buf;
 	print(buf);
 	fprintf(fp, "%s", buf.c_str());
 	if(newline) fprintf(fp, "\n");
@@ -288,3 +292,13 @@ int Record::getLength(bool obeySplits) const {
 	//only bed12 and BAM need to check splits
 	return _endPos - _startPos;
 }
+
+void Record::setFileRecordManager(FileRecordMgr *frm)
+{
+	_frm = frm;
+}
+
+FileRecordMgr * Record::getFileRecordManager()
+{
+	return _frm;
+}
\ No newline at end of file
diff --git a/src/utils/FileRecordTools/Records/Record.h b/src/utils/FileRecordTools/Records/Record.h
index c199d83..eeed218 100644
--- a/src/utils/FileRecordTools/Records/Record.h
+++ b/src/utils/FileRecordTools/Records/Record.h
@@ -10,7 +10,7 @@
 
 #include <string>
 #include "FreeList.h"
-#include "QuickString.h"
+#include "string.h"
 #include "FileRecordTypeChecker.h"
 
 using namespace std;
@@ -26,24 +26,27 @@ public:
 
 	friend class FreeList<Record>;
 
+	virtual ~Record(); //by making the destructor protected, only the friend class(es) can actually delete Record objects, or objects derived from Record.
+
 	typedef enum { FORWARD, REVERSE, UNKNOWN } strandType;
 	Record();
 	virtual bool initFromFile(FileReader *) =0;
 	virtual void clear();
-	virtual void print(QuickString &outBuf) const {}
-	virtual void print(QuickString &outBuf, int start, int end) const {}
-	virtual void print(QuickString &outBuf, const QuickString & start, const QuickString & end) const {}
+	virtual void print(string &) const {}
+	virtual void print(string &, int, int ) const {}
+	virtual void print(string &, const string &, const string &) const {}
 	virtual void print(FILE *fp, bool newline = false) const;
-	virtual void printNull(QuickString &outBuf) const {}
+	virtual void printNull(string &) const {}
 	friend ostream &operator << (ostream &out, const Record &record);
 
 	virtual const Record & operator=(const Record &);
 
-
 	virtual bool isZeroBased() const {return true;};
 
-	virtual const QuickString &getChrName() const { return _chrName; }
-	virtual void setChrName(const QuickString &chr) { _chrName = chr; }
+	virtual void setValid(const bool valid)  { _isValidHit = valid; }
+	virtual bool isValid() const { return _isValidHit; }
+
+	virtual const string &getChrName() const { return _chrName; }
 	virtual void setChrName(const string &chr) { _chrName = chr; }
 	virtual void setChrName(const char *chr) { _chrName = chr; }
 
@@ -55,19 +58,19 @@ public:
 
 	virtual int getStartPos() const { return _startPos; }
 	virtual void setStartPos(int startPos) { _startPos = startPos; }
-	virtual const QuickString &getStartPosStr() const { return _startPosStr; }
-	virtual void setStartPosStr(const QuickString &str) { _startPosStr = str; }
+	virtual const string &getStartPosStr() const { return _startPosStr; }
+	virtual void setStartPosStr(const string &str) { _startPosStr = str; }
 
 	virtual int getEndPos() const { return _endPos; }
 	virtual void setEndPos(int endPos) { _endPos = endPos; }
-	virtual const QuickString &getEndPosStr() const { return _endPosStr; }
-	virtual void setEndPosStr(const QuickString &str) { _endPosStr = str; }
+	virtual const string &getEndPosStr() const { return _endPosStr; }
+	virtual void setEndPosStr(const string &str) { _endPosStr = str; }
 
 	virtual bool getZeroLength() const { return _zeroLength; }
 	virtual void setZeroLength(bool val) { _zeroLength = val; }
 
-	virtual const QuickString &getStrand() const { return _strand; }
-	virtual void setStrand(const QuickString &val) { _strand = val;
+	virtual const string &getStrand() const { return _strand; }
+	virtual void setStrand(const string &val) { _strand = val;
 		_strandVal = (val == "+" ? FORWARD : (val == "-" ? REVERSE : UNKNOWN));
 	}
 	virtual void setStrand(char val) { _strand = val;
@@ -79,17 +82,15 @@ public:
 
 	virtual strandType getStrandVal() const {return _strandVal; }
 
-	virtual const QuickString &getName() const { return _name; }
-	virtual void setName(const QuickString &chr) { _name = chr; }
-	virtual void setName(const string &chr) { _name = chr; }
+	virtual const string &getName() const { return _name; }
+	virtual void setName(const string &name) { _name = name; }
 	virtual void setName(const char *chr) { _name = chr; }
 
-	virtual const QuickString &getScore() const { return _score; }
-	virtual void setScore(const QuickString &chr) { _score = chr; }
-	virtual void setScore(const string &chr) { _score = chr; }
+	virtual const string &getScore() const { return _score; }
+	virtual void setScore(const string &score) { _score = score; }
 	virtual void setScore(const char *chr) { _score = chr; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	virtual int getNumFields() const  = 0;
 
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::UNKNOWN_RECORD_TYPE; }
@@ -110,7 +111,7 @@ public:
 	// Bam record.
 	bool isUnmapped() const { return _isUnmapped; }
 	bool isMateUnmapped() const { return _isMateUnmapped; }
-	virtual void printUnmapped(QuickString &outBuf) const {}
+	virtual void printUnmapped(string &) const {}
 
 
 
@@ -153,26 +154,32 @@ public:
 	bool hasLeadingZeroInChromName(bool chrKnown = false) const;
 	virtual int getLength(bool obeySplits) const;
 
+	void setFileRecordManager(FileRecordMgr *frm);
+	FileRecordMgr * getFileRecordManager();
+
+	vector<int> block_starts;
+	vector<int> block_ends;
 
 protected:
-	virtual ~Record(); //by making the destructor protected, only the friend class(es) can actually delete Record objects, or objects derived from Record.
 
 	int _fileIdx; //associated file the record came from
-	QuickString _chrName;
+	string _chrName;
 	int _chrId;
 	int _startPos;
 	int _endPos;
 	//It is actually faster to also store the start and end positions as their original strings than to
 	//have to convert their integer representations back to strings when printing them.
-	QuickString _startPosStr;
-	QuickString _endPosStr;
-	QuickString _name;
-	QuickString _score;
-	QuickString _strand;
+	string _startPosStr;
+	string _endPosStr;
+	string _name;
+	string _score;
+	string _strand;
 	strandType _strandVal;
 	bool _zeroLength;
 	bool _isUnmapped;
 	bool _isMateUnmapped;
+	bool _isValidHit;
+	FileRecordMgr *_frm;
 };
 
 class RecordPtrSortAscFunctor {
diff --git a/src/utils/FileRecordTools/Records/RecordKeyList.cpp b/src/utils/FileRecordTools/Records/RecordKeyList.cpp
index 049bcdd..838f18a 100644
--- a/src/utils/FileRecordTools/Records/RecordKeyList.cpp
+++ b/src/utils/FileRecordTools/Records/RecordKeyList.cpp
@@ -5,12 +5,12 @@ RecordKeyList::RecordKeyList()
 {
 }
 
-RecordKeyList::RecordKeyList(const Record * item)
+RecordKeyList::RecordKeyList(Record * item)
 : _key(item)
 {
 }
 
-RecordKeyList::RecordKeyList(const Record * item, const listType &list)
+RecordKeyList::RecordKeyList(Record * item, listType &list)
 : _key(item)
 {
 	_list = list;
@@ -19,7 +19,7 @@ RecordKeyList::RecordKeyList(const Record * item, const listType &list)
 RecordKeyList::~RecordKeyList() {
 }
 
-const RecordKeyList &RecordKeyList::operator=(const RecordKeyList &other)
+RecordKeyList &RecordKeyList::operator=(RecordKeyList &other)
 {
 	setKey(other._key);
 	_list = other._list;
@@ -51,7 +51,7 @@ void RecordKeyList::push_back(elemType item) {
 	_list.push_back(item);
 }
 
-const Record *RecordKeyList::getKey() const {
+Record *RecordKeyList::getKey() const {
 	return _key;
 }
 
diff --git a/src/utils/FileRecordTools/Records/RecordKeyList.h b/src/utils/FileRecordTools/Records/RecordKeyList.h
index b3d94f2..de2af22 100644
--- a/src/utils/FileRecordTools/Records/RecordKeyList.h
+++ b/src/utils/FileRecordTools/Records/RecordKeyList.h
@@ -13,15 +13,15 @@
 
 class RecordKeyList {
 public:
-	typedef const Record * elemType;
+	typedef Record * elemType;
 	typedef RecordList listType;
 	typedef const RecordListNode *const_iterator_type;
 	RecordKeyList();
     RecordKeyList(elemType item);
-    RecordKeyList(elemType item, const listType &list);
+    RecordKeyList(elemType item, listType &list);
     ~RecordKeyList();
 
-    const RecordKeyList &operator=(const RecordKeyList &other);
+    RecordKeyList &operator=(RecordKeyList &other);
     const_iterator_type begin();
     const_iterator_type next();
     const_iterator_type end();
diff --git a/src/utils/FileRecordTools/Records/RecordKeyVector.cpp b/src/utils/FileRecordTools/Records/RecordKeyVector.cpp
index bb3837c..2b75846 100644
--- a/src/utils/FileRecordTools/Records/RecordKeyVector.cpp
+++ b/src/utils/FileRecordTools/Records/RecordKeyVector.cpp
@@ -17,7 +17,7 @@ RecordKeyVector::RecordKeyVector()
 	_mustDeleteVec = true;
 }
 
-RecordKeyVector::RecordKeyVector(const Record * item)
+RecordKeyVector::RecordKeyVector(Record * item)
 : _key(item),
   _currPos(0)
 {
@@ -25,7 +25,7 @@ RecordKeyVector::RecordKeyVector(const Record * item)
 	_mustDeleteVec = true;
 }
 
-RecordKeyVector::RecordKeyVector(const Record * item, const vecType *vec)
+RecordKeyVector::RecordKeyVector(Record * item, vecType *vec)
 : _key(item),
   _currPos(0)
 {
@@ -33,8 +33,10 @@ RecordKeyVector::RecordKeyVector(const Record * item, const vecType *vec)
 	_mustDeleteVec = true;
 }
 
-RecordKeyVector::~RecordKeyVector() {
-	if (_mustDeleteVec) {
+RecordKeyVector::~RecordKeyVector() 
+{
+	if (_mustDeleteVec) 
+	{
 		delete _recVec;
 		_recVec = NULL;
 		_mustDeleteVec = false;
@@ -48,21 +50,27 @@ const RecordKeyVector &RecordKeyVector::operator=(const RecordKeyVector &other)
 	return *this;
 }
 
-RecordKeyVector::const_iterator_type RecordKeyVector::begin()  {
+RecordKeyVector::iterator_type RecordKeyVector::begin()  {
 	_currPos = 0;
 	return _recVec->begin();
 }
 
-RecordKeyVector::const_iterator_type RecordKeyVector::next()  {
+RecordKeyVector::iterator_type RecordKeyVector::next()  {
 	_currPos++;
 	return _recVec->begin() + _currPos;
 }
 
 
-RecordKeyVector::const_iterator_type RecordKeyVector::end() {
+RecordKeyVector::iterator_type RecordKeyVector::end() {
 	return _recVec->end();
 }
 
+void RecordKeyVector::erase()  
+{
+	delete _recVec->at(_currPos);
+	_recVec->erase (_recVec->begin() + _currPos);
+}
+
 size_t RecordKeyVector::size() const {
 	return _recVec->size();
 }
@@ -75,7 +83,7 @@ void RecordKeyVector::push_back(elemType item) {
 	_recVec->push_back(item);
 }
 
-const Record *RecordKeyVector::getKey() const {
+Record * RecordKeyVector::getKey() const {
 	return _key;
 }
 
@@ -90,6 +98,10 @@ void RecordKeyVector::setVector(vecType *vec) {
 
 void RecordKeyVector::clearVector() {
 	_currPos = 0;
+	//for (vecType::iterator it = _recVec->begin() ; it != _recVec->end(); ++it)
+    //{
+    //	delete *it;
+    //}
 	_recVec->clear();
 }
 
diff --git a/src/utils/FileRecordTools/Records/RecordKeyVector.h b/src/utils/FileRecordTools/Records/RecordKeyVector.h
index 36ef1db..f41511b 100644
--- a/src/utils/FileRecordTools/Records/RecordKeyVector.h
+++ b/src/utils/FileRecordTools/Records/RecordKeyVector.h
@@ -17,18 +17,19 @@ using namespace std;
 
 class RecordKeyVector {
 public:
-	typedef const Record * elemType;
-	typedef vector<const Record *> vecType;
-	typedef vecType::const_iterator const_iterator_type;
+	typedef Record * elemType;
+	typedef vector<Record *> vecType;
+	typedef vecType::iterator iterator_type;
 	RecordKeyVector();
     RecordKeyVector(elemType item);
-    RecordKeyVector(elemType item, const vecType *vector);
+    RecordKeyVector(elemType item, vecType *vector);
     ~RecordKeyVector();
 
     const RecordKeyVector &operator=(const RecordKeyVector &other);
-    const_iterator_type begin();
-    const_iterator_type next();
-    const_iterator_type end();
+    iterator_type begin();
+    iterator_type next();
+    iterator_type end();
+    void erase();
     size_t size() const ;
     bool empty() const ; //only checks whether list is empty. Doesn't check key.
     void push_back(elemType item);
diff --git a/src/utils/FileRecordTools/Records/RecordList.cpp b/src/utils/FileRecordTools/Records/RecordList.cpp
index 142706f..fc0a0fe 100644
--- a/src/utils/FileRecordTools/Records/RecordList.cpp
+++ b/src/utils/FileRecordTools/Records/RecordList.cpp
@@ -73,7 +73,7 @@ RecordListNode *RecordList::deleteCurrent() {
 	return returnNode;
 }
 
-void RecordList::push_back(const Record * &val) {
+void RecordList::push_back(Record * &val) {
 	RecordListNode *newNode = new RecordListNode(val);
 	if (empty()) {
 		_begin = newNode;
@@ -89,6 +89,7 @@ void RecordList::push_back(const Record * &val) {
 
 
 void RecordList::clear() {
+        _size = 0;
 	if (_dontDelete) {
 		return;
 	}
@@ -105,7 +106,7 @@ void RecordList::clear() {
 	_size = 0;
 }
 
-const RecordList &RecordList::operator=(const RecordList &other) {
+RecordList &RecordList::operator=(const RecordList &other) {
 	//need to make copies of all nodes and assign values
 	clear();
 
diff --git a/src/utils/FileRecordTools/Records/RecordList.h b/src/utils/FileRecordTools/Records/RecordList.h
index e1b24b5..859fab4 100644
--- a/src/utils/FileRecordTools/Records/RecordList.h
+++ b/src/utils/FileRecordTools/Records/RecordList.h
@@ -26,7 +26,7 @@
 
 
 #include "FreeList.h"
-#include "QuickString.h"
+#include "string.h"
 #include <cstring> //for memset
 #include "Record.h"
 
@@ -35,8 +35,8 @@ public:
 	friend class RecordList;
 
 	RecordListNode() : _next(NULL){}
-	RecordListNode(const Record * val) : _val(val), _next(NULL) {}
-	const Record * value() const { return _val; }
+	RecordListNode(Record * val) : _val(val), _next(NULL) {}
+	Record * value() const { return _val; }
 	const RecordListNode *next() const { return _next; }
 	RecordListNode *next() { return _next; }
 	bool hasNext() const { return _next != NULL; }
@@ -48,7 +48,7 @@ public:
 
 private:
 
-	const Record * _val;
+	Record * _val;
 	RecordListNode *_next;
 };
 
@@ -76,10 +76,10 @@ public:
 	const RecordListNode *end() const { return NULL; }
 
 	RecordListNode * deleteCurrent();
-	void push_back(const Record * &val);
+	void push_back(Record * &val);
 
 	void clear();
-	const RecordList &operator=(const RecordList &other);
+	RecordList &operator=(const RecordList &other);
 	void assignNoCopy(RecordList &other);
 
 	void sort() { mergeSort(&_begin); }
diff --git a/src/utils/FileRecordTools/Records/VcfRecord.cpp b/src/utils/FileRecordTools/Records/VcfRecord.cpp
index e5bd914..6af2920 100644
--- a/src/utils/FileRecordTools/Records/VcfRecord.cpp
+++ b/src/utils/FileRecordTools/Records/VcfRecord.cpp
@@ -44,52 +44,53 @@ bool VcfRecord::initFromFile(SingleLineDelimTextFileReader *fileReader)
 void VcfRecord::clear()
 {
 	BedPlusInterval::clear();
-	_varRef.release();
-	_varAlt.release();
+	_varRef.clear();
+	_varAlt.clear();
 }
 
-void VcfRecord::print(QuickString &outBuf) const {
+void VcfRecord::print(string &outBuf) const {
 	outBuf.append(_chrName);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_startPosStr);
 	printOtherFields(outBuf);
 }
 
-void VcfRecord::print(QuickString &outBuf, int start, int end) const {
+void VcfRecord::print(string &outBuf, int start, int end) const {
 	outBuf.append(_chrName);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_startPosStr);
 	printOtherFields(outBuf);
 }
 
-void VcfRecord::print(QuickString &outBuf, const QuickString & start, const QuickString & end) const {
+void VcfRecord::print(string &outBuf, const string & start, const string & end) const {
 	outBuf.append(_chrName);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_startPosStr);
 	printOtherFields(outBuf);
 
 }
 
-void VcfRecord::printNull(QuickString &outBuf) const {
+void VcfRecord::printNull(string &outBuf) const {
 	outBuf.append(".\t-1\t.");
-	for (int i= 2; i < _numPrintFields; i++) {
+	for (int i=3; i < _numPrintFields; i++) {
 		outBuf.append("\t.");
 	}
 }
 
-void VcfRecord::printOtherFields(QuickString &outBuf) const {
-	outBuf.append('\t');
+void VcfRecord::printOtherFields(string &outBuf) const {
+	outBuf.append("\t");
 	outBuf.append(_name);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_varRef);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_varAlt);
-	outBuf.append('\t');
+	outBuf.append("\t");
 	outBuf.append(_score);
+	outBuf.append("\t");
 	_plusFields.printFields(outBuf);
 }
 
-const QuickString &VcfRecord::getField(int fieldNum) const
+const string &VcfRecord::getField(int fieldNum) const
 {
 	//a request for any of the first six fields will retrieve
 	//chrom, start, name, varRef, varAlt, score,  in that order.
diff --git a/src/utils/FileRecordTools/Records/VcfRecord.h b/src/utils/FileRecordTools/Records/VcfRecord.h
index c140b69..410c40a 100644
--- a/src/utils/FileRecordTools/Records/VcfRecord.h
+++ b/src/utils/FileRecordTools/Records/VcfRecord.h
@@ -19,22 +19,22 @@ public:
 	VcfRecord() {}
 	virtual bool initFromFile(SingleLineDelimTextFileReader *);
 	virtual void clear();
-	void print(QuickString &outBuf) const;
-	void print(QuickString &outBuf, int start, int end) const;
-	void print(QuickString &outBuf, const QuickString & start, const QuickString & end) const;
-	virtual void printNull(QuickString &outBuf) const;
+	void print(string &outBuf) const;
+	void print(string &outBuf, int start, int end) const;
+	void print(string &outBuf, const string & start, const string & end) const;
+	virtual void printNull(string &outBuf) const;
 	virtual FileRecordTypeChecker::RECORD_TYPE getType() const { return FileRecordTypeChecker::VCF_RECORD_TYPE; }
 
-	virtual const QuickString &getField(int fieldNum) const;
+	virtual const string &getField(int fieldNum) const;
 	static bool isNumericField(int fieldNum);
 
 	virtual bool isZeroBased() const {return false;};
 protected:
-	QuickString _varRef;
-	QuickString _varAlt;
+	string _varRef;
+	string _varAlt;
 	static const int numFixedFields = 6;
 
-	void printOtherFields(QuickString &outBuf) const;
+	void printOtherFields(string &outBuf) const;
 };
 
 #endif /* VCFRECORD_H_ */
diff --git a/src/utils/GenomeFile/NewGenomeFile.cpp b/src/utils/GenomeFile/NewGenomeFile.cpp
index 53c9540..9ddbc20 100644
--- a/src/utils/GenomeFile/NewGenomeFile.cpp
+++ b/src/utils/GenomeFile/NewGenomeFile.cpp
@@ -13,7 +13,7 @@
 #include "ParseTools.h"
 #include "Tokenizer.h"
 
-NewGenomeFile::NewGenomeFile(const QuickString &genomeFilename)
+NewGenomeFile::NewGenomeFile(const string &genomeFilename)
 : _maxId(-1)
 {
     _genomeFileName = genomeFilename;
@@ -25,7 +25,7 @@ NewGenomeFile::NewGenomeFile(const BamTools::RefVector &refVector)
 {
 	size_t i = 0;
     for (; i < refVector.size(); ++i) {
-        QuickString chrom = refVector[i].RefName;
+        string chrom = refVector[i].RefName;
         CHRPOS length = refVector[i].RefLength;
         _maxId++;
         _chromSizeIds[chrom] = pair<CHRPOS, CHRPOS>(length, _maxId);
@@ -89,7 +89,7 @@ void NewGenomeFile::loadGenomeFileIntoMap() {
 	genFile.close();
 }
 
-bool NewGenomeFile::projectOnGenome(CHRPOS genome_pos, QuickString &chrom, CHRPOS &start) {
+bool NewGenomeFile::projectOnGenome(CHRPOS genome_pos, string &chrom, CHRPOS &start) {
     // search for the chrom that the position belongs on.
     // add 1 to genome position b/c of zero-based, half open.
     vector<CHRPOS>::const_iterator low =
@@ -106,7 +106,7 @@ bool NewGenomeFile::projectOnGenome(CHRPOS genome_pos, QuickString &chrom, CHRPO
     return true;
 }
     
-CHRPOS NewGenomeFile::getChromSize(const QuickString &chrom) {
+CHRPOS NewGenomeFile::getChromSize(const string &chrom) {
 	if (chrom == _currChromName) {
 		return _currChromSize;
 	}
@@ -121,7 +121,7 @@ CHRPOS NewGenomeFile::getChromSize(const QuickString &chrom) {
     return INT_MAX;
 }
 
-CHRPOS NewGenomeFile::getChromSize(const QuickString &chrom) const {
+CHRPOS NewGenomeFile::getChromSize(const string &chrom) const {
 	if (chrom == _currChromName) {
 		return _currChromSize;
 	}
@@ -133,7 +133,7 @@ CHRPOS NewGenomeFile::getChromSize(const QuickString &chrom) const {
     return INT_MAX;
 }
 
-CHRPOS NewGenomeFile::getChromId(const QuickString &chrom) {
+CHRPOS NewGenomeFile::getChromId(const string &chrom) {
 	if (chrom == _currChromName) {
 		return _currChromId;
 	}
diff --git a/src/utils/GenomeFile/NewGenomeFile.h b/src/utils/GenomeFile/NewGenomeFile.h
index 6d45fae..7d0a6c1 100644
--- a/src/utils/GenomeFile/NewGenomeFile.h
+++ b/src/utils/GenomeFile/NewGenomeFile.h
@@ -25,32 +25,32 @@ class NewGenomeFile {
 
 public:
 
-     NewGenomeFile(const QuickString &genomeFileName);
+     NewGenomeFile(const string &genomeFileName);
      NewGenomeFile(const BamTools::RefVector &genome);
     ~NewGenomeFile(void);
 
     // load a GENOME file into a map keyed by chrom. value is a pair<int, int> of id and size.
     void loadGenomeFileIntoMap();
     
-    bool projectOnGenome(CHRPOS genome_pos, QuickString &chrom, CHRPOS &start);
+    bool projectOnGenome(CHRPOS genome_pos, string &chrom, CHRPOS &start);
     
     CHRPOS getGenomeSize(void) const { return _genomeLength; }                // return the total size of the genome
-    CHRPOS getChromSize(const QuickString &chrom);  // return the size of a chromosome
-    CHRPOS getChromSize(const QuickString &chrom) const;  // return the size of a chromosome
-    CHRPOS getChromId(const QuickString &chrom); // return chromosome's sort order
-    const vector<QuickString> &getChromList() const { return _chromList; }  // return a list of chrom names
+    CHRPOS getChromSize(const string &chrom);  // return the size of a chromosome
+    CHRPOS getChromSize(const string &chrom) const;  // return the size of a chromosome
+    CHRPOS getChromId(const string &chrom); // return chromosome's sort order
+    const vector<string> &getChromList() const { return _chromList; }  // return a list of chrom names
     CHRPOS getNumberOfChroms() const { return _chromList.size() -1; }//the -1 excludes the blank chrom added for unmapped reads
-    const QuickString &getGenomeFileName() const { return _genomeFileName; }
-    bool hasChrom(const QuickString &chrom) const { return _chromSizeIds.find(chrom) != _chromSizeIds.end(); }
+    const string &getGenomeFileName() const { return _genomeFileName; }
+    bool hasChrom(const string &chrom) const { return _chromSizeIds.find(chrom) != _chromSizeIds.end(); }
 
 
 
 
 private:
-    QuickString  _genomeFileName;
-    typedef map<QuickString, pair<CHRPOS, int> > lookupType;
+    string  _genomeFileName;
+    typedef map<string, pair<CHRPOS, int> > lookupType;
     lookupType _chromSizeIds;
-    vector<QuickString> _chromList;
+    vector<string> _chromList;
     int _maxId;
 
     // projecting chroms onto a single coordinate system
@@ -58,7 +58,7 @@ private:
     vector<CHRPOS> _startOffsets;
     
     //cache members for quick lookup
-    QuickString _currChromName;
+    string _currChromName;
     CHRPOS _currChromSize;
     int _currChromId;
 
diff --git a/src/utils/KeyListOps/KeyListOps.cpp b/src/utils/KeyListOps/KeyListOps.cpp
index 8e184c8..c329062 100644
--- a/src/utils/KeyListOps/KeyListOps.cpp
+++ b/src/utils/KeyListOps/KeyListOps.cpp
@@ -74,14 +74,14 @@ bool KeyListOps::isNumericOp(OP_TYPES op) const {
 	return (iter == _isNumericOp.end() ? false : iter->second);
 }
 
-bool KeyListOps::isNumericOp(const QuickString &op) const {
+bool KeyListOps::isNumericOp(const string &op) const {
 	return isNumericOp(getOpCode(op));
 }
 
-KeyListOps::OP_TYPES KeyListOps::getOpCode(const QuickString &operation) const {
+KeyListOps::OP_TYPES KeyListOps::getOpCode(const string &operation) const {
 	//If the operation does not exist, return INVALID.
 	//otherwise, return code for given operation.
-	map<QuickString, OP_TYPES>::const_iterator iter = _opCodes.find(operation);
+	map<string, OP_TYPES>::const_iterator iter = _opCodes.find(operation);
 	if (iter == _opCodes.end()) {
 		return INVALID;
 	}
@@ -132,7 +132,7 @@ bool KeyListOps::isValidColumnOps(FileRecordMgr *dbFile) {
 					 << dbFile->getFileName() << " only has fields 1 - " << dbFile->getNumFields() << "." << endl;
 			 return false;
 		}
-		const QuickString &operation = opsTokens.getElem(numOps > 1 ? i : 0);
+		const string &operation = opsTokens.getElem(numOps > 1 ? i : 0);
 		OP_TYPES opCode = getOpCode(operation);
 		if (opCode == INVALID) {
 			cerr << endl << "*****" << endl
@@ -160,7 +160,7 @@ bool KeyListOps::isValidColumnOps(FileRecordMgr *dbFile) {
     return true;
 }
 
-const QuickString & KeyListOps::getOpVals(RecordKeyVector &hits)
+const string & KeyListOps::getOpVals(RecordKeyVector &hits)
 {
 	//loop through all requested columns, and for each one, call the method needed
 	//for the operation specified.
@@ -168,6 +168,7 @@ const QuickString & KeyListOps::getOpVals(RecordKeyVector &hits)
 	_outVals.clear();
 	double val = 0.0;
 	for (int i=0; i < (int)_colOps.size(); i++) {
+		ostringstream s;
 		int col = _colOps[i].first;
 		OP_TYPES opCode = _colOps[i].second;
 
@@ -176,138 +177,138 @@ const QuickString & KeyListOps::getOpVals(RecordKeyVector &hits)
 		case SUM:
 			val = _methods.getSum();
 			if (isnan(val)) {
-				_outVals.append(_methods.getNullValue());
+				s << _methods.getNullValue();
 			} else {
-				_outVals.append(format(val));
+				s << format(val);
 			}
 			break;
 
 		case MEAN:
 			val = _methods.getMean();
 			if (isnan(val)) {
-				_outVals.append(_methods.getNullValue());
+				s << _methods.getNullValue();
 			} else {
-				_outVals.append(format(val));
+				s << format(val);
 			}
 			break;
 
 		case STDDEV:
 			val = _methods.getStddev();
 			if (isnan(val)) {
-				_outVals.append(_methods.getNullValue());
+				s << _methods.getNullValue();
 			} else {
-				_outVals.append(format(val));
+				s << format(val);
 			}
 			break;
 
 		case SAMPLE_STDDEV:
 			val = _methods.getSampleStddev();
 			if (isnan(val)) {
-				_outVals.append(_methods.getNullValue());
+				s << _methods.getNullValue();
 			} else {
-				_outVals.append(format(val));
+				s << format(val);
 			}
 			break;
 
 		case MEDIAN:
 			val = _methods.getMedian();
 			if (isnan(val)) {
-				_outVals.append(_methods.getNullValue());
+				s << _methods.getNullValue();
 			} else {
-				_outVals.append(format(val));
+				s << format(val);
 			}
 			break;
 
 		case MODE:
-			_outVals.append(_methods.getMode());
+			s << _methods.getMode();
 			break;
 
 		case ANTIMODE:
-			_outVals.append(_methods.getAntiMode());
+			s << _methods.getAntiMode();
 			break;
 
 		case MIN:
 			val = _methods.getMin();
 			if (isnan(val)) {
-				_outVals.append(_methods.getNullValue());
+				s << _methods.getNullValue();
 			} else {
-				_outVals.append(format(val));
+				s << format(val);
 			}
 			break;
 
 		case MAX:
 			val = _methods.getMax();
 			if (isnan(val)) {
-				_outVals.append(_methods.getNullValue());
+				s << _methods.getNullValue();
 			} else {
-				_outVals.append(format(val));
+				s << format(val);
 			}
 			break;
 
 		case ABSMIN:
 			val = _methods.getAbsMin();
 			if (isnan(val)) {
-				_outVals.append(_methods.getNullValue());
+				s << _methods.getNullValue();
 			} else {
-				_outVals.append(format(val));
+				s << format(val);
 			}
 			break;
 
 		case ABSMAX:
 			val = _methods.getAbsMax();
 			if (isnan(val)) {
-				_outVals.append(_methods.getNullValue());
+				s << _methods.getNullValue();
 			} else {
-				_outVals.append(format(val));
+				s << format(val);
 			}
 			break;
 
 		case COUNT:
-			_outVals.append(_methods.getCount());
+			s << _methods.getCount();
 			break;
 
 		case DISTINCT:
-			_outVals.append(_methods.getDistinct());
+			s << _methods.getDistinct();
 			break;
 
 		case DISTINCT_SORT_NUM:
-			_outVals.append(_methods.getDistinctSortNum());
+			s << _methods.getDistinctSortNum();
 			break;
 
 		case DISTINCT_SORT_NUM_DESC:
-			_outVals.append(_methods.getDistinctSortNum(false));
+			s << _methods.getDistinctSortNum(false);
 			break;
 
 		case COUNT_DISTINCT:
-			_outVals.append(_methods.getCountDistinct());
+			s << _methods.getCountDistinct();
 			break;
 
 		case DISTINCT_ONLY:
-			_outVals.append(_methods.getDistinctOnly());
+			s << _methods.getDistinctOnly();
 			break;
 
 		case COLLAPSE:
-			_outVals.append(_methods.getCollapse());
+			s << _methods.getCollapse();
 			break;
 
 		case CONCAT:
-			_outVals.append(_methods.getConcat());
+			s << _methods.getConcat();
 			break;
 
 		case FREQ_ASC:
-			_outVals.append(_methods.getFreqAsc());
+			s << _methods.getFreqAsc();
 			break;
 
 		case FREQ_DESC:
-			_outVals.append(_methods.getFreqDesc());
+			s << _methods.getFreqDesc();
 			break;
 
 		case FIRST:
-			_outVals.append(_methods.getFirst());
+			s << _methods.getFirst();
 			break;
 
 		case LAST:
-			_outVals.append(_methods.getLast());
+			s << _methods.getLast();
 			break;
 
 		case INVALID:
@@ -318,9 +319,10 @@ const QuickString & KeyListOps::getOpVals(RecordKeyVector &hits)
 			cerr << "ERROR: Invalid operation given for column " << col << ". Exiting..." << endl;
 			break;
 		}
+		_outVals.append(s.str());
 		//if this isn't the last column, add a tab.
 		if (i < (int)_colOps.size() -1) {
-			_outVals.append('\t');
+			_outVals.append("\t");
 		}
 	}
 	if (_methods.nonNumErrFlagSet()) {
@@ -331,7 +333,7 @@ const QuickString & KeyListOps::getOpVals(RecordKeyVector &hits)
 	return _outVals;
 }
 
-const QuickString &KeyListOps::format(double val)
+const string &KeyListOps::format(double val)
 {
    std::stringstream strmBuf;
    strmBuf << std::setprecision (_precision) << val;
diff --git a/src/utils/KeyListOps/KeyListOps.h b/src/utils/KeyListOps/KeyListOps.h
index b6d4949..3e899e5 100644
--- a/src/utils/KeyListOps/KeyListOps.h
+++ b/src/utils/KeyListOps/KeyListOps.h
@@ -21,24 +21,24 @@ public:
 
 	KeyListOps();
 
-	void setColumns(const QuickString &columns) { _columns = columns; }
-	void addColumns(const QuickString &newCols) {
+	void setColumns(const string &columns) { _columns = columns; }
+	void addColumns(const string &newCols) {
 		if (!_columns.empty()) _columns += ",";
 		_columns += newCols;
 	}
-	void setOperations(const QuickString & operation) { _operations = operation; }
-	void addOperations(const QuickString &newOps) {
+	void setOperations(const string & operation) { _operations = operation; }
+	void addOperations(const string &newOps) {
 		if (!_operations.empty()) _operations += ",";
 		_operations += newOps;
 	}
 
-	void setNullValue(const QuickString & nullValue) { _methods.setNullValue(nullValue); }
-	void setDelimStr(const QuickString & delimStr) { _methods.setDelimStr(delimStr); }
+	void setNullValue(const string & nullValue) { _methods.setNullValue(nullValue); }
+	void setDelimStr(const string & delimStr) { _methods.setDelimStr(delimStr); }
 
-	const QuickString &getColumns() { return _columns; }
-	const QuickString &getOperations() { return _operations; }
-	const QuickString &getNullValue() { return _methods.getNullValue(); }
-	const QuickString &getDelimStr() { return _methods.getDelimStr(); }
+	const string &getColumns() { return _columns; }
+	const string &getOperations() { return _operations; }
+	const string &getNullValue() { return _methods.getNullValue(); }
+	const string &getDelimStr() { return _methods.getDelimStr(); }
 
 	void setKeyList(RecordKeyVector *keyList) { _methods.setKeyList(keyList); }
 
@@ -48,32 +48,32 @@ public:
 	void setDBfileType(FileRecordTypeChecker::FILE_TYPE type) { _dbFileType = type; }
 	bool isValidColumnOps(FileRecordMgr *dbFile);
 
-	const QuickString &getOpVals(RecordKeyVector &hits);
+	const string &getOpVals(RecordKeyVector &hits);
 	void setPrecision(int val) { _precision = val; }
 
 private:
     void init();
     FileRecordTypeChecker::FILE_TYPE _dbFileType;
 
-    QuickString _operations;
-    QuickString _columns;
+    string _operations;
+    string _columns;
 
 	KeyListOpsMethods _methods;
-	map<QuickString, OP_TYPES> _opCodes;
+	map<string, OP_TYPES> _opCodes;
 	map<OP_TYPES, bool> _isNumericOp;
 
     typedef vector<pair<int, OP_TYPES> > colOpsType;
     colOpsType _colOps;
-    QuickString _outVals;
+    string _outVals;
 
-    QuickString _formatStr;
+    string _formatStr;
     int _precision;
 
     static const int DEFAULT_PRECISION = 10;
-    OP_TYPES getOpCode(const QuickString &operation) const;
+    OP_TYPES getOpCode(const string &operation) const;
     bool isNumericOp(OP_TYPES op) const;
-    bool isNumericOp(const QuickString &op) const;
-    const QuickString &format(double val);
+    bool isNumericOp(const string &op) const;
+    const string &format(double val);
 
 };
 
diff --git a/src/utils/KeyListOps/KeyListOpsMethods.cpp b/src/utils/KeyListOps/KeyListOpsMethods.cpp
index f46f76e..6bb3a35 100644
--- a/src/utils/KeyListOps/KeyListOpsMethods.cpp
+++ b/src/utils/KeyListOps/KeyListOpsMethods.cpp
@@ -8,6 +8,7 @@
 #include "KeyListOpsMethods.h"
 #include <cmath>
 #include <algorithm>
+#include <limits.h>
 #include "ParseTools.h" //to get the isNumeric function
 
 KeyListOpsMethods::KeyListOpsMethods()
@@ -100,7 +101,7 @@ double KeyListOpsMethods::getMedian() {
 }
 
 // return the most common value in the vector
-const QuickString &KeyListOpsMethods::getMode() {
+const string &KeyListOpsMethods::getMode() {
 	if (empty()) return _nullVal;
 
 	makeFreqMap();
@@ -118,7 +119,7 @@ const QuickString &KeyListOpsMethods::getMode() {
 	return _retStr;
 }
 // return the least common value in the vector
-const QuickString &KeyListOpsMethods::getAntiMode() {
+const string &KeyListOpsMethods::getAntiMode() {
 	if (empty()) return _nullVal;
 
 	makeFreqMap();
@@ -190,7 +191,7 @@ uint32_t KeyListOpsMethods::getCount() {
 	return _keyList->size();
 }
 // return a delimited list of the unique elements
-const QuickString &KeyListOpsMethods::getDistinct() {
+const string &KeyListOpsMethods::getDistinct() {
 	if (empty()) return _nullVal;
 	// separated list of unique values. If something repeats, only report once.
 	makeFreqMap();
@@ -202,7 +203,7 @@ const QuickString &KeyListOpsMethods::getDistinct() {
 	return _retStr;
 }
 
-const QuickString &KeyListOpsMethods::getDistinctOnly() {
+const string &KeyListOpsMethods::getDistinctOnly() {
 	if (empty()) return _nullVal;
 	// separated list of unique values. If something repeats, don't report.
 	makeFreqMap();
@@ -215,15 +216,17 @@ const QuickString &KeyListOpsMethods::getDistinctOnly() {
 	return _retStr;
 }
 
-const QuickString &KeyListOpsMethods::getDistinctSortNum(bool asc) {
+const string &KeyListOpsMethods::getDistinctSortNum(bool asc) {
 	toArray(true, asc ? ASC : DESC);
 	vector<double>::iterator endIter = std::unique(_numArray.begin(), _numArray.end());
 
 	_retStr.clear();
+	ostringstream s;
 	for (vector<double>::iterator iter = _numArray.begin(); iter != endIter; iter++) {
 		if (iter != _numArray.begin()) _retStr += _delimStr;
-		_retStr.append(*iter);
+		s << *iter;
 	}
+	_retStr.append(s.str());
 	return  _retStr;
 
 }
@@ -238,7 +241,7 @@ uint32_t KeyListOpsMethods::getCountDistinct() {
 }
 
 // return a delimiter-separated list of elements
-const QuickString &KeyListOpsMethods::getCollapse(const QuickString &delimiter) {
+const string &KeyListOpsMethods::getCollapse(const string &delimiter) {
 	if (empty()) return _nullVal;
 
 	//just put all items in one big separated list.
@@ -253,13 +256,13 @@ const QuickString &KeyListOpsMethods::getCollapse(const QuickString &delimiter)
 }
 
 // return a concatenation of all elements in the vector
-const QuickString &KeyListOpsMethods::getConcat() {
+const string &KeyListOpsMethods::getConcat() {
 	if (empty()) return _nullVal;
 
 	//like collapse but w/o commas. Just a true concat of all vals.
 	//just swap out the delimChar with '' and call collapse, then
 	//restore the delimChar.
-	QuickString oldDelimStr(_delimStr);
+	string oldDelimStr(_delimStr);
 	_delimStr = "";
 	getCollapse(); //this will store it's results in the _retStr method.
 	_delimStr = oldDelimStr;
@@ -267,7 +270,7 @@ const QuickString &KeyListOpsMethods::getConcat() {
 }
 
 // return a histogram of values and their freqs. in desc. order of frequency
-const QuickString &KeyListOpsMethods::getFreqDesc() {
+const string &KeyListOpsMethods::getFreqDesc() {
 	if (empty()) return _nullVal;
 
 	//for each uniq val, report # occurances, in desc order.
@@ -275,20 +278,22 @@ const QuickString &KeyListOpsMethods::getFreqDesc() {
 	//put freq map into multimap where key is the freq and val is the item. In other words, basically a reverse freq map.
 	histDescType hist;
 	for (; _freqIter != _freqMap.end(); _freqIter++) {
-		hist.insert(pair<int, QuickString>(_freqIter->second, _freqIter->first));
+		hist.insert(pair<int, string>(_freqIter->second, _freqIter->first));
 	}
 	//now iterate through the reverse map we just made and output it's pairs in val:key format.
 	_retStr.clear();
+	ostringstream s;
 	for (histDescType::iterator histIter = hist.begin(); histIter != hist.end(); histIter++) {
 		if (histIter != hist.begin()) _retStr += _delimStr;
-		_retStr.append(histIter->second);
-		_retStr += ":";
-		_retStr.append(histIter->first);
+		s << histIter->second;
+		s << ":";
+		s << histIter->first;
 	}
+	_retStr.append(s.str());
 	return _retStr;
 }
 // return a histogram of values and their freqs. in asc. order of frequency
-const QuickString &KeyListOpsMethods::getFreqAsc() {
+const string &KeyListOpsMethods::getFreqAsc() {
 	if (empty()) return _nullVal;
 
 	//for each uniq val, report # occurances, in asc order.
@@ -296,21 +301,23 @@ const QuickString &KeyListOpsMethods::getFreqAsc() {
 	//put freq map into multimap where key is the freq and val is the item. In other words, basically a reverse freq map.
 	histAscType hist;
 	for (; _freqIter != _freqMap.end(); _freqIter++) {
-		hist.insert(pair<int, QuickString>(_freqIter->second, _freqIter->first));
+		hist.insert(pair<int, string>(_freqIter->second, _freqIter->first));
 //		hist[*(_freqIter->second)] = _freqIter->first;
 	}
 	//now iterate through the reverse map we just made and output it's pairs in val:key format.
 	_retStr.clear();
+	ostringstream s;
 	for (histAscType::iterator histIter = hist.begin(); histIter != hist.end(); histIter++) {
 		if (histIter != hist.begin()) _retStr += _delimStr;
-		_retStr.append(histIter->second);
-		_retStr += ":";
-		_retStr.append(histIter->first);
+		s << histIter->second;
+		s << ":";
+		s << histIter->first;
 	}
+	_retStr.append(s.str());
 	return _retStr;
 }
 // return the first value in the list
-const QuickString &KeyListOpsMethods::getFirst() {
+const string &KeyListOpsMethods::getFirst() {
 	if (empty()) return _nullVal;
 
 	//just the first item.
@@ -318,7 +325,7 @@ const QuickString &KeyListOpsMethods::getFirst() {
 	return getColVal();
 }
 // return the last value in the list
-const QuickString &KeyListOpsMethods::getLast() {
+const string &KeyListOpsMethods::getLast() {
 	if (empty()) return _nullVal;
 
 	//just the last item.
@@ -329,21 +336,23 @@ const QuickString &KeyListOpsMethods::getLast() {
 	return getColVal();
 }
 
-const QuickString &KeyListOpsMethods::getColVal() {
-	const QuickString &retVal = (*_iter)->getField(_column);
+const string &KeyListOpsMethods::getColVal() {
+	const string &retVal = (*_iter)->getField(_column);
 	if (_isBam && retVal.empty()) return _nullVal;
 	return retVal;
 }
 
 double KeyListOpsMethods::getColValNum() {
-	const QuickString &strVal = (*_iter)->getField(_column);
+	const string &strVal = (*_iter)->getField(_column);
 	if (!isNumeric(strVal)) {
 		_nonNumErrFlag = true;
+		ostringstream s;
 		_errMsg = " ***** WARNING: Non numeric value ";
-		_errMsg.append(strVal);
-		_errMsg.append(" in ");
-		_errMsg.append(_column);
-		_errMsg.append(".");
+		s << strVal;
+		s << " in ";
+		s << _column;
+		s << ".";
+		_errMsg.append(s.str());
 		return NAN;
 	}
 	return atof(strVal.c_str());
@@ -382,9 +391,9 @@ void KeyListOpsMethods::sortArray(bool useNum, bool ascOrder)
 		}
 	} else {
 		if (ascOrder) {
-			sort(_qsArray.begin(), _qsArray.end(), less<QuickString>());
+			sort(_qsArray.begin(), _qsArray.end(), less<string>());
 		} else {
-			sort(_qsArray.begin(), _qsArray.end(), greater<QuickString>());
+			sort(_qsArray.begin(), _qsArray.end(), greater<string>());
 		}
 	}
 }
diff --git a/src/utils/KeyListOps/KeyListOpsMethods.h b/src/utils/KeyListOps/KeyListOpsMethods.h
index 1d0c963..d1eea62 100644
--- a/src/utils/KeyListOps/KeyListOpsMethods.h
+++ b/src/utils/KeyListOps/KeyListOpsMethods.h
@@ -10,7 +10,7 @@
 
 #include <map>
 #include <utility> //for pair
-#include "QuickString.h"
+#include "string.h"
 #include <stdint.h>
 #include "RecordKeyVector.h"
 
@@ -25,10 +25,10 @@ public:
 	void setIsBam(bool isBam) { _isBam = isBam; }
 	void setKeyList(RecordKeyVector *keyList) { _keyList = keyList; }
 	void setColumn(int col) { _column = col; }
-	void setNullValue(const QuickString & nullVal) { _nullVal = nullVal; }
-	const QuickString &getNullValue() const { return _nullVal; }
-	void setDelimStr(const QuickString &delimStr) { _delimStr = delimStr; }
-	const QuickString &getDelimStr() const { return _delimStr; }
+	void setNullValue(const string & nullVal) { _nullVal = nullVal; }
+	const string &getNullValue() const { return _nullVal; }
+	void setDelimStr(const string &delimStr) { _delimStr = delimStr; }
+	const string &getDelimStr() const { return _delimStr; }
 
     // return the total of the values in the vector
     double getSum();
@@ -41,9 +41,9 @@ public:
     // return the median value in the vector
     double getMedian();
     // return the most common value in the vector
-    const QuickString &getMode();
+    const string &getMode();
     // return the least common value in the vector
-    const QuickString &getAntiMode();
+    const string &getAntiMode();
     // return the minimum element of the vector
     double getMin();
     // return the maximum element of the vector
@@ -57,29 +57,29 @@ public:
     // return a the count of _unique_ elements in the vector
     uint32_t getCountDistinct();
     // return only those elements that occur once
-    const QuickString &getDistinctOnly();
+    const string &getDistinctOnly();
     // as distinct, but sorted numerically.
-    const QuickString &getDistinctSortNum(bool ascending = true);
+    const string &getDistinctSortNum(bool ascending = true);
     // as distinct, but sorted numerically, descending
 
 
      // return a delimiter-separated list of elements
-    const QuickString & getCollapse(const QuickString & delimiter = ",");
+    const string & getCollapse(const string & delimiter = ",");
     // return a concatenation of all elements in the vector
-    const QuickString & getConcat();
+    const string & getConcat();
     // return a comma-separated list of the _unique_ elements
-    const QuickString & getDistinct();
+    const string & getDistinct();
     // return a histogram of values and their freqs. in desc. order of frequency
-    const QuickString & getFreqDesc();
+    const string & getFreqDesc();
     // return a histogram of values and their freqs. in asc. order of frequency
-    const QuickString & getFreqAsc();
+    const string & getFreqAsc();
     // return the first value in the list
-    const QuickString & getFirst();
+    const string & getFirst();
     // return the last value in the list
-    const QuickString & getLast();
+    const string & getLast();
 
     bool nonNumErrFlagSet() const { return _nonNumErrFlag; }
-    const QuickString &getErrMsg() const { return _errMsg; }
+    const string &getErrMsg() const { return _errMsg; }
     void resetNonNumErrFlag() {
     	_nonNumErrFlag = false;
     	_errMsg.clear();
@@ -88,31 +88,31 @@ public:
 private:
 	RecordKeyVector *_keyList;
 	int _column;
-	QuickString _nullVal;
-	QuickString _delimStr;
-	QuickString _retStr;
+	string _nullVal;
+	string _delimStr;
+	string _retStr;
 
 	RecordKeyVector _nullKeyList; //this has to exist just so we can initialize _iter, below.
-	RecordKeyVector::const_iterator_type _iter;
+	RecordKeyVector::iterator_type _iter;
 
 	// Some methods need to put values into a vector, mostly for sorting.
 	vector<double> _numArray;
-	vector<QuickString> _qsArray;
+	vector<string> _qsArray;
 
-	typedef map<QuickString, int> freqMapType;
+	typedef map<string, int> freqMapType;
 	freqMapType _freqMap;
 	freqMapType::iterator _freqIter;
 
 	typedef enum { UNSORTED, ASC, DESC} SORT_TYPE;
 
 	bool _nonNumErrFlag;
-	QuickString _errMsg;
+	string _errMsg;
 	bool _isBam;
 
-	typedef multimap<int, QuickString, less<int> > histAscType;
-	typedef multimap<int, QuickString, greater<int> > histDescType;
+	typedef multimap<int, string, less<int> > histAscType;
+	typedef multimap<int, string, greater<int> > histDescType;
 	void init();
-	const QuickString &getColVal();
+	const string &getColVal();
 	double getColValNum();
 	bool empty() { return _keyList->empty(); }
 	void begin() { _iter = _keyList->begin(); }
diff --git a/src/utils/NewChromsweep/CloseSweep.cpp b/src/utils/NewChromsweep/CloseSweep.cpp
index 171a87a..06c4d17 100644
--- a/src/utils/NewChromsweep/CloseSweep.cpp
+++ b/src/utils/NewChromsweep/CloseSweep.cpp
@@ -48,7 +48,7 @@ void RecDistList::clear() {
 	_totalRecs = 0;
 }
 
-bool RecDistList::addRec(int dist, const Record *record, chromDirType chromDir) {
+bool RecDistList::addRec(int dist, Record *record, chromDirType chromDir) {
 	int newPos = 0;
 	bool mustAppend = false;
 	int useElemIdx = 0;
@@ -313,7 +313,7 @@ void CloseSweep::scanCache(int dbIdx, RecordKeyVector &retList) {
 	recListIterType cacheIter = _caches[dbIdx].begin();
     while (cacheIter != _caches[dbIdx].end())
     {
-    	const Record *cacheRec = cacheIter->value();
+        Record *cacheRec = cacheIter->value();
     	bool stopScanning = false;
     	if (considerRecord(cacheRec, dbIdx, stopScanning) == DELETE) {
             cacheIter = _caches[dbIdx].deleteCurrent();
@@ -326,7 +326,7 @@ void CloseSweep::scanCache(int dbIdx, RecordKeyVector &retList) {
 }
 
 
-CloseSweep::rateOvlpType CloseSweep::considerRecord(const Record *cacheRec, int dbIdx, bool &stopScanning) {
+CloseSweep::rateOvlpType CloseSweep::considerRecord(Record *cacheRec, int dbIdx, bool &stopScanning) {
 
 	// Determine whether the hit and query intersect, and if so, what to do about it.
 	_dbForward = cacheRec->getStrandVal() == Record::FORWARD;
@@ -466,7 +466,7 @@ void CloseSweep::finalizeSelections(int dbIdx, RecordKeyVector &retList) {
 
 
 
-int CloseSweep::addRecsToRetList(const RecDistList::elemsType *recs, int currDist, RecordKeyVector &retList) {
+int CloseSweep::addRecsToRetList(RecDistList::elemsType *recs, int currDist, RecordKeyVector &retList) {
 
 	int hitsUsed = 0;
 	int numRecs = (int)recs->size(); //just to clean the code some.
@@ -489,7 +489,7 @@ int CloseSweep::addRecsToRetList(const RecDistList::elemsType *recs, int currDis
 	}
 }
 
-void CloseSweep::addSingleRec(const Record *rec, int currDist, int &hitsUsed, RecordKeyVector &retList) {
+void CloseSweep::addSingleRec(Record *rec, int currDist, int &hitsUsed, RecordKeyVector &retList) {
 	retList.push_back(rec);
 	_finalDistances.push_back(currDist);
 	hitsUsed++;
@@ -511,7 +511,7 @@ void CloseSweep::checkMultiDbs(RecordKeyVector &retList) {
 	int numHits = (int)retList.size();
 	copyDists.resize(numHits);
 	int i=0;
-	for (RecordKeyVector::const_iterator_type iter = retList.begin(); iter != retList.end(); iter++) {
+	for (RecordKeyVector::iterator_type iter = retList.begin(); iter != retList.end(); iter++) {
 		int dist = _finalDistances[i];
 		copyDists[i]._dist = abs(dist);
 		copyDists[i]._rec = *iter;
@@ -575,7 +575,7 @@ void CloseSweep::checkMultiDbs(RecordKeyVector &retList) {
 
 bool CloseSweep::chromChange(int dbIdx, RecordKeyVector &retList, bool wantScan)
 {
-	const Record *dbRec = _currDbRecs[dbIdx];
+	Record *dbRec = _currDbRecs[dbIdx];
 
 	bool haveQuery = _currQueryRec != NULL;
 	bool haveDB = dbRec != NULL;
@@ -615,14 +615,14 @@ bool CloseSweep::chromChange(int dbIdx, RecordKeyVector &retList, bool wantScan)
 
 	// the query is ahead of the database. fast-forward the database to catch-up.
 	if (queryChromAfterDbRec(dbRec)) {
-		QuickString oldDbChrom(dbRec->getChrName());
+		string oldDbChrom(dbRec->getChrName());
 
 		while (dbRec != NULL &&
 				queryChromAfterDbRec(dbRec)) {
 			_dbFRMs[dbIdx]->deleteRecord(dbRec);
 			if (!nextRecord(false, dbIdx)) break;
 			dbRec =  _currDbRecs[dbIdx];
-			const QuickString &newDbChrom = dbRec->getChrName();
+			const string &newDbChrom = dbRec->getChrName();
 			if (newDbChrom != oldDbChrom) {
 				testChromOrder(dbRec);
 				oldDbChrom = newDbChrom;
@@ -683,7 +683,7 @@ void CloseSweep::setLeftClosestEndPos(int dbIdx)
 	}
 }
 
-bool CloseSweep::beforeLeftClosestEndPos(int dbIdx, const Record *rec)
+bool CloseSweep::beforeLeftClosestEndPos(int dbIdx, Record *rec)
 {
 	int recEndPos = rec->getEndPos();
 	int prevPos = _maxPrevLeftClosestEndPos[dbIdx];
@@ -708,7 +708,7 @@ void CloseSweep::clearClosestEndPos(int dbIdx)
 	_maxPrevLeftClosestEndPosReverse[dbIdx] = 0;
 }
 
-CloseSweep::rateOvlpType CloseSweep::tryToAddRecord(const Record *cacheRec, int dist, int dbIdx, bool &stopScanning, chromDirType chromDir, streamDirType streamDir) {
+CloseSweep::rateOvlpType CloseSweep::tryToAddRecord(Record *cacheRec, int dist, int dbIdx, bool &stopScanning, chromDirType chromDir, streamDirType streamDir) {
 
 	//
 	// Decide whether to ignore hit
diff --git a/src/utils/NewChromsweep/CloseSweep.h b/src/utils/NewChromsweep/CloseSweep.h
index 2627562..8165cbe 100644
--- a/src/utils/NewChromsweep/CloseSweep.h
+++ b/src/utils/NewChromsweep/CloseSweep.h
@@ -17,10 +17,10 @@
 class distanceTuple {
 public:
 	distanceTuple() : _dist(0), _rec(NULL), _isNeg(false) {}
-	distanceTuple(int dist, const Record *rec, bool isNeg = false) : _dist(dist), _rec(rec), _isNeg(isNeg) {}
+	distanceTuple(int dist, Record *rec, bool isNeg = false) : _dist(dist), _rec(rec), _isNeg(isNeg) {}
 //	bool operator < (const distanceTuple & other) const { return (_dist < other._dist); }
 	int _dist;
-	const Record *_rec;
+	Record *_rec;
 	bool _isNeg;
 };
 
@@ -51,12 +51,12 @@ public:
 	void clear();
 	int uniqueSize() const { return _currNumIdxs; }
 	size_t totalSize() const { return _totalRecs; }
-	bool addRec(int dist, const Record *, chromDirType chromDir);
+	bool addRec(int dist, Record *, chromDirType chromDir);
 	bool exists(int dist) const {
 		int dummyVal = 0;
 		return find(dist, dummyVal);
 	}
-	typedef pair<chromDirType, const Record *> elemPairType;
+	typedef pair<chromDirType, Record *> elemPairType;
 	typedef vector<elemPairType> elemsType;
 	typedef pair<int, int> indexType;
 
@@ -66,12 +66,12 @@ public:
 	constIterType end() const { return _currNumIdxs; }
 	int currDist(constIterType iter) const { return _distIndex[iter].first; }
 	size_t currNumElems(constIterType iter) const { return allElems(iter)->size(); }
-	const elemsType *allElems(constIterType iter) const { return _allRecs[_distIndex[iter].second]; }
+	elemsType *allElems(constIterType iter) const { return _allRecs[_distIndex[iter].second]; }
 	int getMaxLeftEndPos() const;
 
 private:
 
-	void insert(int dist, const Record *, chromDirType chromDir);
+	void insert(int dist, Record *, chromDirType chromDir);
 
 
 	//if true, pos will be the idx the distance is at.
@@ -148,7 +148,7 @@ private:
 
 
  	typedef enum { IGNORE, DELETE } rateOvlpType;
-    rateOvlpType considerRecord(const Record *cacheRec, int dbIdx, bool &stopScanning);
+    rateOvlpType considerRecord(Record *cacheRec, int dbIdx, bool &stopScanning);
     void finalizeSelections(int dbIdx, RecordKeyVector &retList);
     void checkMultiDbs(RecordKeyVector &retList);
 
@@ -157,11 +157,11 @@ private:
     typedef enum { NEITHER, FORWARD_ONLY, REVERSE_ONLY, BOTH } purgeDirectionType;
 
     void setLeftClosestEndPos(int dbIdx);
-    bool beforeLeftClosestEndPos(int dbIdx, const Record *rec);
+    bool beforeLeftClosestEndPos(int dbIdx, Record *rec);
     void clearClosestEndPos(int dbIdx);
-    int addRecsToRetList(const RecDistList::elemsType *recs, int currDist, RecordKeyVector &retList);
-    void addSingleRec(const Record *rec, int currDist, int &hitsUsed, RecordKeyVector &retList);
-    rateOvlpType tryToAddRecord(const Record *cacheRec, int dist, int dbIdx, bool &stopScanning, chromDirType chromDir, streamDirType streamDir);
+    int addRecsToRetList(RecDistList::elemsType *recs, int currDist, RecordKeyVector &retList);
+    void addSingleRec(Record *rec, int currDist, int &hitsUsed, RecordKeyVector &retList);
+    rateOvlpType tryToAddRecord(Record *cacheRec, int dist, int dbIdx, bool &stopScanning, chromDirType chromDir, streamDirType streamDir);
     purgeDirectionType purgePointException(int dbIdx);
 
 };
diff --git a/src/utils/NewChromsweep/NewChromsweep.cpp b/src/utils/NewChromsweep/NewChromsweep.cpp
index 9a8e375..76a68e1 100644
--- a/src/utils/NewChromsweep/NewChromsweep.cpp
+++ b/src/utils/NewChromsweep/NewChromsweep.cpp
@@ -121,16 +121,20 @@ void NewChromSweep::scanCache(int dbIdx, RecordKeyVector &retList) {
     recListIterType cacheIter = _caches[dbIdx].begin();
     while (cacheIter != _caches[dbIdx].end())
     {
-        const Record *cacheRec = cacheIter->value();
-        if (_currQueryRec->sameChrom(cacheRec) && !_currQueryRec->after(cacheRec)) {
-            if (intersects(_currQueryRec, cacheRec)) {
+        Record *cacheRec = cacheIter->value();
+        if (_currQueryRec->sameChrom(cacheRec) && !_currQueryRec->after(cacheRec)) 
+        {
+            if (intersects(_currQueryRec, cacheRec)) 
+            {
                 retList.push_back(cacheRec);
-            } else if (cacheRec->after(_currQueryRec)) break; // cacheRec is after the query rec, stop scanning.
+            } 
+            else if (cacheRec->after(_currQueryRec)) break; // cacheRec is after the query rec, stop scanning.
             cacheIter = _caches[dbIdx].next();
         }
-        else {
-            cacheIter = _caches[dbIdx].deleteCurrent();
+        else 
+        {
             _dbFRMs[dbIdx]->deleteRecord(cacheRec);
+            cacheIter = _caches[dbIdx].deleteCurrent();
         }
     }
 }
@@ -139,7 +143,8 @@ void NewChromSweep::clearCache(int dbIdx)
 {
     //delete all objects pointed to by cache
     recListType &cache = _caches[dbIdx];
-    for (recListIterType iter = cache.begin(); iter != cache.end(); iter = cache.next()) {
+    for (recListIterType iter = cache.begin(); iter != cache.end(); iter = cache.next()) 
+    {
         _dbFRMs[dbIdx]->deleteRecord(iter->value());
     }
     cache.clear();
@@ -147,10 +152,14 @@ void NewChromSweep::clearCache(int dbIdx)
 
 void NewChromSweep::masterScan(RecordKeyVector &retList) {
 
-    for (int i=0; i < _numDBs; i++) {
-        if (dbFinished(i) || chromChange(i, retList, true)) {
+    for (int i=0; i < _numDBs; i++) 
+    {
+        if (dbFinished(i) || chromChange(i, retList, true)) 
+        {
             continue;
-        } else {
+        } 
+        else 
+        {
 
             // scan the database cache for hits
             scanCache(i, retList);
@@ -198,13 +207,13 @@ bool NewChromSweep::chromChange(int dbIdx, RecordKeyVector &retList, bool wantSc
 
     if (queryChromAfterDbRec(dbRec)) {
         // the query is ahead of the database. fast-forward the database to catch-up.
-        QuickString oldDbChrom(dbRec->getChrName());
-        while (dbRec != NULL &&
-                queryChromAfterDbRec(dbRec)) {
-                _dbFRMs[dbIdx]->deleteRecord(dbRec);
+        string oldDbChrom(dbRec->getChrName());
+        while (dbRec != NULL && queryChromAfterDbRec(dbRec)) 
+        {
+            _dbFRMs[dbIdx]->deleteRecord(dbRec);
             if (!nextRecord(false, dbIdx)) break;
             dbRec =  _currDbRecs[dbIdx];
-            const QuickString &newDbChrom = dbRec->getChrName();
+            const string &newDbChrom = dbRec->getChrName();
             if (newDbChrom != oldDbChrom) {
                 testChromOrder(dbRec);
                 oldDbChrom = newDbChrom;
@@ -324,17 +333,17 @@ void NewChromSweep::testChromOrder(const Record *rec)
 
     int fileIdx = rec->getFileIdx();
 
-    const QuickString &chrom = rec->getChrName();
+    const string &chrom = rec->getChrName();
 
     findChromOrder(rec);
 
     //determine what the previous chrom was for this file.
-    map<int, QuickString>::iterator prevIter = _filePrevChrom.find(fileIdx);
+    map<int, string>::iterator prevIter = _filePrevChrom.find(fileIdx);
     if (prevIter == _filePrevChrom.end()) {
         _filePrevChrom[fileIdx] = chrom;
         return; //no previously stored chrom for this file.
     }
-    const QuickString prevChrom(prevIter->second);
+    const string prevChrom(prevIter->second);
     _filePrevChrom[fileIdx] = chrom;
 
     if (chrom == prevChrom) return;
@@ -365,8 +374,8 @@ bool NewChromSweep::queryChromAfterDbRec(const Record *dbRec)
         return (_currQueryRec->getChromId() > dbRec->getChromId()) ;
     }
     //see if query has both
-    const QuickString &qChrom = _currQueryRec->getChrName();
-    const QuickString &dbChrom = dbRec->getChrName();
+    const string &qChrom = _currQueryRec->getChrName();
+    const string &dbChrom = dbRec->getChrName();
     const _orderTrackType *track = _fileTracks[_currQueryRec->getFileIdx()];
     _orderTrackType::const_iterator iter = track->find(qChrom);
 
@@ -385,7 +394,7 @@ bool NewChromSweep::queryChromAfterDbRec(const Record *dbRec)
 
 
 int NewChromSweep::findChromOrder(const Record *rec) {
-    const QuickString &chrom = rec->getChrName();
+    const string &chrom = rec->getChrName();
     int fileIdx = rec->getFileIdx();
     _orderTrackType *track = _fileTracks[fileIdx];
 
@@ -393,14 +402,14 @@ int NewChromSweep::findChromOrder(const Record *rec) {
     if (iter == track->end()) {
         //chrom never seen before. Enter into map.
         int val = (int)track->size();
-        track->insert(pair<QuickString, int>(chrom, val));
+        track->insert(pair<string, int>(chrom, val));
         return val;
     } else {
         return iter->second;
     }
 }
 
-bool NewChromSweep::verifyChromOrderMismatch(const QuickString & chrom, const QuickString &prevChrom, int skipFile) {
+bool NewChromSweep::verifyChromOrderMismatch(const string & chrom, const string &prevChrom, int skipFile) {
     //for every file except the one being checked,
     //find the current and previous chrom. If a given file
     //is missing either, skip it and go on. If it has both,
@@ -434,7 +443,7 @@ void NewChromSweep::testThatAllDbChromsExistInQuery()
         if (i == queryIdx) continue;
         const _orderTrackType *dbTrack = _fileTracks[i];
         for (_orderTrackType::const_iterator iter = dbTrack->begin(); iter != dbTrack->end(); iter++) {
-            const QuickString &chrom = iter->first;
+            const string &chrom = iter->first;
             if (qTrack->find(chrom) == qTrack->end()
                 && !chrom.empty())  // don't raise an error if the chrom is unknown (e.g., unmapped BAM)
             {
diff --git a/src/utils/NewChromsweep/NewChromsweep.h b/src/utils/NewChromsweep/NewChromsweep.h
index dc7f0a0..18fb165 100644
--- a/src/utils/NewChromsweep/NewChromsweep.h
+++ b/src/utils/NewChromsweep/NewChromsweep.h
@@ -20,7 +20,7 @@
 #include <iostream>
 #include <fstream>
 #include <stdlib.h>
-#include "QuickString.h"
+#include "string.h"
 
 using namespace std;
 
@@ -83,12 +83,12 @@ protected:
 //    recListType _hits;
 
     // the current query and db features.
-    const Record * _currQueryRec;
-    vector<const Record *> _currDbRecs;
+    Record * _currQueryRec;
+    vector<Record *> _currDbRecs;
 
     // a cache of the current chrom from the query. used to handle chrom changes.
-    QuickString _currQueryChromName;
-    QuickString _prevQueryChromName;
+    string _currQueryChromName;
+    string _prevQueryChromName;
     bool _runToQueryEnd;
 
 
@@ -113,19 +113,19 @@ protected:
     // sorted files without a genome file.
     //
 
-    typedef map<QuickString, int> _orderTrackType;
+    typedef map<string, int> _orderTrackType;
     vector<_orderTrackType *> _fileTracks;
-    map<int, QuickString> _filePrevChrom;
+    map<int, string> _filePrevChrom;
     bool _lexicoDisproven; //whether we've established that any file ISN'T in lexicographical order
     bool _lexicoAssumed; //whether we've had to try to guess that any file might be in lexicographical order.
-    QuickString _lexicoAssumedChromName; //which chromosome we had to make that guess for. Used in error reporting.
+    string _lexicoAssumedChromName; //which chromosome we had to make that guess for. Used in error reporting.
     int _lexicoAssumedFileIdx; //which file we had to make the guess for. Also for error reporting.
     bool _testLastQueryRec;
 
     void testChromOrder(const Record *rec);
     bool queryChromAfterDbRec(const Record *dbRec);
     int findChromOrder(const Record *rec);
-    bool verifyChromOrderMismatch(const QuickString & chrom, const QuickString &prevChrom, int skipFile);
+    bool verifyChromOrderMismatch(const string & chrom, const string &prevChrom, int skipFile);
     void testThatAllDbChromsExistInQuery();
     bool testLexicoQueryAfterDb(const Record *queryRec, const Record *dbRec);
 
diff --git a/src/utils/RecordOutputMgr/RecordOutputMgr.cpp b/src/utils/RecordOutputMgr/RecordOutputMgr.cpp
index 58aba85..20a2aa8 100644
--- a/src/utils/RecordOutputMgr/RecordOutputMgr.cpp
+++ b/src/utils/RecordOutputMgr/RecordOutputMgr.cpp
@@ -125,13 +125,13 @@ RecordOutputMgr::printBamType RecordOutputMgr::printBamRecord(RecordKeyVector &k
 	return NOT_BAM;
 }
 
-void RecordOutputMgr::printRecord(const Record *record)
+void RecordOutputMgr::printRecord(Record *record)
 {
 	RecordKeyVector keyList(record);
 	printRecord(keyList);
 }
 
-void RecordOutputMgr::printRecord(const Record *record, const QuickString & value)
+void RecordOutputMgr::printRecord(Record *record, const string & value)
 {	
 	checkForHeader();
 
@@ -158,7 +158,7 @@ void RecordOutputMgr::printClosest(RecordKeyVector &keyList, const vector<int> *
 
 	const ContextClosest *context = static_cast<const ContextClosest *>(_context);
 	bool deleteBlocks = false;
-	const Record *keyRec = keyList.getKey();
+	Record *keyRec = keyList.getKey();
 	RecordKeyVector blockList(keyRec);
 	if (keyRec->getType() == FileRecordTypeChecker::BAM_RECORD_TYPE) {
 		_bamBlockMgr->getBlocks(blockList, deleteBlocks);
@@ -166,7 +166,7 @@ void RecordOutputMgr::printClosest(RecordKeyVector &keyList, const vector<int> *
 	}
 	if (!keyList.empty()) {
 		int distCount = 0;
-		for (RecordKeyVector::const_iterator_type iter = keyList.begin(); iter != keyList.end(); iter = keyList.next()) {
+		for (RecordKeyVector::iterator_type iter = keyList.begin(); iter != keyList.end(); iter = keyList.next()) {
 			const Record *hitRec = *iter;
 			printKey(keyRec, keyRec->getStartPosStr(), keyRec->getEndPosStr());
 			tab();
@@ -177,7 +177,9 @@ void RecordOutputMgr::printClosest(RecordKeyVector &keyList, const vector<int> *
 				int dist = (*dists)[distCount];
 				//if not using sign distance, use absolute value instead.
 				dist = context->signDistance() ? dist : abs(dist);
-				_outBuf.append(dist);
+				ostringstream s;
+				s << dist;
+				_outBuf.append(s.str());
 				distCount++;
 			}
 			newline();
@@ -188,13 +190,14 @@ void RecordOutputMgr::printClosest(RecordKeyVector &keyList, const vector<int> *
 		tab();
 		// need to add a dummy file id if multiple DB files are used
 		if (_context->getNumInputFiles() > 2) {
-			_outBuf.append('.');
+			_outBuf.append(".");
 			tab();
 		}		
 		null(false, true);
 		if (context->reportDistance()) {
 			tab();
-			_outBuf.append(-1);
+
+			_outBuf.append("-1");
 		}
 		newline();
 	}
@@ -249,12 +252,12 @@ void RecordOutputMgr::printRecord(RecordKeyVector &keyList, RecordKeyVector *blo
 					tab();
 					// need to add a dummy file id if multiple DB files are used
 					if (_context->getNumInputFiles() > 2) {
-						_outBuf.append('.');
+						_outBuf.append(".");
 						tab();
 					}
 					null(false, true);
 					tab();
-					_outBuf.append('0');
+					_outBuf.append("0");
 					newline();
 					if (needsFlush()) flush();
 				}
@@ -269,7 +272,7 @@ void RecordOutputMgr::printRecord(RecordKeyVector &keyList, RecordKeyVector *blo
 					tab();
 					// need to add a dummy file id if multiple DB files are used
 					if (_context->getNumInputFiles() > 2) {
-						_outBuf.append('.');
+						_outBuf.append(".");
 						tab();
 					}
 					null(false, true);
@@ -279,7 +282,9 @@ void RecordOutputMgr::printRecord(RecordKeyVector &keyList, RecordKeyVector *blo
 
 					return;
 				}
-			} else {
+			} 
+			else 
+			{
 				if (printBamRecord(keyList, true) == BAM_AS_BAM) {
 					_currBamBlockList = NULL;
 
@@ -287,9 +292,14 @@ void RecordOutputMgr::printRecord(RecordKeyVector &keyList, RecordKeyVector *blo
 					return;
 				}
 				int hitIdx = 0;
-				for (RecordKeyVector::const_iterator_type iter = keyList.begin(); iter != keyList.end(); iter = keyList.next()) {
-					reportOverlapDetail(keyList.getKey(), *iter, hitIdx);
-					hitIdx++;
+				for (RecordKeyVector::iterator_type iter = keyList.begin(); iter != keyList.end(); iter = keyList.next()) 
+				{
+					// a hit can be invalid if there was no enough overlap, etc.
+					//if ((*iter)->isValid())
+					//{
+						reportOverlapDetail(keyList.getKey(), *iter, hitIdx);
+						hitIdx++;
+					//}
 				}
 			}
 		} else { // not printable
@@ -315,9 +325,9 @@ void RecordOutputMgr::checkForHeader() {
 	//If the tool is groupBy, and outheader was set,  but the header is empty, we need to print groupBy's
 	//default header
 	if (_context->getProgram() == ContextBase::GROUP_BY) {
-		const QuickString &header = _context->getFile(0)->getHeader();
+		const string &header = _context->getFile(0)->getHeader();
 		if (header.empty()) {
-			const QuickString &defaultHeader = (static_cast<ContextGroupBy *>(_context))->getDefaultHeader();
+			const string &defaultHeader = (static_cast<ContextGroupBy *>(_context))->getDefaultHeader();
 			_outBuf.append(defaultHeader);
 		} else {
 			_outBuf.append(header);
@@ -326,7 +336,7 @@ void RecordOutputMgr::checkForHeader() {
 		//if the tool is based on intersection, we want the header from the query file.
 
 		int queryIdx = (static_cast<ContextIntersect *>(_context))->getQueryFileIdx();
-		const QuickString &header  = _context->getFile(queryIdx)->getHeader();
+		const string &header  = _context->getFile(queryIdx)->getHeader();
 		_outBuf.append(header);
 	} else {
 		_outBuf.append(_context->getFile(0)->getHeader());
@@ -428,14 +438,16 @@ void RecordOutputMgr::reportOverlapSummary(RecordKeyVector &keyList)
 }
 
 void RecordOutputMgr::addDbFileId(int fileId) {
+	ostringstream s;
 	if ((static_cast<ContextIntersect *>(_context))->getNumDatabaseFiles()  == 1) return;
 	if (!_context->getUseDBnameTags() && (!_context->getUseDBfileNames())) {
-		_outBuf.append(fileId);
+		s << fileId;
 	} else if (_context->getUseDBnameTags()){
-		_outBuf.append((static_cast<ContextIntersect *>(_context))->getDatabaseNameTag((static_cast<ContextIntersect *>(_context))->getDbIdx(fileId)));
+		s << (static_cast<ContextIntersect *>(_context))->getDatabaseNameTag((static_cast<ContextIntersect *>(_context))->getDbIdx(fileId));
 	} else {
-		_outBuf.append(_context->getInputFileName(fileId));
+		s << _context->getInputFileName(fileId);
 	}
+	_outBuf.append(s.str());
 	tab();
 }
 
@@ -502,7 +514,7 @@ void RecordOutputMgr::null(bool queryType, bool dbType)
 	delete dummyRecord;
 }
 
-void RecordOutputMgr::printKey(const Record *key, const QuickString & start, const QuickString & end)
+void RecordOutputMgr::printKey(const Record *key, const string & start, const string & end)
 {
 	if (key->getType() != FileRecordTypeChecker::BAM_RECORD_TYPE) {
 		key->print(_outBuf, start, end);
diff --git a/src/utils/RecordOutputMgr/RecordOutputMgr.h b/src/utils/RecordOutputMgr/RecordOutputMgr.h
index 2639d9d..782c9d8 100644
--- a/src/utils/RecordOutputMgr/RecordOutputMgr.h
+++ b/src/utils/RecordOutputMgr/RecordOutputMgr.h
@@ -24,15 +24,15 @@ public:
 	//The init method must be called after all the input files are open.
 	void init(ContextBase *context);
 
-	void printRecord(const Record *record);
+	void printRecord(Record *record);
 	void printRecord(RecordKeyVector &keyList);
-	void printRecord(const Record *record, const QuickString & value);
+	void printRecord(Record *record, const string & value);
 	void checkForHeader();
 
 	void printClosest(RecordKeyVector &keyList, const vector<int> *dists = NULL);
 
-	void tab() { _outBuf.append('\t'); }
-	void newline() { _outBuf.append('\n'); }
+	void tab() { _outBuf.append("\t"); }
+	void newline() { _outBuf.append("\n"); }
 
 private:
 	typedef enum { NOT_BAM, BAM_AS_BAM, BAM_AS_BED} printBamType;
@@ -42,16 +42,16 @@ private:
 	BamTools::BamWriter *_bamWriter;
 	RecordKeyVector *_currBamBlockList;
 
-	QuickString _outBuf;
+	string _outBuf;
 
 	BlockMgr *_bamBlockMgr;
-	QuickString _afterVal; //to store values to be printed after record, such as column operations.
+	string _afterVal; //to store values to be printed after record, such as column operations.
 	//some helper functions to neaten the code.
 	void null(bool queryType, bool dbType);
 
 	void printRecord(RecordKeyVector &keyList, RecordKeyVector *blockList);
 	void printKey(const Record *key);
-	void printKey(const Record *key, const QuickString & start, const QuickString & end);
+	void printKey(const Record *key, const string & start, const string & end);
 	void printKey(const Record *key, int start, int end);
 	void addDbFileId(int fileId);
 	bool printKeyAndTerminate(RecordKeyVector &keyList);
diff --git a/src/utils/bedFile/bedFile.cpp b/src/utils/bedFile/bedFile.cpp
index 0db7f07..9ce59d8 100644
--- a/src/utils/bedFile/bedFile.cpp
+++ b/src/utils/bedFile/bedFile.cpp
@@ -64,7 +64,10 @@ bool byChromThenStart(BED const &a, BED const &b) {
     return false;
 };
 
-
+bool sortByWeight(const BED &a, const BED &b) {
+    if (a.weight > b.weight) return true;
+    else return false;
+};
 /*******************************************
 Class methods
 *******************************************/
@@ -767,3 +770,35 @@ void BedFile::loadBedFileIntoVector() {
     Close();
 }
 
+void BedFile::assignWeightsBasedOnSize() {
+    // sort by size
+    sort(bedList.begin(), bedList.end(), sortBySizeAsc);
+    // then assign a weight to each interval based on the
+    // proportion of the total interval length of the file
+    size_t totalSize = 0;
+    for (unsigned int i = 0; i < bedList.size(); ++i) 
+    {
+        totalSize += bedList[i].size();
+    }
+    double totalWeight = 0.0;
+    for (unsigned int i = 0; i < bedList.size(); ++i) 
+    {
+        totalWeight += (double) bedList[i].size() / (double) totalSize;
+        bedList[i].weight = totalWeight;
+    }
+}
+
+struct CompareByWeight {
+    bool operator()(double const val, BED const& bed) const 
+    {
+        return bed.weight > val;
+    }
+};
+
+BED * BedFile::sizeWeightedSearch(double val) {
+    // binary search for first interval with weight greater than search val
+    vector<BED>::iterator up = upper_bound(bedList.begin(), bedList.end(), val, CompareByWeight());
+    return &(*up);
+}
+
+
diff --git a/src/utils/bedFile/bedFile.h b/src/utils/bedFile/bedFile.h
index 0ef508f..8e7e4c9 100644
--- a/src/utils/bedFile/bedFile.h
+++ b/src/utils/bedFile/bedFile.h
@@ -91,6 +91,7 @@ struct BED {
     vector<uint16_t> other_idxs;
     // is this a zero length feature: i.e., start == end
     bool   zeroLength;
+    double weight;
 
 public:
     // constructors
@@ -105,7 +106,8 @@ public:
       strand(""),
       fields(),
       other_idxs(),
-      zeroLength(false)
+      zeroLength(false),
+      weight(0.0)
     {}
 
     // BED3
@@ -118,7 +120,8 @@ public:
       strand(""),
       fields(),
       other_idxs(),
-      zeroLength(false)
+      zeroLength(false),
+      weight(0.0)
     {}
 
     // BED4
@@ -131,7 +134,8 @@ public:
       strand(strand),
       fields(),
       other_idxs(),
-      zeroLength(false)
+      zeroLength(false),
+      weight(0.0)
     {}
 
     // BED6
@@ -145,7 +149,8 @@ public:
       strand(strand),
       fields(),
       other_idxs(),
-      zeroLength(false)
+      zeroLength(false),
+      weight(0.0)
     {}
 
     // BEDALL
@@ -160,7 +165,8 @@ public:
       strand(strand),
       fields(fields),
       other_idxs(other_idxs),
-      zeroLength(false)
+      zeroLength(false),
+      weight(0.0)
     {}
     
     int size() const {
@@ -434,6 +440,11 @@ public:
     // load a BED file into a vector of BEDs
     void loadBedFileIntoVector();
 
+    // load a BED file into a vector ordered in decreasing order by size
+    void assignWeightsBasedOnSize();
+
+    BED * sizeWeightedSearch(double val);
+
     // Given a chrom, start, end and strand for a single feature,
     // search for all overlapping features in another BED file.
     // Searches through each relevant genome bin on the same chromosome
@@ -484,7 +495,7 @@ public:
     bool isBed12;          // is it file of true blocked BED12 records?
     bool isZeroBased;
 
-    // Main data structires used by BEDTools
+    // Main data structures used by BEDTools
     masterBedCovMap      bedCovMap;
     masterBedCovListMap  bedCovListMap;
     masterBedMap         bedMap;
diff --git a/src/utils/driver/BedtoolsDriver.cpp b/src/utils/driver/BedtoolsDriver.cpp
index 093cc0e..ecab8c3 100644
--- a/src/utils/driver/BedtoolsDriver.cpp
+++ b/src/utils/driver/BedtoolsDriver.cpp
@@ -43,7 +43,7 @@ BedtoolsDriver::BedtoolsDriver()
 }
 
 
-bool BedtoolsDriver::supports(const QuickString &tool) {
+bool BedtoolsDriver::supports(const string &tool) {
 	supportType::iterator iter = _supported.find(tool);
 	return (iter != _supported.end());
 }
diff --git a/src/utils/driver/BedtoolsDriver.h b/src/utils/driver/BedtoolsDriver.h
index d4a1853..097031d 100644
--- a/src/utils/driver/BedtoolsDriver.h
+++ b/src/utils/driver/BedtoolsDriver.h
@@ -5,13 +5,13 @@ class BedtoolsDriver {
 public:
 	BedtoolsDriver();
 	bool subMain(int argc, char **argv);
-	bool supports(const QuickString &tool);
+	bool supports(const string &tool);
 	ContextBase *getContext();
 	ToolBase *getTool(ContextBase *context);
 	bool hadError() const { return _hadError; }
 protected:
-	QuickString _subCmd;
-	typedef set<QuickString> supportType;
+	string _subCmd;
+	typedef set<string> supportType;
 	supportType _supported;
 	bool _hadError;
 
diff --git a/src/utils/fileType/FileRecordTypeChecker.cpp b/src/utils/fileType/FileRecordTypeChecker.cpp
index 71dc42e..d6166ba 100644
--- a/src/utils/fileType/FileRecordTypeChecker.cpp
+++ b/src/utils/fileType/FileRecordTypeChecker.cpp
@@ -181,12 +181,12 @@ bool FileRecordTypeChecker::handleTextFormat(const char *buffer, size_t len)
 		//Tokenize the first line of valid data into fields.
 		//Need to make a copy so next call to tokenizer doesn't overwrite the line.
 
-		QuickString line(_tokenizer.getElem(_firstValidDataLineIdx));
+		string line(_tokenizer.getElem(_firstValidDataLineIdx));
 
 		_tokenizer.setKeepFinalIncompleteElem(Tokenizer::USE_NOW);
 		_tokenizer.setNumExpectedItems(_numFields);
 		_tokenizer.tokenize(line, _delimChar);
-		if (_tokenizer.getNumFields(line.str(), _delimChar) != _numFields) {
+		if (_tokenizer.getNumFields(line, _delimChar) != _numFields) {
 			cerr << "Error: Type checker found wrong number of fields while tokenizing data line." << endl;
 			exit(1);
 		}
@@ -293,7 +293,7 @@ bool FileRecordTypeChecker::isGFFformat()
 
 bool FileRecordTypeChecker::isTextDelimtedFormat(const char *buffer, size_t len)
 {
-	//Break single string buffer into vector of QuickStrings. Delimiter is newline.
+	//Break single string buffer into vector of strings. Delimiter is newline.
 	_tokenizer.setKeepFinalIncompleteElem(Tokenizer::IGNORE);
 	int numLines = _tokenizer.tokenize(buffer, '\n', _eofHit, _isCompressed);
 
@@ -455,6 +455,6 @@ bool FileRecordTypeChecker::passesBed12() {
 }
 
 bool FileRecordTypeChecker::isStrandField(int field) {
-	const QuickString &strandChar = _tokenizer.getElem(field);
+	const string &strandChar = _tokenizer.getElem(field);
 	return (strandChar == "+" || strandChar == "-" || strandChar == ".");
 }
diff --git a/src/utils/fileType/FileRecordTypeChecker.h b/src/utils/fileType/FileRecordTypeChecker.h
index a384a27..21ea896 100644
--- a/src/utils/fileType/FileRecordTypeChecker.h
+++ b/src/utils/fileType/FileRecordTypeChecker.h
@@ -35,7 +35,7 @@ public:
 		BED6_RECORD_TYPE, BED12_RECORD_TYPE, BED_PLUS_RECORD_TYPE, BED6_PLUS_RECORD_TYPE, BAM_RECORD_TYPE, VCF_RECORD_TYPE, GFF_RECORD_TYPE,
 		GFF_PLUS_RECORD_TYPE, NO_POS_PLUS_RECORD_TYPE} RECORD_TYPE;
 
-	void setFilename(const QuickString & filename) { _filename = filename; }
+	void setFilename(const string & filename) { _filename = filename; }
 	bool scanBuffer(const char *buf, size_t len, bool eofHit, bool isCompressed = false);
 	bool needsMoreData() const { return _insufficientData; }
 
@@ -89,7 +89,7 @@ private:
 	FILE_TYPE _fileType;
 	RECORD_TYPE _recordType;
 
-	QuickString _filename; //useful for reporting errors with file.
+	string _filename; //useful for reporting errors with file.
 	Tokenizer _tokenizer;
 
 	int _firstValidDataLineIdx;
diff --git a/src/utils/fileType/Makefile b/src/utils/fileType/Makefile
index ec0c518..57f7650 100644
--- a/src/utils/fileType/Makefile
+++ b/src/utils/fileType/Makefile
@@ -12,7 +12,7 @@ INCLUDES = -I$(UTILITIES_DIR)/BamTools/include/ \
 # ----------------------------------
 SOURCES= fileType.cpp fileType.h FileRecordTypeChecker.cpp FileRecordTypeChecker.h
 OBJECTS= fileType.o FileRecordTypeChecker.o
-#_EXT_OBJECTS=ParseTools.o QuickString.o
+#_EXT_OBJECTS=ParseTools.o string.o
 #EXT_OBJECTS=$(patsubst %,$(OBJ_DIR)/%,$(_EXT_OBJECTS))
 BUILT_OBJECTS= $(patsubst %,$(OBJ_DIR)/%,$(OBJECTS))
 
diff --git a/src/utils/general/BTlist.h b/src/utils/general/BTlist.h
index 7bae4f3..d64d845 100644
--- a/src/utils/general/BTlist.h
+++ b/src/utils/general/BTlist.h
@@ -26,7 +26,8 @@
 
 
 #include "FreeList.h"
-#include "QuickString.h"
+#include "string.h"
+#include <sstream>
 #include <stack>
 #include <cstring> //for memset
 
@@ -65,9 +66,9 @@ public:
 		_dontDelete(false)
 	{
 	}
-	//This version of the constructor will convert a QuickString into a BTlist.
+	//This version of the constructor will convert a string into a BTlist.
 	//It is effectively the opposite of the toStr method.
-	BTlist(const QuickString &str) :
+	BTlist(const string &str) :
 		_begin(NULL),
 		_currEnd(NULL),
 		_prevCursor(NULL),
@@ -230,18 +231,19 @@ public:
 		_dontDelete = true;
 	}
 
-	//this method will convert the contents of the list into a QuickString.
+	//this method will convert the contents of the list into a string.
 	//It assumes that the templated type of the listNode can be converted to a
 	//char using the (char) cast. The user must ensure that this is the case.
 	//The 2nd parameter needs only be true if you wish to append the data
-	//to the QuickString's existing contents. Otherwise, it will be cleared first.
-	void toStr(QuickString &str, bool append = false) const {
+	//to the string's existing contents. Otherwise, it will be cleared first.
+	void toStr(string &str, bool append = false) const 
+	{
 		if (!append) {
 			str.clear();
 		}
 		str.reserve(_size + str.size());
 		for (const BTlistNode<T> *iter = begin(); iter != end(); iter = iter->next()) {
-			str.append((char)iter->value());
+			str += iter->value();
 		}
 	}
 
diff --git a/src/utils/general/BedtoolsTypes.h b/src/utils/general/BedtoolsTypes.h
index 46aef49..c4b4dfd 100644
--- a/src/utils/general/BedtoolsTypes.h
+++ b/src/utils/general/BedtoolsTypes.h
@@ -17,7 +17,7 @@ using namespace std;
 #include <cstring>
 #include <cstdio>
 #include <iostream>
-#include "QuickString.h"
+#include "string.h"
 
 //STL headers
 #include <utility> //include pair and make_pair
diff --git a/src/utils/general/Makefile b/src/utils/general/Makefile
index 7fe5316..905eb5a 100644
--- a/src/utils/general/Makefile
+++ b/src/utils/general/Makefile
@@ -10,9 +10,9 @@ INCLUDES = -I$(UTILITIES_DIR)/lineFileUtilities/ \
 # ----------------------------------
 # define our source and object files
 # ----------------------------------
-SOURCES= QuickString.h QuickString.cpp ParseTools.h ParseTools.cpp PushBackStreamBuf.cpp PushBackStreamBuf.h CompressionTools.h CompressionTools.cpp \
+SOURCES= ParseTools.h ParseTools.cpp PushBackStreamBuf.cpp PushBackStreamBuf.h CompressionTools.h CompressionTools.cpp \
 		 Tokenizer.h Tokenizer.cpp CommonHelp.h CommonHelp.cpp ErrorMsg.h ErrorMsg.cpp
-OBJECTS= QuickString.o ParseTools.o PushBackStreamBuf.o CompressionTools.o Tokenizer.o CommonHelp.o
+OBJECTS= ParseTools.o PushBackStreamBuf.o CompressionTools.o Tokenizer.o CommonHelp.o
 BUILT_OBJECTS= $(patsubst %,$(OBJ_DIR)/%,$(OBJECTS))
 
 all: $(BUILT_OBJECTS)
@@ -25,6 +25,6 @@ $(BUILT_OBJECTS): $(SOURCES)
 
 clean:
 	@echo "Cleaning up."
-	@rm -f $(OBJ_DIR)/QuickString.o $(OBJ_DIR)/ParseTools.o $(OBJ_DIR)/PushBackStreamBuf.o $(OBJ_DIR)/Tokenizer.o $(OBJ_DIR)/CommonHelp.o
+	@rm -f $(OBJ_DIR)/string.o $(OBJ_DIR)/ParseTools.o $(OBJ_DIR)/PushBackStreamBuf.o $(OBJ_DIR)/Tokenizer.o $(OBJ_DIR)/CommonHelp.o
 
 .PHONY: clean
diff --git a/src/utils/general/ParseTools.cpp b/src/utils/general/ParseTools.cpp
index 372efdd..43f71c4 100644
--- a/src/utils/general/ParseTools.cpp
+++ b/src/utils/general/ParseTools.cpp
@@ -7,7 +7,7 @@
 #include <sstream>
 
 //This functions recognizes only numbers with digits, plus sign, minus sign, decimal point, e, or E. Hexadecimal and pointers not currently supported.
-bool isNumeric(const QuickString &str) {
+bool isNumeric(const string &str) {
 	for (int i=0; i < (int)str.size(); i++) {
 		char currChar = str[i];
 		if (!(isdigit(currChar) || currChar == '-' || currChar == '.' || currChar == '+' || currChar == 'e' || currChar == 'E')) {
@@ -18,7 +18,7 @@ bool isNumeric(const QuickString &str) {
 }
 
 //As above, but does not allow decimal points
-bool isInteger(const QuickString &str) {
+bool isInteger(const string &str) {
 	for (int i=0; i < (int)str.size(); i++) {
 		char currChar = str[i];
 		if (!(isdigit(currChar) || currChar == '-' || currChar == '+' || currChar == 'e' || currChar == 'E')) {
@@ -30,7 +30,7 @@ bool isInteger(const QuickString &str) {
 
 
 
-int str2chrPos(const QuickString &str) {
+int str2chrPos(const string &str) {
 	return str2chrPos(str.c_str(), str.size());
 }
 
@@ -128,7 +128,7 @@ string vectorIntToStr(const vector<int> &vec) {
 	return str;
 }
 
-bool isHeaderLine(const QuickString &line) {
+bool isHeaderLine(const string &line) {
 	if (line[0] == '>') {
 		return true;
 	}
@@ -138,7 +138,15 @@ bool isHeaderLine(const QuickString &line) {
 	if (line[0] == '#') {
 		return true;
 	}
-	//GFF file headers can also start with the words "browser" or "track", followed by a whitespace character.
+	//allow chr chrom to start a header line
+	if (memcmp(line.c_str(), "chrom", 5) == 0 && isspace(line[5])) {
+		return true;
+	}
+	//allow chr chrom to start a header line
+	if (memcmp(line.c_str(), "chr", 3) == 0 && isspace(line[3])) {
+		return true;
+	}
+	//UCSC file headers can also start with the words "browser" or "track", followed by a whitespace character.
 	if (memcmp(line.c_str(), "browser", 7) == 0 && isspace(line[7])) {
 		return true;
 	}
diff --git a/src/utils/general/ParseTools.h b/src/utils/general/ParseTools.h
index 9432f98..b354cdc 100644
--- a/src/utils/general/ParseTools.h
+++ b/src/utils/general/ParseTools.h
@@ -12,14 +12,14 @@
 #include <limits>
 #include <string>
 #include <vector>
-#include "QuickString.h"
+#include "string.h"
 #include <cstdio>
 #include <cstdlib>
 
 using namespace std;
 
-bool isNumeric(const QuickString &str);
-bool isInteger(const QuickString &str);
+bool isNumeric(const string &str);
+bool isInteger(const string &str);
 
 //This method is a faster version of atoi, but is limited to a maximum of
 //9 digit numbers in Base 10 only. The string may begin with a negative.
@@ -27,14 +27,14 @@ bool isInteger(const QuickString &str);
 //digits (with the excpetion of a minus sign in the first position)
 //will result in error. Errors return INT_MIN.
 int str2chrPos(const char *str, size_t len = 0);
-int str2chrPos(const QuickString &str);
+int str2chrPos(const string &str);
 
 
 //int2str is faster but less flexible version of the ToString method in
 //lineFileUtilities. Unlike ToString, which uses streams, this method
 //can only handle integers. The buffer, which is templated, needs to support the
 //assignment operater for char *, meaning it needs a T::operator = (const char *) method.
-//strings, QuickStrings, stringbuffers, and the like are acceptable.
+//strings, strings, stringbuffers, and the like are acceptable.
 
 template<class T>
 void int2str(int number, T& buffer, bool appendToBuf = false)
@@ -75,12 +75,12 @@ void int2str(int number, T& buffer, bool appendToBuf = false)
 
 }
 
-bool isHeaderLine(const QuickString &line);
+bool isHeaderLine(const string &line);
 
 string vectorIntToStr(const vector<int> &vec);
 
 
 //This is a faster version of tokenize that doesn't use strings. Return value is final size of elems vector.
-int Tokenize(const QuickString &str, vector<QuickString> &elems, char delimiter = '\t', int numExpectedItems = 0);
+//int Tokenize(const string &str, vector<string> &elems, char delimiter = '\t', int numExpectedItems = 0);
 
 #endif /* PARSETOOLS_H_ */
diff --git a/src/utils/general/QuickString.cpp b/src/utils/general/QuickString.cpp
index a83263e..4507a8c 100644
--- a/src/utils/general/QuickString.cpp
+++ b/src/utils/general/QuickString.cpp
@@ -1,11 +1,11 @@
-#include "QuickString.h"
+#include "string.h"
 #include <cstring>
 #include <cstdlib>
 #include <cstdio>
 #include "ParseTools.h"
 #include "lineFileUtilities.h"
 
-QuickString::QuickString(size_t capacity)
+string::string(size_t capacity)
 : _buffer(NULL),
   _currCapacity(capacity),
   _currSize(0)
@@ -13,7 +13,7 @@ QuickString::QuickString(size_t capacity)
 	build();
 }
 
-QuickString::QuickString(const QuickString &qs)
+string::string(const string &qs)
 :	_buffer(NULL),
 	_currCapacity(qs._currCapacity),
 	_currSize(0)
@@ -22,7 +22,7 @@ QuickString::QuickString(const QuickString &qs)
 	set(qs._buffer, qs._currSize);
 }
 
-QuickString::QuickString(const char *inBuf)
+string::string(const char *inBuf)
 {
 	size_t len = strlen(inBuf);
 	_currCapacity = len +1;
@@ -31,7 +31,7 @@ QuickString::QuickString(const char *inBuf)
 	set(inBuf, len);
 }
 
-QuickString::QuickString(const string &inString)
+string::string(const string &inString)
 {
 	size_t len = (int)inString.size();
 	_currCapacity = len +1;
@@ -40,7 +40,7 @@ QuickString::QuickString(const string &inString)
 	set(inString.c_str(), len);
 }
 
-QuickString::QuickString(char c)
+string::string(char c)
 {
 	_currCapacity =2;
 
@@ -53,127 +53,127 @@ QuickString::QuickString(char c)
 	set(buffer, 1);
 }
 
-void QuickString::build() {
+void string::build() {
 	_buffer = (char *)malloc(_currCapacity);
 	clear();
 }
 
-QuickString::~QuickString(){
+string::~string(){
 	free(_buffer);
 }
 
-void QuickString::clear() {
+void string::clear() {
 	memset(_buffer, 0, _currCapacity);
 	_currSize = 0;
 }
 
-void QuickString::release() {
+void string::release() {
 	free(_buffer);
 	_currCapacity = DEFAULT_CAPACITY;
 	build();
 }
 
-QuickString &QuickString::operator = (const char *inBuf){
+string &string::operator = (const char *inBuf){
 	set(inBuf, strlen(inBuf));
 	return *this;
 }
 
-QuickString &QuickString::operator = (const string & inBuf){
+string &string::operator = (const string & inBuf){
 	set(inBuf.c_str(), (int)inBuf.size());
 	return *this;
 }
 
-QuickString &QuickString::operator = (const QuickString & inBuf){
+string &string::operator = (const string & inBuf){
 	set(inBuf._buffer, (int)inBuf._currSize);
 	return *this;
 }
 
-QuickString &QuickString::operator = (char val) {
+string &string::operator = (char val) {
 	clear();
 	append(val);
 	return *this;
 }
-QuickString &QuickString::operator = (int val) {
+string &string::operator = (int val) {
 	clear();
 	append(val);
 	return *this;
 }
 
-QuickString &QuickString::operator = (uint32_t val) {
+string &string::operator = (uint32_t val) {
 	clear();
 	append(val);
 	return *this;
 }
 
-// QuickString &QuickString::operator = (size_t val) {
+// string &string::operator = (size_t val) {
 // 	clear();
 // 	append(val);
 // 	return *this;
 // }
 
-QuickString &QuickString::operator = (float val) {
+string &string::operator = (float val) {
 	clear();
 	append(val);
 	return *this;
 }
 
-QuickString &QuickString::operator = (double val) {
+string &string::operator = (double val) {
 	clear();
 	append(val);
 	return *this;
 }
 
 
-QuickString &QuickString::operator += (const QuickString & inBuf)
+string &string::operator += (const string & inBuf)
 {
 	append(inBuf._buffer, (int)inBuf._currSize);
 	return *this;
 }
 
-QuickString &QuickString::operator +=(const string &inBuf)
+string &string::operator +=(const string &inBuf)
 {
 	append(inBuf.c_str(), (int)inBuf.size());
 	return *this;
 }
 
-QuickString &QuickString::operator +=(char c) {
+string &string::operator +=(char c) {
 
 	append(c);
 	return *this;
 }
 
-QuickString &QuickString::operator += (const char *inBuf)
+string &string::operator += (const char *inBuf)
 {
 	append(inBuf, strlen(inBuf));
 	return *this;
 }
 
-QuickString &QuickString::operator += (int num) {
+string &string::operator += (int num) {
 	append(num);
 	return *this;
 }
 
-QuickString &QuickString::operator += (uint32_t num) {
+string &string::operator += (uint32_t num) {
 	append(num);
 	return *this;
 }
 
-// QuickString &QuickString::operator += (size_t num) {
+// string &string::operator += (size_t num) {
 // 	append(num);
 // 	return *this;
 // }
 
-QuickString &QuickString::operator += (float num) {
+string &string::operator += (float num) {
 	append(num);
 	return *this;
 }
 
-QuickString &QuickString::operator += (double num) {
+string &string::operator += (double num) {
 	append(num);
 	return *this;
 }
 
-bool QuickString::operator == (const QuickString &qs) const {
+bool string::operator == (const string &qs) const {
 	if ( _currSize != qs._currSize) {
 		return false;
 	}
@@ -183,7 +183,7 @@ bool QuickString::operator == (const QuickString &qs) const {
 	return true;
 }
 
-bool QuickString::operator == (const string &str) const {
+bool string::operator == (const string &str) const {
 	if ( _currSize != str.size()) {
 		return false;
 	}
@@ -194,7 +194,7 @@ bool QuickString::operator == (const string &str) const {
 
 }
 
-bool QuickString::stricmp(const QuickString &str) const {
+bool string::stricmp(const string &str) const {
 	if (str.size() != _currSize) {
 		return true;
 	}
@@ -206,7 +206,7 @@ bool QuickString::stricmp(const QuickString &str) const {
 	return false;
 }
 
-bool QuickString::operator == (const char *str) const {
+bool string::operator == (const char *str) const {
 	size_t inLen = strlen(str);
 	if (inLen != _currSize) {
 		return false;
@@ -218,26 +218,26 @@ bool QuickString::operator == (const char *str) const {
 }
 
 
-bool QuickString::operator != (const QuickString &qs) const {
+bool string::operator != (const string &qs) const {
 	return !(*this == qs);
 }
 
-bool QuickString::operator < (const QuickString &qs) const {
+bool string::operator < (const string &qs) const {
 	return (memcmp(_buffer, qs._buffer, max(_currSize, qs._currSize)) < 0);
 }
 
-bool QuickString::operator > (const QuickString &qs) const {
+bool string::operator > (const string &qs) const {
 	return (memcmp(_buffer, qs._buffer, max(_currSize, qs._currSize))> 0);
 }
 
-void QuickString::set(const char *inBuf, size_t newLen) {
+void string::set(const char *inBuf, size_t newLen) {
 	reserve(newLen);
 	clear();
 	memcpy(_buffer, inBuf, newLen);
 	_currSize = newLen;
 }
 
-void QuickString::reserve(size_t newLen) {
+void string::reserve(size_t newLen) {
 	newLen++; //always leave room for a null termninator.
 	if (_currCapacity <= newLen) {
 		while (_currCapacity <= newLen) {
@@ -255,50 +255,50 @@ void QuickString::reserve(size_t newLen) {
 	}
 }
 
-void QuickString::append(char c)
+void string::append(char c)
 {
 	reserve(_currSize +1);
 	_buffer[_currSize] = c;
 	_currSize++;
 }
 
-void QuickString::append(const char *inBuf, size_t inBufLen)
+void string::append(const char *inBuf, size_t inBufLen)
 {
 	reserve(_currSize + inBufLen);
 	memcpy(_buffer + _currSize, inBuf, inBufLen);
 	_currSize += inBufLen;
 }
 
-void QuickString::append(int num) {
+void string::append(int num) {
 	int2str(num, *this, true);
 }
 
-void QuickString::append(uint32_t num) {
+void string::append(uint32_t num) {
  	int2str((int)num, *this, true);
 }
 
-// void QuickString::append(size_t num) {
+// void string::append(size_t num) {
 // 	int2str((int)num, *this, true);
 // }
 
-void QuickString::append(float num) {
+void string::append(float num) {
 	append(ToString(num));
 }
 
-void QuickString::append(double num) {
+void string::append(double num) {
 	append(ToString(num));
 }
 
 
 
-QuickString &QuickString::assign(const char *inBuf, size_t inBufLen)
+string &string::assign(const char *inBuf, size_t inBufLen)
 {
 	clear();
 	append(inBuf, inBufLen);
 	return *this;
 }
 
-void QuickString::resize(size_t newSize, char fillChar)
+void string::resize(size_t newSize, char fillChar)
 {
 	if (newSize > _currSize) { //grow the string, pad with fillChar
 		reserve(newSize);
@@ -310,7 +310,7 @@ void QuickString::resize(size_t newSize, char fillChar)
 }
 
 
-void QuickString::substr (QuickString &newStr, size_t pos, size_t len) const
+void string::substr (string &newStr, size_t pos, size_t len) const
 {
 	if (pos >= _currSize) {
 		return;
@@ -321,7 +321,7 @@ void QuickString::substr (QuickString &newStr, size_t pos, size_t len) const
 	newStr.set(_buffer + pos, len);
 }
 
-ostream &operator << (ostream &out, const QuickString &str) {
+ostream &operator << (ostream &out, const string &str) {
 	out << str._buffer;
 	return out;
 }
diff --git a/src/utils/general/QuickString.h b/src/utils/general/QuickString.h
index 6e6fa94..c5e768e 100644
--- a/src/utils/general/QuickString.h
+++ b/src/utils/general/QuickString.h
@@ -1,12 +1,12 @@
 /*
- * QuickString.h
+ * string.h
  *
  *  Created on: Dec 3, 2012
  *      Author: nek3d
  */
 
-#ifndef QUICKSTRING_H_
-#define QUICKSTRING_H_
+#ifndef string_H_
+#define string_H_
 
 #include <string>
 #include <stdint.h>
@@ -15,16 +15,16 @@
 
 using namespace std;
 
-class QuickString {
+class string {
 public:
-	QuickString(size_t capacity = DEFAULT_CAPACITY);
-	QuickString(const QuickString &); //need explicit copy constructor
-	//so address of _buffer member is not copied! Each QuickString object
+	string(size_t capacity = DEFAULT_CAPACITY);
+	string(const string &); //need explicit copy constructor
+	//so address of _buffer member is not copied! Each string object
 	//needs to build it's own buffer.
-	QuickString(const char *);
-	QuickString(const string &);
-	QuickString(char c);
-	~QuickString();
+	string(const char *);
+	string(const string &);
+	string(char c);
+	~string();
 	size_t size() const { return _currSize; }
 	size_t capacity() const { return _currCapacity; }
 	void reserve(size_t newCapacity=0);
@@ -32,40 +32,40 @@ public:
 
 	void clear(); //only clears buffer, doesn't delete it.
 	void release(); //will deallocate current buffer, reallocate it at default size.
-	QuickString &operator = (const string &);
-	QuickString &operator = (const char *);
-	QuickString &operator = (const QuickString &);
-	QuickString &operator = (char);
-	QuickString &operator = (int);
-	QuickString &operator = (uint32_t);
-	//QuickString &operator = (size_t);
-	QuickString &operator = (float);
-	QuickString &operator = (double);
-	QuickString &operator += (const QuickString &);
-	QuickString &operator += (const string &);
-	QuickString &operator += (const char *);
-	QuickString &operator += (char);
-	QuickString &operator += (int);
-	QuickString &operator += (uint32_t);
-	//QuickString &operator += (size_t);
-	QuickString &operator += (float);
-	QuickString &operator += (double);
+	string &operator = (const string &);
+	string &operator = (const char *);
+	string &operator = (const string &);
+	string &operator = (char);
+	string &operator = (int);
+	string &operator = (uint32_t);
+	//string &operator = (size_t);
+	string &operator = (float);
+	string &operator = (double);
+	string &operator += (const string &);
+	string &operator += (const string &);
+	string &operator += (const char *);
+	string &operator += (char);
+	string &operator += (int);
+	string &operator += (uint32_t);
+	//string &operator += (size_t);
+	string &operator += (float);
+	string &operator += (double);
 
-	friend ostream &operator << (ostream &out, const QuickString &str);
-	bool operator == (const QuickString &) const;
+	friend ostream &operator << (ostream &out, const string &str);
+	bool operator == (const string &) const;
 	bool operator == (const string &) const;
 	bool operator == (const char *) const;
-	bool operator != (const QuickString &) const;
-	bool operator < (const QuickString &) const;
-	bool operator > (const QuickString &) const;
+	bool operator != (const string &) const;
+	bool operator < (const string &) const;
+	bool operator > (const string &) const;
 	const char *c_str() const { return _buffer; }
 	const string str() const { return _buffer; }
 	const char &operator [] (int pos) const { return _buffer[pos]; }
 	char &operator [] (int pos) { return _buffer[pos]; }
 	char &at(size_t pos) { return _buffer[pos]; }
-	bool stricmp(const QuickString &str) const; //case insensitive compare. False if same aside from case, true if different aside from case.
+	bool stricmp(const string &str) const; //case insensitive compare. False if same aside from case, true if different aside from case.
 
-	void append(const QuickString &str) { append(str.c_str(), str.size()); }
+	void append(const string &str) { append(str.c_str(), str.size()); }
 	void append(const char *buf, size_t bufLen);
 	void append(char c);
 
@@ -80,9 +80,9 @@ public:
 
 
 
-	QuickString &assign(const char *str, size_t n);
+	string &assign(const char *str, size_t n);
 	void resize(size_t n, char c = '\0');
-	void substr(QuickString &newStr, size_t pos = 0, size_t len = UINT_MAX) const;
+	void substr(string &newStr, size_t pos = 0, size_t len = UINT_MAX) const;
 
 private:
 	char *_buffer;
@@ -95,4 +95,4 @@ private:
 };
 
 
-#endif /* QUICKSTRING_H_ */
+#endif /* string_H_ */
diff --git a/src/utils/general/Tokenizer.cpp b/src/utils/general/Tokenizer.cpp
index ab3c8ea..779e261 100644
--- a/src/utils/general/Tokenizer.cpp
+++ b/src/utils/general/Tokenizer.cpp
@@ -35,11 +35,11 @@ int Tokenizer::getNumFields(const string &str, char delimiter)
     return tmp.size();
 }
 
-int Tokenizer::tokenize(const QuickString &str, char delimiter, bool eofHit, bool isCompressed) {
+int Tokenizer::tokenize(const string &str, char delimiter, bool eofHit, bool isCompressed) {
 
     // http://stackoverflow.com/questions/236129/how-to-split-a-string-in-c/236803#236803
     // NOTE: this approach intentionally allows consecutive delimiters
-    std::stringstream ss(str.str());
+    std::stringstream ss(str);
     std::string item;
     _elems.clear();
     while(getline(ss, item, delimiter)) {
@@ -62,7 +62,8 @@ int Tokenizer::tokenize(const QuickString &str, char delimiter, bool eofHit, boo
     		_elems.push_back(item);
     	}
     }
-    return _elems.size();
+    _numValidElems = _elems.size();
+    return _numValidElems;
 
 
 	// int strLen = (int)str.size();
@@ -82,7 +83,7 @@ int Tokenizer::tokenize(const QuickString &str, char delimiter, bool eofHit, boo
 	// 			currIdx--; //make sure it's not included in the final count of valid elems.
 
 	// 		} else {
-	// 			QuickString *newStr = fetchElem(currIdx);
+	// 			string *newStr = fetchElem(currIdx);
 	// 			newStr->assign(str.c_str() + startPos, min(currPos, strLen) - startPos);
 
 	// 			// If splitting lines, strip any white space from the end of the line
diff --git a/src/utils/general/Tokenizer.h b/src/utils/general/Tokenizer.h
index 88704de..797e1c1 100644
--- a/src/utils/general/Tokenizer.h
+++ b/src/utils/general/Tokenizer.h
@@ -8,7 +8,7 @@
 #ifndef TOKENIZER_H_
 #define TOKENIZER_H_
 
-#include "QuickString.h"
+#include "string.h"
 #include <vector>
 #include <sstream>
 
@@ -23,7 +23,7 @@ public:
 	// If not, don't worry about it.
 	void setNumExpectedItems(int val);
 
-	int tokenize(const QuickString &str, char delimiter = '\t', bool eofHit = false, bool isCompressed = true);
+	int tokenize(const string &str, char delimiter = '\t', bool eofHit = false, bool isCompressed = true);
 
 	// If the final element ends before a delim char, that means
 	// the buffer passed in ends mid-element. The last, incomplete
diff --git a/src/utils/stringUtilities/stringUtilities.h b/src/utils/stringUtilities/stringUtilities.h
index 6f3b459..36393da 100644
--- a/src/utils/stringUtilities/stringUtilities.h
+++ b/src/utils/stringUtilities/stringUtilities.h
@@ -1,18 +1,32 @@
 #ifndef STRINGUTILITIES_H
 #define STRINGUTILITIES_H
 
-#include <cctype>
+#include <iostream>
 #include <string>
+#include <cctype>
+#include <cwctype>
+#include <stdexcept>
+
+using namespace std;
 
 /****************************************************
 // isInteger(s): Tests if string s is a valid integer
 *****************************************************/
 inline bool isInteger(const std::string& s) {
     int len = s.length();
-    for (int i = 0; i < len; i++) {
+    for (int i = 0; i < len; i++)
         if (!std::isdigit(s[i])) return false;
     return true;
 }
 
+string toLower(const string& s) {
+	string t = s;
+	for (string::iterator p = t.begin(); p != t.end(); ++p) 
+	{
+		*p = tolower(*p);
+	}
+	return t;
+}
+
 #endif /* STRINGUTILITIES_H */
 
diff --git a/test/coverage/test-coverage.sh b/test/coverage/test-coverage.sh
index 7b534e0..95375fa 100644
--- a/test/coverage/test-coverage.sh
+++ b/test/coverage/test-coverage.sh
@@ -495,7 +495,7 @@ rm exp obs
 ##################################################################
 echo "    coverage.t10...\c"
 echo \
-"chr1	0	50	3	30	50	0.6000000
+"chr1	0	50	1	30	50	0.6000000
 chr1	12	20	0	0	8	0.0000000" > exp
 $BT coverage -a c.bed -b three_blocks_match.bam -split > obs
 check exp obs
diff --git a/test/general/t.bed b/test/general/t.bed
new file mode 100644
index 0000000..4a48d79
--- /dev/null
+++ b/test/general/t.bed
@@ -0,0 +1,5 @@
+chrom	chromStart	chromEnd	name	score	strand
+chr14	24800000	24810000	blarg	0	.
+chr11	64610000	64620000	blarg	0	.
+chr14	24710000	24720000	blarg	0	.
+chr11	111230000	111240000	blarg	0	.
diff --git a/test/general/test-general.sh b/test/general/test-general.sh
index 541be1a..2355836 100644
--- a/test/general/test-general.sh
+++ b/test/general/test-general.sh
@@ -277,5 +277,16 @@ $BT merge -i c.bed.gz > obs
 echo -n "" > exp
 check obs exp
 
+# allow header lines to start with chr or chrom
+echo "    general.t43...\c"
+echo "chrom	chromStart	chromEnd	name	score	strand
+chr14	24800000	24810000	blarg	0	.
+chr11	64610000	64620000	blarg	0	.
+chr14	24710000	24720000	blarg	0	.
+chr11	111230000	111240000	blarg	0	." > exp
+$BT intersect -a t.bed -b t.bed -header > obs
+check obs exp
+
+
 rm a.bed.gz b.bed.gz c.bed.gz a.bed b.bed c.bed genome.txt exp obs
 
diff --git a/test/groupBy/test-groupby.sh b/test/groupBy/test-groupby.sh
index 6a239d1..6d0036a 100644
--- a/test/groupBy/test-groupby.sh
+++ b/test/groupBy/test-groupby.sh
@@ -293,9 +293,8 @@ rm obs exp
 # non-positional records
 ###########################################################
 echo "    groupby.t15...\c"
-echo \
-"ERROR: file noPosvalues.header.bed has non positional records, which are only valid for the groupBy tool." > exp
-$BT merge  -i noPosvalues.header.bed 2>&1 >/dev/null | cat - > obs
+echo "ERROR: file noPosvalues.header.bed has non positional records, which are only valid for the groupBy tool." > exp
+$BT merge  -i noPosvalues.header.bed 2>&1 | head -n 1 > obs
 check obs exp
 rm obs exp
 
diff --git a/test/shift/b.bed b/test/shift/b.bed
new file mode 100644
index 0000000..a147e8a
--- /dev/null
+++ b/test/shift/b.bed
@@ -0,0 +1,2 @@
+chr1	66999638	67216822	NM_032291	0	+
+chr1	92145899	92351836	NR_036634	0	-
diff --git a/test/shift/huge.genome b/test/shift/huge.genome
new file mode 100644
index 0000000..d8ebc53
--- /dev/null
+++ b/test/shift/huge.genome
@@ -0,0 +1 @@
+chr1	249250621
diff --git a/test/shift/test-shift.sh b/test/shift/test-shift.sh
index 9c3c6a2..a78b15a 100644
--- a/test/shift/test-shift.sh
+++ b/test/shift/test-shift.sh
@@ -113,3 +113,14 @@ chr1	999	1000	a2	2	-" > exp
 $BT shift -i a.bed -s 3000000000 -g tiny.genome > obs
 check obs exp
 rm obs exp
+
+###########################################################
+# test shift huge genome
+###########################################################
+echo "    shift.t9...\c"
+echo \
+"chr1	67000638	67217822	NM_032291	0	+
+chr1	92146899	92352836	NR_036634	0	-" > exp
+$BT shift -i b.bed -s 1000 -g huge.genome > obs
+check obs exp
+rm obs exp
diff --git a/test/test.sh b/test/test.sh
index f249557..9b9e69a 100644
--- a/test/test.sh
+++ b/test/test.sh
@@ -31,6 +31,9 @@ cd genomecov; bash test-genomecov.sh; cd ..
 echo " Testing bedtools getfasta:"
 cd getfasta; bash test-getfasta.sh; cd ..
 
+echo " Testing bedtools groupby:"
+cd groupby; bash test-groupby.sh; cd ..
+
 echo " Testing bedtools intersect:"
 cd intersect; bash test-intersect.sh; bash new_test-intersect.sh; cd ..
 
