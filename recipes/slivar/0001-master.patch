diff --git a/nim.cfg b/nim.cfg
index 93f6fa1..834861a 100644
--- a/nim.cfg
+++ b/nim.cfg
@@ -2,6 +2,7 @@
 -d:nimNoGetRandom
 --passC:"-mpopcnt"
 --passC:"-static -no-pie"
+--passC:"-Wno-incompatible-pointer-types"
 path = "$projectPath/src"
 #-d:useLibzipSrc
 
diff --git a/slivar.nimble b/slivar.nimble
index 0c49c6d..de8b508 100644
--- a/slivar.nimble
+++ b/slivar.nimble
@@ -18,7 +18,7 @@ license       = "MIT"
 
 
 # Dependencies
-requires "hts >= 0.3.4", "lapper >= 0.1.6", "nimgen", "https://github.com/brentp/duktape-nim#dev", "https://github.com/brentp/pedfile >= 0.0.3"
+requires "hts >= 0.3.4", "lapper >= 0.1.6", "https://github.com/brentp/duktape-nim#dev", "https://github.com/brentp/pedfile >= 0.0.3"
 requires "https://github.com/brentp/nim-minizip >= 0.0.11", "argparse >=0.10.1 & < 0.10.2"
 srcDir = "src"
 installExt = @["nim"]
diff --git a/src/slivarpkg/ddc.nim b/src/slivarpkg/ddc.nim
index b1b3bae..079dce9 100644
--- a/src/slivarpkg/ddc.nim
+++ b/src/slivarpkg/ddc.nim
@@ -12,12 +12,12 @@ import strutils
 import strformat
 import os
 
-proc `$$`(k:float32): string {.inline.} =
+proc `$$`(k: float32): string {.inline.} =
   result = &"{k:.3f}"
   while result.len > 1 and result[result.high] == '0':
-    result = result.strip(chars={'0'}, leading=false)
+    result = result.strip(chars = {'0'}, leading = false)
   if result[result.high] == '.':
-    result = result.strip(chars={'.'}, leading=false)
+    result = result.strip(chars = {'.'}, leading = false)
 
 const tmpl_html* = staticRead("ddc.html")
 
@@ -58,7 +58,7 @@ proc tojson(tbl: Table[string, seq[float32]]): string =
     result = "{}"
 
 
-proc tojson(t:Trio): string =
+proc tojson(t: Trio): string =
   result = newStringOfCap(16384)
   result.add(&"""{{sample_id: "{t.sample_id}",
 tbl: {t.tbl.tojson},
@@ -66,7 +66,7 @@ violations: {%t.violations},
 variant_idxs: {%t.variant_idxs}
 }}""")
 
-proc tojson(ts:seq[Trio]): string =
+proc tojson(ts: seq[Trio]): string =
   result = newStringOfCap(16384*128)
   result.add('[')
   for t in ts:
@@ -74,7 +74,7 @@ proc tojson(ts:seq[Trio]): string =
     result.add(',')
   result[result.high] = ']'
 
-proc tojson(v:VariantInfo): string =
+proc tojson(v: VariantInfo): string =
   result = newStringOfCap(16384)
   result.add(&"""{{float_tbl: {v.float_tbl.tojson},
 bool_tbl: {%v.bool_tbl},
@@ -87,10 +87,11 @@ proc trio_kids(samples: seq[Sample]): seq[Sample] =
   ## return all samples that have a mom and dad.
   result = newSeqOfCap[Sample](16)
   for sample in samples:
-    if sample.mom == nil or sample.mom.i == -1 or sample.dad == nil or sample.dad.i == -1: continue
+    if sample.mom == nil or sample.mom.i == -1 or sample.dad == nil or
+        sample.dad.i == -1: continue
     result.add(sample)
 
-proc getAB(v:Variant): seq[float32] =
+proc getAB(v: Variant): seq[float32] =
   if v.format.get("AB", result) != Status.OK:
 
     var ad: seq[int32]
@@ -108,7 +109,7 @@ proc getAB(v:Variant): seq[float32] =
   #  if ab == 0'f32 or ab == 1'f32: continue
   #  if ab > 0.5: ab = 1-ab
 
-proc getINFOf32(v:Variant, f:string): float32 =
+proc getINFOf32(v: Variant, f: string): float32 =
   if f == "QUAL":
     return v.QUAL.float32
   var rr = newSeqUninitialized[float32](1)
@@ -123,7 +124,7 @@ proc getINFOf32(v:Variant, f:string): float32 =
   doAssert i.len == 1, &"[slivar] require only fields with single values got {rr.len} in field {f}"
   return i[0].float32
 
-proc getf32(v:Variant, f:string): seq[float32] =
+proc getf32(v: Variant, f: string): seq[float32] =
   if f == "AB": return v.getAB
   var st = v.format.get(f, result)
   if st == Status.OK: return
@@ -145,26 +146,29 @@ proc getf32(v:Variant, f:string): seq[float32] =
     # TODO: handle missing
     result[k] = val.float32
 
-proc violation(kid:Sample, alts: seq[int8], allele_balances: seq[float32]): bool =
+proc violation(kid: Sample, alts: seq[int8], allele_balances: seq[
+    float32]): bool =
   result = alts[kid.i] >= 1 and alts[kid.mom.i] == 0 and alts[kid.dad.i] == 0
   if not result and alts[kid.i] == 2:
-      result = [alts[kid.mom.i], alts[kid.dad.i]] in [[0'i8, 1], [1'i8, 0]]
+    result = [alts[kid.mom.i], alts[kid.dad.i]] in [[0'i8, 1], [1'i8, 0]]
   if not result and alts[kid.i] == 0:
-      result = [alts[kid.mom.i], alts[kid.dad.i]] in [[2'i8, 1], [1'i8, 2]]
+    result = [alts[kid.mom.i], alts[kid.dad.i]] in [[2'i8, 1], [1'i8, 2]]
 
   if allele_balances.len == 0 or result == false: return
   if allele_balances[kid.mom.i] > 0 or allele_balances[kid.dad.i] > 0:
     raise newException(ValueError, "non zero allele balance for parents")
 
-proc inherited(kid:Sample, alts: seq[int8], allele_balances: seq[float32]): bool =
-  result = alts[kid.i] == 1 and [alts[kid.mom.i], alts[kid.dad.i]] in [[0'i8, 1], [1'i8, 0]]
+proc inherited(kid: Sample, alts: seq[int8], allele_balances: seq[
+    float32]): bool =
+  result = alts[kid.i] == 1 and [alts[kid.mom.i], alts[kid.dad.i]] in [[0'i8,
+      1], [1'i8, 0]]
   if result == false or allele_balances.len == 0: return
   if alts[kid.dad.i] == 0 and allele_balances[kid.dad.i] > 0:
     raise newException(ValueError, "non zero allele balance for parents")
   if alts[kid.mom.i] == 0 and allele_balances[kid.mom.i] > 0:
     raise newException(ValueError, "non zero allele balance for parents")
 
-proc get_variant_length(v:Variant): int =
+proc get_variant_length(v: Variant): int =
   var length = int(v.ALT[0].len - v.REF.len)
   if v.ALT[0][0] == '<':
     var lengths: seq[int32]
@@ -172,12 +176,13 @@ proc get_variant_length(v:Variant): int =
       length = lengths[0]
     else:
       length = int(v.stop - v.start - 1)
-      var svt:string
+      var svt: string
       if v.info.get("SVTYPE", svt) == Status.OK and svt == "DEL":
         length = -length
   result = length
 
-proc check*[T: VariantInfo|seq[Trio]](ivcf:VCF, fields: seq[string], ftype:BCF_HEADER_TYPE, infos: var T): seq[string] =
+proc check*[T: VariantInfo|seq[Trio]](ivcf: VCF, fields: seq[string],
+    ftype: BCF_HEADER_TYPE, infos: var T): seq[string] =
   for f in fields:
     try:
       let hr = ivcf.header.get(f, ftype)
@@ -214,13 +219,14 @@ proc check*[T: VariantInfo|seq[Trio]](ivcf:VCF, fields: seq[string], ftype:BCF_H
           quit &"requested info field {f} not found in header"
   return fields
 
-proc ddc_main*(dropfirst:bool=false) =
+proc ddc_main*(dropfirst: bool = false) =
   var p = newParser("slivar ddc"):
     #option("-x", help="haploid (x) chromosome", default="chrX")
-    option("--chrom", help="limit to this chromosome only. use '-3' for all chromosomes (in the case of exome data)", default="chr15")
-    option("--info-fields", help="comma-delimited list of info fields")
-    option("--fmt-fields", help="comma-delimited list of sample fields")
-    option("--html", default="slivar-ddc.html", help="path to output file")
+    option("--chrom", help = "limit to this chromosome only. use '-3' for all chromosomes (in the case of exome data)",
+        default = "chr15")
+    option("--info-fields", help = "comma-delimited list of info fields")
+    option("--fmt-fields", help = "comma-delimited list of sample fields")
+    option("--html", default = "slivar-ddc.html", help = "path to output file")
     arg("vcf")
     arg("ped")
 
@@ -233,8 +239,8 @@ proc ddc_main*(dropfirst:bool=false) =
   if opts.help:
     quit 0
 
-  var ivcf:VCF
-  if not open(ivcf, opts.vcf, threads=2):
+  var ivcf: VCF
+  if not open(ivcf, opts.vcf, threads = 2):
     quit "could not open vcf:" & opts.vcf
 
   var samples = parse_ped(opts.ped).match(ivcf)
@@ -245,7 +251,7 @@ proc ddc_main*(dropfirst:bool=false) =
     randomize()
     shuffle(kids)
     kids = kids[0..<max_trios]
-    kids.sort(proc(a, b:Sample): int = a.i - b.i)
+    kids.sort(proc(a, b: Sample): int = a.i - b.i)
     samples = newSeq[Sample]()
     for k in kids:
       samples.add(k)
@@ -254,15 +260,18 @@ proc ddc_main*(dropfirst:bool=false) =
       if k.mom notin samples:
         samples.add(k.mom)
 
-  var output_infos = VariantInfo(float_tbl: initTable[string, seq[float32]](), bool_tbl: initTable[string, seq[bool]]())
+  var output_infos = VariantInfo(float_tbl: initTable[string, seq[float32]](),
+      bool_tbl: initTable[string, seq[bool]]())
   var output_trios = newSeq[Trio](kids.len)
   for i, o in output_trios.mpairs:
     o.sample_id = kids[i].id
     o.tbl = initTable[string, seq[float32]]()
 
   if opts.info_fields != "":
-    discard ivcf.check(opts.info_fields.strip().split(','), BCF_HEADER_TYPE.BCF_HL_INFO, output_infos)
-  var fmt_fields = ivcf.check(opts.fmt_fields.strip().split(','), BCF_HEADER_TYPE.BCF_HL_FMT, output_trios)
+    discard ivcf.check(opts.info_fields.strip().split(','),
+        BCF_HEADER_TYPE.BCF_HL_INFO, output_infos)
+  var fmt_fields = ivcf.check(opts.fmt_fields.strip().split(','),
+      BCF_HEADER_TYPE.BCF_HL_FMT, output_trios)
 
   var x: seq[int32]
 
@@ -278,12 +287,15 @@ proc ddc_main*(dropfirst:bool=false) =
     var fmts = newSeq[seq[float32]](fmt_fields.len)
     for i, f in fmt_fields:
       fmts[i] = v.getf32(f)
-    shallow(fmts)
+
+    when NimMajor < 2:
+      shallow(fmts)
     if "AB" in fmt_fields:
       ab = fmts[fmt_fields.find("AB")]
 
     var alts = v.format.genotypes(x).alts
-    shallow(alts)
+    when NimMajor < 2:
+      shallow(alts)
     var any_used = false
     var any_violation = false
 
@@ -335,7 +347,7 @@ proc ddc_main*(dropfirst:bool=false) =
   html = html.replace("<TRIO_JSON>", output_trios.tojson)
 
 
-  var fh:File
+  var fh: File
   if not open(fh, opts.html, fmWrite):
     quit "couldn't open output html file:" & opts.html
   fh.write(html)
diff --git a/src/slivarpkg/default-order.txt b/src/slivarpkg/default-order.txt
index a54296f..dcda55f 100644
--- a/src/slivarpkg/default-order.txt
+++ b/src/slivarpkg/default-order.txt
@@ -41,6 +41,7 @@ initiator_codon
 splice_donor_5th_base
 splice_polypyrimidine_tract
 splice_donor_region
+coding_transcript
 miRNA
 non_coding_transcript_exon
 non_coding_exon
@@ -56,6 +57,7 @@ non_coding_transcript
 non_coding
 upstream_gene
 sequence_feature
+sequence
 downstream_gene
 intragenic
 TFBS_ablation
diff --git a/src/slivarpkg/duodel.nim b/src/slivarpkg/duodel.nim
index 25802cd..875b844 100644
--- a/src/slivarpkg/duodel.nim
+++ b/src/slivarpkg/duodel.nim
@@ -15,14 +15,15 @@ type Duo = object
   parent_label: string # "mom" or "dad"
   i: int
 
-template AB(sample_i:int, AD:seq[int32]): float32 =
+template AB(sample_i: int, AD: seq[int32]): float32 =
   var a = AD[2*sample_i+1].float32
   a / max(1, a + AD[2*sample_i].float32)
 
-template DP(sample_i: int, AD:seq[int32]): int32 =
+template DP(sample_i: int, AD: seq[int32]): int32 =
   AD[2*sample_i+1] + AD[2*sample_i]
 
-proc hq*(sample_i: int, GQ: seq[int32], AD: seq[int32], alts: seq[int8], min_dp=9): bool {.inline.} =
+proc hq*(sample_i: int, GQ: seq[int32], AD: seq[int32], alts: seq[int8],
+    min_dp = 9): bool {.inline.} =
   if GQ[sample_i] < 20: return false
   if sample_i.DP(AD) < min_dp: return false
   var ab = sample_i.AB(AD)
@@ -54,7 +55,7 @@ proc transmit(duo: Duo, GQ: seq[int32], AD: seq[int32], alts: seq[int8]): set[Tr
     result.incl Transmit.Uninformative
 
 
-  if not hq(duo.kid.i, GQ, AD, alts, 9): result.incl  Transmit.LowQual
+  if not hq(duo.kid.i, GQ, AD, alts, 9): result.incl Transmit.LowQual
   if not hq(duo.parent.i, GQ, AD, alts): result.incl Transmit.LowQual
   if p == 1:
     result.incl Transmit.ParentHet
@@ -73,24 +74,28 @@ proc transmit(duo: Duo, GQ: seq[int32], AD: seq[int32], alts: seq[int8]): set[Tr
   return result + {Transmit.Maybe}
 
 
-proc duos(samples:seq[Sample], affected_only:bool): seq[Duo] =
+proc duos(samples: seq[Sample], affected_only: bool): seq[Duo] =
   for s in samples:
     if affected_only and not s.affected: continue
-    if s.mom != nil: result.add(Duo(kid:s, parent: s.mom, i: result.len, parent_label: "mom"))
-    if s.dad != nil: result.add(Duo(kid:s, parent: s.dad, i: result.len, parent_label: "dad"))
+    if s.mom != nil: result.add(Duo(kid: s, parent: s.mom, i: result.len,
+        parent_label: "mom"))
+    if s.dad != nil: result.add(Duo(kid: s, parent: s.dad, i: result.len,
+        parent_label: "dad"))
 
 type Site = object
   chrom*: string
   start*: int64
   sample_i*: int
   status*: set[Transmit]
-  i*: int # index of sites used in this duo
+  i*: int     # index of sites used in this duo
   dps_i*: int # index into DPs seq
   ads*: array[4, uint16]
 
-proc near(group: seq[Site], other:Site, i_dist:int=3, genome_dist:int=10000): bool =
+proc near(group: seq[Site], other: Site, i_dist: int = 3,
+    genome_dist: int = 10000): bool =
   for g in group:
-    if abs(g.i - other.i) <= i_dist and abs(g.start - other.start) < genome_dist: return true
+    if abs(g.i - other.i) <= i_dist and abs(g.start - other.start) <
+        genome_dist: return true
   return false
 
 type SiteStats = object
@@ -192,7 +197,7 @@ proc normalize*(DPs: var seq[seq[uint16]]): seq[seq[float32]] =
     for v in row.mitems:
       v = v / rowMean
 
-proc get(s:Sample, DPs: var seq[seq[float32]]): seq[float32] =
+proc get(s: Sample, DPs: var seq[seq[float32]]): seq[float32] =
   result = newSeqOfCap[float32](DPs.len)
   for row in DPs:
     result.add(row[s.i])
@@ -203,7 +208,9 @@ proc median(vals: seq[float32]): float32 =
   sort(vals, system.cmp[float32])
   return vals[int(vals.high / 2)]
 
-proc cull(duo: Duo, sites: seq[Site], DPs: var seq[seq[float32]], i_dist:int=25, genome_dist:int=200000, min_sites:int=2, min_size:int=20) =
+proc cull(duo: Duo, sites: seq[Site], DPs: var seq[seq[float32]],
+    i_dist: int = 25, genome_dist: int = 200000, min_sites: int = 2,
+    min_size: int = 20) =
 
   var dp_norm_kid = duo.kid.get(DPs)
   var dp_norm_parent = duo.parent.get(DPs)
@@ -218,7 +225,8 @@ proc cull(duo: Duo, sites: seq[Site], DPs: var seq[seq[float32]], i_dist:int=25,
     if Transmit.No in c.status: seeds.add(c)
 
   var used = initHashSet[int]()
-  shallow(seeds)
+  when NimMajor < 2:
+    shallow(seeds)
   for j, site in seeds:
     if site.i in used: continue
     used.incl(site.i)
@@ -248,7 +256,7 @@ proc cull(duo: Duo, sites: seq[Site], DPs: var seq[seq[float32]], i_dist:int=25,
     s &= &"{stats.hq_kid_hets}\t{stats.kid_hets}\t{stats.hq_parent_hets}\t{stats.hq_parent_hom_alts}"
     echo s
 
-template min16*(i:int32):uint16 =
+template min16*(i: int32): uint16 =
   max(0, min(uint16.high.int32, i)).uint16
 
 proc toDP(AD: seq[int32]): seq[uint16] =
@@ -258,19 +266,21 @@ proc toDP(AD: seq[int32]): seq[uint16] =
 
 include ./utils
 
-proc main*(dropfirst:bool=false) =
+proc main*(dropfirst: bool = false) =
   ## TODO: find homozygous deletions with ./.
   var p = newParser("slivar duodel"):
     help("""find denovo structural deletions in parent-child duos using non-transmission of SNPs
     see: https://github.com/brentp/slivar/wiki/finding-deletions-in-parent-child-duos
     """)
-    option("-p", "--ped", help="required ped file describing the duos in the VCF")
-    option("-g", "--gnotate", help="optional gnotate file to check for flagged variants to exclude")
-    option("-s", "--min-sites", default="3", help="minimum number of variants required to define a region (use 1 to output all putative deletions)")
-    option("-S", "--min-size", default="50", help="minimum size in base-pairs of a region")
-    option("-x", "--exclude", help="path to BED file of exclude regions e.g. (LCRs or self-chains)")
-    flag("-a", "--affected-only", help="only output DEL calls for affected kids")
-    arg("vcf", default="/dev/stdin", help="input SNP/indel VCF")
+    option("-p", "--ped", help = "required ped file describing the duos in the VCF")
+    option("-g", "--gnotate", help = "optional gnotate file to check for flagged variants to exclude")
+    option("-s", "--min-sites", default = "3",
+        help = "minimum number of variants required to define a region (use 1 to output all putative deletions)")
+    option("-S", "--min-size", default = "50",
+        help = "minimum size in base-pairs of a region")
+    option("-x", "--exclude", help = "path to BED file of exclude regions e.g. (LCRs or self-chains)")
+    flag("-a", "--affected-only", help = "only output DEL calls for affected kids")
+    arg("vcf", default = "/dev/stdin", help = "input SNP/indel VCF")
 
   var argv = commandLineParams()
   if len(argv) > 0 and argv[0] == "duo-del":
@@ -287,13 +297,13 @@ proc main*(dropfirst:bool=false) =
 
 
   var samples = parse_ped(opts.ped)
-  var ivcf:VCF
-  if not open(ivcf, opts.vcf, threads=2):
+  var ivcf: VCF
+  if not open(ivcf, opts.vcf, threads = 2):
     quit "couldn't open VCF"
   samples = samples.match(ivcf)
   var duos = samples.duos(opts.affected_only)
   stderr.write_line &"[slivar] found {duos.len} duos"
-  var gno:Gnotater
+  var gno: Gnotater
   if opts.gnotate != "":
     if not gno.open(opts.gnotate):
       quit "couldn't open gnotate file at:" & opts.gnotate
@@ -320,17 +330,20 @@ proc main*(dropfirst:bool=false) =
       if last_rid != -1:
         var fdps = DPs.normalize
         for duo in duos:
-          duo.cull(sites[duo.i], fdps, min_sites=min_sites, min_size=min_size)
+          duo.cull(sites[duo.i], fdps, min_sites = min_sites,
+              min_size = min_size)
           sites[duo.i].setLen(0)
         DPs.setLen(0)
       last_rid = v.rid
 
-    if v.CHROM == "X" or v.CHROM == "chrX" or v.CHROM == "MT" or v.CHROM == "chrM" or v.CHROM == "chrMT": continue
+    if v.CHROM == "X" or v.CHROM == "chrX" or v.CHROM == "MT" or v.CHROM ==
+        "chrM" or v.CHROM == "chrMT": continue
     if v.FILTER notin ["PASS", "", "."]: continue
     if len(v.ALT) > 1: continue
     if len(v.REF) != 1: continue
     if len(v.ALT[0]) != 1: continue
-    if exclude != nil and stripChr(v.CHROM) in exclude and 0 != exclude[stripChr(v.CHROM)].count(v.start.int, v.start.int + 1):
+    if exclude != nil and stripChr(v.CHROM) in exclude and 0 != exclude[
+        stripChr(v.CHROM)].count(v.start.int, v.start.int + 1):
       continue
     var LowQual = false
     if gno != nil and gno.annotate(v) and v.info.has_flag(gno.names[0] & "_filter"):
@@ -359,7 +372,8 @@ proc main*(dropfirst:bool=false) =
       if Transmit.Uninformative in m: continue
       if LowQual:
         m.incl(Transmit.LowQual)
-      var c = Site(chrom: $v.CHROM, start: v.start, status: m, dps_i: DPs.high, i: sites[duo.i].len)
+      var c = Site(chrom: $v.CHROM, start: v.start, status: m, dps_i: DPs.high,
+          i: sites[duo.i].len)
       c.ads[0] = min16(AD[2*duo.kid.i])
       c.ads[1] = min16(AD[2*duo.kid.i+1])
       c.ads[2] = min16(AD[2*duo.parent.i])
@@ -368,7 +382,7 @@ proc main*(dropfirst:bool=false) =
 
   var fdps = DPs.normalize
   for duo in duos:
-    duo.cull(sites[duo.i], fdps, min_sites=min_sites, min_size=min_size)
+    duo.cull(sites[duo.i], fdps, min_sites = min_sites, min_size = min_size)
 
 when isMainModule:
   main()
diff --git a/src/slivarpkg/gnotate.nim b/src/slivarpkg/gnotate.nim
index 80120be..ee5b127 100644
--- a/src/slivarpkg/gnotate.nim
+++ b/src/slivarpkg/gnotate.nim
@@ -23,15 +23,15 @@ const MissingVal = float32(0x7F800001) # float32.low
 type Gnotater* = ref object
   zip: Zip
   missing_value: float32 ## annotate variants absent from gnotate file with an allele frequency of -1.0
-  chrom: cstring ## this tracks the current chromosome.
-  encs: seq[uint64] ## encoded position,ref,alt. alts > 1 are encoding a FILTER as well.
-  names: seq[string] ## this is what gets set in the INFO. e.g. 'gnomad_af'.
+  chrom: cstring      ## this tracks the current chromosome.
+  encs: seq[uint64]   ## encoded position,ref,alt. alts > 1 are encoding a FILTER as well.
+  names: seq[string]  ## this is what gets set in the INFO. e.g. 'gnomad_af'.
   values: seq[seq[float32]] ## encoded values, e.g. allele frequencies from gnomad.
-  longs: seq[Long] ## pos, ref, alt, af for long variants
+  longs: seq[Long]    ## pos, ref, alt, af for long variants
   chroms: seq[string] ## list of chroms available in the index.
   tmpDir: string
 
-proc close*(g:var Gnotater) =
+proc close*(g: var Gnotater) =
   g.zip.close()
 
 template names*(g: Gnotater): seq[string] =
@@ -40,7 +40,7 @@ template names*(g: Gnotater): seq[string] =
 proc n_fields(g: Gnotater): int =
   return g.names.len
 
-proc cmp_long*(a, b:Long): int =
+proc cmp_long*(a, b: Long): int =
   if a.position != b.position:
     return cmp[uint32](a.position, b.position)
   if a.reference != b.reference:
@@ -50,24 +50,26 @@ proc cmp_long*(a, b:Long): int =
 
 randomize()
 
-proc open*(g:var Gnotater, zpath: string, tmpDir:string="/tmp", missing_val:float32= -1.0'f32): bool =
-  g = Gnotater(tmpDir:tmpDir, missing_value:missing_val, names: @[], chroms: @[])
+proc open*(g: var Gnotater, zpath: string, tmpDir: string = "/tmp",
+    missing_val: float32 = -1.0'f32): bool =
+  g = Gnotater(tmpDir: tmpDir, missing_value: missing_val, names: @[],
+      chroms: @[])
   if not open(g.zip, zpath):
     stderr.write_line &"[slivar] error opening {zpath} for annotation"
     return false
 
   var s = newString(1)
   doAssert g.zip.read_into("sli.var/chroms.txt", s)
-  for l in s.strip().split(seps={'\n'}):
+  for l in s.strip().split(seps = {'\n'}):
     g.chroms.add(l.strip())
 
   doAssert g.zip.read_into("sli.var/fields.txt", s)
-  for l in s.strip().split(seps={'\n'}):
+  for l in s.strip().split(seps = {'\n'}):
     g.names.add(l.strip())
 
   if getEnv("SLIVAR_QUIET") == "" and g.zip.read_into("sli.var/message.txt", s):
     stderr.write_line "[slivar] message for " & zpath & ":"
-    for l in s.strip().split(seps={'\n'}):
+    for l in s.strip().split(seps = {'\n'}):
       if l.strip() != "":
         stderr.write_line "   > " & l
   g.encs = newSeq[uint64]()
@@ -78,9 +80,9 @@ proc open*(g:var Gnotater, zpath: string, tmpDir:string="/tmp", missing_val:floa
 
   return true
 
-proc parseLong(line: string, n_fields:int): Long {.inline.} =
+proc parseLong(line: string, n_fields: int): Long {.inline.} =
   var i = -1
-  for t in line.split(seps={'\t', '\n'}, maxsplit=4):
+  for t in line.split(seps = {'\t', '\n'}, maxsplit = 4):
     i += 1
     if i == 0:
       result.position = parseInt(t).uint32
@@ -91,7 +93,7 @@ proc parseLong(line: string, n_fields:int): Long {.inline.} =
     elif i == 3:
       result.filter = t[0] == 't'
     elif i == 4:
-      let ts = t.split(seps={'|'}, maxsplit=n_fields)
+      let ts = t.split(seps = {'|'}, maxsplit = n_fields)
       result.values.setLen(ts.len)
       for i, it in ts:
         result.values[i] = parseFloat(it)
@@ -100,19 +102,19 @@ proc parseLong(line: string, n_fields:int): Long {.inline.} =
     quit "bad line:" & line
 
 
-proc readLongs(g:var Gnotater, chrom: string) =
+proc readLongs(g: var Gnotater, chrom: string) =
   g.longs.setLen(0)
 
   var big = newString(16)
   doAssert g.zip.read_into(&"sli.var/{chrom}/long-alleles.txt", big)
   var i = 0
-  for l in big.split(seps={'\n'}):
+  for l in big.split(seps = {'\n'}):
     if unlikely(l.len == 0): continue
     if unlikely(i == 0 and l.startswith("position")): continue
-    g.longs.add(parseLong(l, g.n_fields))#.strip(chars={'\n'})))
+    g.longs.add(parseLong(l, g.n_fields)) #.strip(chars={'\n'})))
     i += 1
 
-proc readEncs(g:var Gnotater, chrom: string) =
+proc readEncs(g: var Gnotater, chrom: string) =
   doAssert g.zip.readInto(&"sli.var/{chrom}/gnotate-variant.bin", g.encs)
 
 proc readValues(g: var Gnotater, chrom: string, field_i: int) =
@@ -121,21 +123,22 @@ proc readValues(g: var Gnotater, chrom: string, field_i: int) =
     # if we encounter a new chromosome after an empty one.
     g.values.setLen(field_i + 1)
   # gnotate-gnomad_num_homalt.bin
-  shallow(g.values)
+  when NimMajor < 2:
+    shallow(g.values)
   doAssert g.zip.readInto(&"sli.var/{chrom}/gnotate-{field_name}.bin", g.values[field_i])
 
 proc readValues(g: var Gnotater, chrom: string) =
   for i in 0..<g.n_fields:
     g.readValues(chrom, i)
 
-proc sanitize_chrom*(c:string): string {.inline.} =
+proc sanitize_chrom*(c: string): string {.inline.} =
   if c.len == 1: return c
   result = c
   if c.len > 3 and c[0] == 'c' and c[1] == 'h' and c[2] == 'r':
     result = result[3..result.high]
   if result == "MT": result = "M"
 
-proc load(g:var Gnotater, chrom: cstring): bool =
+proc load(g: var Gnotater, chrom: cstring): bool =
   g.chrom = chrom
   var chrom = sanitize_chrom($chrom)
   if chrom notin g.chroms:
@@ -169,11 +172,11 @@ proc values_at(g: Gnotater, i: int): seq[float32] =
     # g.values  is shape (n_fields, n_variants)
     result[k] = g.values[k][i]
 
-proc show*(g:var Gnotater, chrom:string, start:int, stop:int) =
+proc show*(g: var Gnotater, chrom: string, start: int, stop: int) =
   if g.chrom != chrom:
-   discard g.load(chrom)
+    discard g.load(chrom)
 
-  var q = pfra(position:start.uint32, reference:"A", alternate:"A")
+  var q = pfra(position: start.uint32, reference: "A", alternate: "A")
   var i = g.encs.lowerBound(q.encode)
   q.position = stop.uint32
   var j = max(0, g.encs.lowerBound(q.encode))
@@ -183,7 +186,7 @@ proc show*(g:var Gnotater, chrom:string, start:int, stop:int) =
   for k in i..j:
     echo g.encs[k].decode, " # ", g.encs[k], " values:", g.values_at(k)
 
-proc annotate_missing(g:Gnotater, v:Variant): bool {.inline.} =
+proc annotate_missing(g: Gnotater, v: Variant): bool {.inline.} =
   if g.missing_value != MissingVal:
     var values = @[g.missing_value]
     for n in g.names:
@@ -192,15 +195,15 @@ proc annotate_missing(g:Gnotater, v:Variant): bool {.inline.} =
     return true
   return false
 
-proc contains*(g: var Gnotater, v:Variant): bool =
+proc contains*(g: var Gnotater, v: Variant): bool =
   ## fast-path to check presence variant in set
   if g.chrom != v.CHROM:
     discard g.load(v.CHROM)
   let alt = if likely(len(v.ALT) > 0): v.ALT[0] else: "."
   let q = if unlikely(v.REF.len + alt.len > MaxCombinedLen):
-    pfra(position:v.start.uint32)
+    pfra(position: v.start.uint32)
   else:
-    pfra(position:v.start.uint32, reference:v.REF, alternate:alt)
+    pfra(position: v.start.uint32, reference: v.REF, alternate: alt)
   var i = g.encs.find(q)
   if i == -1: return false
   let match = g.encs[i].decode
@@ -210,7 +213,7 @@ proc contains*(g: var Gnotater, v:Variant): bool =
     return true
 
   # should find this position in the longs
-  let l = Long(position:v.start.uint32, reference:v.REF, alternate:alt)
+  let l = Long(position: v.start.uint32, reference: v.REF, alternate: alt)
   i = lowerBound(g.longs, l, cmp_long)
   # since these can be ordered differently, we have to check until we get to a different position or a match.
   while i < g.longs.len:
@@ -221,7 +224,7 @@ proc contains*(g: var Gnotater, v:Variant): bool =
     i += 1
   return i < g.longs.len
 
-proc annotate*(g:var Gnotater, v:Variant): bool {.inline.} =
+proc annotate*(g: var Gnotater, v: Variant): bool {.inline.} =
   ## annotate the variant INFO field with the allele frequencies and flags in g
   ## if include_missing is true. the allele frequency will be set to -1 if the variant
   ## is not found.
@@ -231,12 +234,12 @@ proc annotate*(g:var Gnotater, v:Variant): bool {.inline.} =
   if g.encs.len == 0:
     return g.annotate_missing(v)
 
-  var q:pfra
+  var q: pfra
   var alt = if likely(len(v.ALT) > 0): v.ALT[0] else: "."
   if unlikely(v.REF.len + alt.len > MaxCombinedLen):
-    q = pfra(position:v.start.uint32)
+    q = pfra(position: v.start.uint32)
   else:
-    q = pfra(position:v.start.uint32, reference:v.REF, alternate:alt)
+    q = pfra(position: v.start.uint32, reference: v.REF, alternate: alt)
   var i = g.encs.find(q)
   if i == -1:
     return g.annotate_missing(v)
@@ -248,7 +251,7 @@ proc annotate*(g:var Gnotater, v:Variant): bool {.inline.} =
 
   if match.reference.len == 0:
     # should find this position in the longs
-    var l = Long(position:v.start.uint32, reference:v.REF, alternate:alt)
+    var l = Long(position: v.start.uint32, reference: v.REF, alternate: alt)
     var i = lowerBound(g.longs, l, cmp_long)
     # since these can be ordered differently, we have to check until we get to a different position or a match.
     while i < g.longs.len:
@@ -276,10 +279,12 @@ proc annotate*(g:var Gnotater, v:Variant): bool {.inline.} =
         quit &"couldn't set info flag {g.names[i] & \"_filter\"}"
   return true
 
-proc update_header*(g:Gnotater, ivcf:VCF) =
+proc update_header*(g: Gnotater, ivcf: VCF) =
   for n in g.names:
-    doAssert ivcf.header.add_info(n, "1", "Float", "field from from gnotate VCF") == Status.OK
-    doAssert ivcf.header.add_info(n & "_filter", "0", "Flag", "non-passing flag in gnotate source VCF") == Status.OK
+    doAssert ivcf.header.add_info(n, "1", "Float",
+        "field from from gnotate VCF") == Status.OK
+    doAssert ivcf.header.add_info(n & "_filter", "0", "Flag",
+        "non-passing flag in gnotate source VCF") == Status.OK
 
 when isMainModule:
 
@@ -299,19 +304,19 @@ when isMainModule:
 
   var vcf_path = paramStr(1)
 
-  var ivcf:VCF
-  if not open(ivcf, vcf_path, threads=2):
+  var ivcf: VCF
+  if not open(ivcf, vcf_path, threads = 2):
     quit "couldn't open path" & vcf_path
 
-  var ovcf:VCF
-  if not open(ovcf, "_t.bcf", mode="wb", threads=3):
+  var ovcf: VCF
+  if not open(ovcf, "_t.bcf", mode = "wb", threads = 3):
     quit "couldn't open output file"
 
   var zip_path = paramStr(2)
   var original_field = paramStr(3)
 
-  var g:Gnotater
-  if not g.open(zip_path, tmpDir="/tmp", missing_val= -1.0'f32):
+  var g: Gnotater
+  if not g.open(zip_path, tmpDir = "/tmp", missing_val = -1.0'f32):
     quit "[slivar] error opening zip. check path and contents"
   g.update_header(ivcf)
 
@@ -334,7 +339,7 @@ when isMainModule:
   ivcf.close()
 
   ## now open the output file and check that values match.
-  if not open(ivcf, "_t.bcf", threads=3):
+  if not open(ivcf, "_t.bcf", threads = 3):
     quit "couldn't open file to check"
 
   var n = 0
@@ -373,7 +378,7 @@ when isMainModule:
           quit "got:" & $val & " expected:" & $oval
 
       if not v.info.has_flag(n & "_filter") and filt != "PASS":
-          quit "FAIL: no filter found for " & v.tostring()
+        quit "FAIL: no filter found for " & v.tostring()
       break
 
     n += 1
