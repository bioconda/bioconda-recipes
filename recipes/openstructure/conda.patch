diff --git a/CMakeLists.txt b/CMakeLists.txt
index 10371f711..f39d93927 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -27,7 +27,7 @@ option(USE_RPATH "embed rpath upon make install"
 option(COMPILE_TMTOOLS "whether to compile the tmalign and tmscore programs"
        OFF)
 option(PROFILE "whether to compile with profiling support"
-       OFF)       
+       OFF)
 option(ENABLE_GUI "whether the graphical user interface should be enabled"
        ON)
 option(ENABLE_GFX "whether graphics support should be enabled"
@@ -36,7 +36,7 @@ option(OPENGLPREFERENCE_LEGACY "whether to use the OpenGL Legacy GL implementati
        OFF)
 option(ENABLE_INFO "whether openstructure should be compiled with support for the info library"
        ON)
-option(USE_DOUBLE_PRECISION "whether to compile in double precision" 
+option(USE_DOUBLE_PRECISION "whether to compile in double precision"
        OFF)
 option(ENABLE_SPNAV "whether 3DConnexion devices should be supported"
       OFF)
@@ -192,7 +192,7 @@ if (WIN32)
    ADD_DEFINITIONS("-DBOOST_ALL_NO_LIB")
 endif()
 
-if (ENABLE_INFO)        
+if (ENABLE_INFO)
   find_package(Qt5Xml REQUIRED)
   set(QT_LIBRARIES ${QT_LIBRARIES} Qt5::Xml)
 endif()
@@ -226,6 +226,7 @@ find_package(SQLITE3 3.7.13 REQUIRED)
 find_package(PNG REQUIRED)
 find_package(FFTW REQUIRED)
 find_package(TIFF REQUIRED)
+find_package(ZLIB REQUIRED)
 
 if(ENABLE_MM)
   find_package(OpenMM REQUIRED)
@@ -241,15 +242,15 @@ endif(ENABLE_PARASAIL)
 if (ENABLE_STATIC)
   set(Boost_LIBRARIES)
   set(Boost_USE_STATIC_LIBS ON)
-  find_package(Boost ${_BOOST_MIN_VERSION} 
+  find_package(Boost ${_BOOST_MIN_VERSION}
                COMPONENTS filesystem system iostreams regex thread REQUIRED)
   find_package(ZLIB REQUIRED)
-   
+
   if (UNIX AND NOT APPLE)
-    set(STATIC_LIBRARIES ${Boost_LIBRARIES} ${FFTW_LIBRARIES} ${TIFF_LIBRARIES} 
+    set(STATIC_LIBRARIES ${Boost_LIBRARIES} ${FFTW_LIBRARIES} ${TIFF_LIBRARIES}
         ${PNG_LIBRARY} ${ZLIB_LIBRARY})
   else ()
-    set(STATIC_LIBRARIES ${Boost_LIBRARIES} ${FFTW_LIBRARIES} ${TIFF_LIBRARIES} 
+    set(STATIC_LIBRARIES ${Boost_LIBRARIES} ${FFTW_LIBRARIES} ${TIFF_LIBRARIES}
         ${PNG_LIBRARY} ${ZLIB_LIBRARY})
   endif()
 endif()
@@ -277,7 +278,7 @@ if (CMAKE_COMPILER_IS_GNUCXX)
   if("${CMAKE_CXX_COMPILER_VERSION}" VERSION_GREATER "4.6")
     set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-attributes")
   endif("${CMAKE_CXX_COMPILER_VERSION}" VERSION_GREATER "4.6")
-  if(HIDDEN_VISIBILITY) 
+  if(HIDDEN_VISIBILITY)
     set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility=hidden")
     set (_HIDDEN_VIS ON)
   else(HIDDEN_VISIBILITY)
@@ -293,8 +294,8 @@ if(CMAKE_C_COMPILER_ID MATCHES "Clang")
 endif(CMAKE_C_COMPILER_ID MATCHES "Clang")
 
 # basic environment
-include_directories(${Boost_INCLUDE_DIRS} 
-                    ${FFTW_INCLUDE_DIRS} 
+include_directories(${Boost_INCLUDE_DIRS}
+                    ${FFTW_INCLUDE_DIRS}
                     ${EIGEN3_INCLUDE_DIRS}
                     ${TIFF_INCLUDE_DIR}
                     ${PNG_INCLUDE_DIRS}
@@ -313,12 +314,12 @@ if (UNIX)
     set(_USE_RPATH OFF)
    SET(CMAKE_INSTALL_RPATH "")
    SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE)
-  endif() 
+  endif()
 endif()
 
 if (ENABLE_STATIC)
   SET(CMAKE_SKIP_BUILD_RPATH TRUE)
-  SET(LINK_SEARCH_END_STATIC TRUE) 
+  SET(LINK_SEARCH_END_STATIC TRUE)
 endif()
 
 add_subdirectory(modules)
@@ -338,10 +339,10 @@ set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES
 #ost_match_boost_python_version(${Python_LIBRARIES})
 
 if (CMAKE_COMPILER_IS_GNUCXX)
-   set(HIDDEN_VIS_MSG 
+   set(HIDDEN_VIS_MSG
        "\n   Hidden object visibility  (-DHIDDEN_VISIBILITY) : ${_HIDDEN_VIS}")
 endif()
-message(STATUS 
+message(STATUS
         "OpenStructure will be built with the following options:\n"
         "   Install Prefix                        (-DPREFIX) : ${CMAKE_INSTALL_PREFIX}\n"
         "   RPath in install                   (-DUSE_RPATH) : ${_USE_RPATH}\n"
diff --git a/cmake_support/OST.cmake b/cmake_support/OST.cmake
index 3456bc0dc..22119e62f 100644
--- a/cmake_support/OST.cmake
+++ b/cmake_support/OST.cmake
@@ -81,14 +81,14 @@ macro(parse_argument_list PREFIX ARG_NAMES OPT_NAMES)
   set(_CURR_ARG_LIST)
   # loop over parameter list and split by ARG_NAMES
   foreach(_ARG ${ARGN})
-    set(_LARG_NAMES ${ARG_NAMES})  
+    set(_LARG_NAMES ${ARG_NAMES})
     list(FIND _LARG_NAMES ${_ARG} _IS_ARG_NAME)
     if (_IS_ARG_NAME GREATER -1)
       set(${PREFIX}_${_CURR_ARG_NAME} ${_CURR_ARG_LIST})
       set(_CURR_ARG_NAME "${_ARG}")
       set(_CURR_ARG_LIST)
     else()
-    set(_LOPT_NAMES ${OPT_NAMES})  
+    set(_LOPT_NAMES ${OPT_NAMES})
       list(FIND _LOPT_NAMES ${_ARG} _IS_OPT_NAME)
       if (_IS_OPT_NAME GREATER -1)
         set(${PREFIX}_${_ARG} TRUE)
@@ -117,7 +117,7 @@ macro(copy_if_different FROM_DIR TO_DIR FILES TARGETS TARGET)
       if("${TO_DIR}" STREQUAL "")
           set(TO ${SRCFILE})
       else()
-          get_filename_component(TOFILE ${SRC} NAME)      
+          get_filename_component(TOFILE ${SRC} NAME)
           set(TO ${TO_DIR}/${TOFILE})
       endif()
       file(MAKE_DIRECTORY  ${TO_DIR})
@@ -159,7 +159,7 @@ endmacro()
 
 #-------------------------------------------------------------------------------
 # Synopsis:
-#   module(NAME name SOURCES source1 source2 HEADERS header1 header2 
+#   module(NAME name SOURCES source1 source2 HEADERS header1 header2
 #          [IN_DIR dir] [header3 header4 [IN_DIR dir]] [DEPENDS_ON dep1 dep2]
 #          [HEADER_OUTPUT_DIR dir]
 #          [LINK link_cmds])
@@ -171,10 +171,10 @@ macro(module)
   # deal with arguments
   #-----------------------------------------------------------------------------
   set(_ARGS "NAME;SOURCES;HEADERS;DEPENDS_ON;LINK;HEADER_OUTPUT_DIR;PREFIX")
-  set(_ARG_PREFIX ost)  
-  parse_argument_list(_ARG "${_ARGS}" "NO_STATIC" ${ARGN})  
+  set(_ARG_PREFIX ost)
+  parse_argument_list(_ARG "${_ARGS}" "NO_STATIC" ${ARGN})
   if (NOT _ARG_NAME)
-    message(FATAL_ERROR 
+    message(FATAL_ERROR
             "invalid use of module(): a module name must be provided")
   endif()
 
@@ -187,9 +187,9 @@ macro(module)
     set(_HEADER_OUTPUT_DIR "${_ARG_PREFIX}/${_ARG_NAME}")
   endif()
   set(_LIB_NAME ${_ARG_PREFIX}_${_ARG_NAME})
-  string(TOUPPER ${_LIB_NAME} _UPPER_LIB_NAME)  
+  string(TOUPPER ${_LIB_NAME} _UPPER_LIB_NAME)
   #-----------------------------------------------------------------------------
-  # create library  
+  # create library
   #-----------------------------------------------------------------------------
   file(MAKE_DIRECTORY ${LIB_STAGE_PATH})
   file(MAKE_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
@@ -216,7 +216,7 @@ macro(module)
     else()
       add_library(${_LIB_NAME} SHARED ${_ABS_SOURCE_NAMES})
     endif()
-    set_target_properties(${_LIB_NAME} 
+    set_target_properties(${_LIB_NAME}
                           PROPERTIES OUTPUT_NAME ${_LIB_NAME}
                                      PROJECT_LABEL ${_ARG_NAME}
                                      EchoString   ${_ARG_NAME}
@@ -227,7 +227,7 @@ macro(module)
                           COMPILE_DEFINITIONS OST_MODULE_${_UPPER_LIB_NAME})
     set_target_properties(${_LIB_NAME} PROPERTIES
                           VERSION ${OST_VERSION_STRING}
-                          SOVERSION ${OST_VERSION_MAJOR}.${OST_VERSION_MINOR})    
+                          SOVERSION ${OST_VERSION_MAJOR}.${OST_VERSION_MINOR})
     set_target_properties(${_LIB_NAME} PROPERTIES
                           LIBRARY_OUTPUT_DIRECTORY ${LIB_STAGE_PATH}
                           ARCHIVE_OUTPUT_DIRECTORY ${LIB_STAGE_PATH}
@@ -245,7 +245,7 @@ macro(module)
       else()
         install(TARGETS ${_LIB_NAME} LIBRARY DESTINATION "${LIB_DIR}")
       endif()
-    endif()                          
+    endif()
     if (_ARG_LINK)
       target_link_libraries(${_LIB_NAME} ${_ARG_LINK})
     endif()
@@ -257,11 +257,11 @@ macro(module)
     endif()
   else()
     add_custom_target("${_LIB_NAME}" ALL)
-    set_target_properties("${_LIB_NAME}" PROPERTIES HEADER_ONLY 1 
+    set_target_properties("${_LIB_NAME}" PROPERTIES HEADER_ONLY 1
                           MODULE_DEPS "${_ARG_DEPENDS_ON}")
   endif()
   #-----------------------------------------------------------------------------
-  # stage headers  
+  # stage headers
   #-----------------------------------------------------------------------------
   if (_ARG_HEADERS)
     stage_and_install_headers("${_ARG_HEADERS}" "${_HEADER_OUTPUT_DIR}" "${_LIB_NAME}")
@@ -302,7 +302,7 @@ endmacro()
 #  Compile, link and stage a C++ executable
 #-------------------------------------------------------------------------------
 macro(executable)
-  parse_argument_list(_ARG 
+  parse_argument_list(_ARG
                       "NAME;SOURCES;LINK;DEPENDS_ON" "NO_RPATH;STATIC" ${ARGN})
   if (NOT _ARG_NAME)
     message(FATAL_ERROR "invalid use of executable(): a name must be provided")
@@ -344,21 +344,21 @@ endmacro()
 #  Compile, link and stage a C++ executable into the libexec directory
 #-------------------------------------------------------------------------------
 macro(executable_libexec)
-  parse_argument_list(_ARG 
+  parse_argument_list(_ARG
                       "NAME;SOURCES;LINK;DEPENDS_ON" "NO_RPATH;STATIC" ${ARGN})
   if (NOT _ARG_NAME)
     message(FATAL_ERROR "invalid use of executable(): a name must be provided")
-  endif()   
+  endif()
   add_executable(${_ARG_NAME} ${_ARG_SOURCES})
   set_target_properties(${_ARG_NAME}
                         PROPERTIES RUNTIME_OUTPUT_DIRECTORY
-                       "${LIBEXEC_STAGE_PATH}")  
+                       "${LIBEXEC_STAGE_PATH}")
   set_target_properties(${_ARG_NAME}
                         PROPERTIES RUNTIME_OUTPUT_DIRECTORY_RELEASE
-                       "${LIBEXEC_STAGE_PATH}")  
+                       "${LIBEXEC_STAGE_PATH}")
   set_target_properties(${_ARG_NAME}
                         PROPERTIES RUNTIME_OUTPUT_DIRECTORY_DEBUG
-                       "${LIBEXEC_STAGE_PATH}")  
+                       "${LIBEXEC_STAGE_PATH}")
   if (NOT _ARG_NO_RPATH AND NOT _ARG_STATIC)
     if (APPLE)
       set_target_properties(${_ARG_NAME} PROPERTIES
@@ -373,7 +373,7 @@ macro(executable_libexec)
   if (ENABLE_STATIC AND _ARG_STATIC)
     target_link_libraries(${_ARG_NAME} ${STATIC_LIBRARIES})
     set_target_properties(${_ARG_NAME}
-                          PROPERTIES LINK_SEARCH_END_STATIC TRUE)  
+                          PROPERTIES LINK_SEARCH_END_STATIC TRUE)
 
   endif()
   foreach(_DEP ${_ARG_DEPENDS_ON})
@@ -388,7 +388,7 @@ endmacro()
 #
 #-------------------------------------------------------------------------------
 macro(substitute)
- parse_argument_list(_ARG 
+ parse_argument_list(_ARG
                      "IN_FILE;OUT_FILE;DICT" "" ${ARGN})
   if (NOT _ARG_IN_FILE)
     message(FATAL_ERROR "invalid use of substitute(): no IN_FILE given")
@@ -400,7 +400,7 @@ macro(substitute)
   foreach(_SUBST ${_ARG_DICT})
     list(APPEND _SUBST_DICT -D${_SUBST})
   endforeach()
-  add_custom_target(subst_${_ARG_OUT_FILE} ALL COMMAND 
+  add_custom_target(subst_${_ARG_OUT_FILE} ALL COMMAND
                     ${CMAKE_COMMAND} ${_SUBST_DICT}
                     -P ${CMAKE_SOURCE_DIR}/cmake_support/substitute.cmake)
 endmacro()
@@ -412,7 +412,7 @@ endmacro()
 #-------------------------------------------------------------------------------
 macro(script)
   set(_ARG_OUTPUT_DIR bin)
-  parse_argument_list(_ARG 
+  parse_argument_list(_ARG
                       "NAME;INPUT;SUBSTITUTE;TARGET;OUTPUT_DIR" "" ${ARGN})
   if (NOT _ARG_NAME)
     message(FATAL_ERROR "invalid use of executable(): a name must be provided")
@@ -423,16 +423,16 @@ macro(script)
   endif()
   if (_ARG_SUBSTITUTE)
     if (NOT _ARG_INPUT)
-      message(FATAL_ERROR "script() can only substitute when INPUT is present.")    
+      message(FATAL_ERROR "script() can only substitute when INPUT is present.")
     endif()
 
-    substitute(IN_FILE "${CMAKE_CURRENT_SOURCE_DIR}/${_INPUT}" OUT_FILE ${_ARG_NAME} 
+    substitute(IN_FILE "${CMAKE_CURRENT_SOURCE_DIR}/${_INPUT}" OUT_FILE ${_ARG_NAME}
                DICT ${_ARG_SUBSTITUTE})
   endif()
-  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${_ARG_NAME} DESTINATION ${_ARG_OUTPUT_DIR} 
-          PERMISSIONS WORLD_EXECUTE GROUP_EXECUTE OWNER_EXECUTE 
+  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${_ARG_NAME} DESTINATION ${_ARG_OUTPUT_DIR}
+          PERMISSIONS WORLD_EXECUTE GROUP_EXECUTE OWNER_EXECUTE
                       WORLD_READ GROUP_READ OWNER_READ)
-  copy_if_different("./" "${STAGE_DIR}/${_ARG_OUTPUT_DIR}" 
+  copy_if_different("./" "${STAGE_DIR}/${_ARG_OUTPUT_DIR}"
                     "${_ARG_NAME}" "TARGETS" ${_ARG_TARGET})
   add_dependencies(${_ARG_TARGET} subst_${_ARG_NAME})
 endmacro()
@@ -442,8 +442,8 @@ endmacro()
 #   ui_to_python(libname stagedir[input_file1 ...])
 # Description:
 #   Calls pyuic on every input file. The resulting python files are stored in
-#   the variable with name out_files. Use with care. Has originally been 
-#   implemented for pyuic4 and ported to pyuic5 without testing. 
+#   the variable with name out_files. Use with care. Has originally been
+#   implemented for pyuic4 and ported to pyuic5 without testing.
 #-------------------------------------------------------------------------------
 macro(ui_to_python LIBNAME PYMODDIR STAGEDIR)
   set(_input_files ${ARGN})
@@ -451,8 +451,8 @@ macro(ui_to_python LIBNAME PYMODDIR STAGEDIR)
   add_dependencies("_${LIBNAME}" "${LIBNAME}_ui")
   find_program(_PYUIC_EXECUTABLE
     NAMES pyuic5-${Python_VERSION} pyuic5 pyuic pyuic5.bat
-    PATHS  ENV PATH 
-  )  
+    PATHS  ENV PATH
+  )
   if(NOT _PYUIC_EXECUTABLE)
     message(FATAL_ERROR "Could not find pyuic command in " ${QT_BINARY_DIR} " for python version " ${Python_VERSION})
   endif(NOT _PYUIC_EXECUTABLE)
@@ -499,11 +499,11 @@ endmacro()
 
 #-------------------------------------------------------------------------------
 # Synopsis:
-#   pymod(NAME name CPP source1 source2 PY source source2 [IN_DIR dir] 
+#   pymod(NAME name CPP source1 source2 PY source source2 [IN_DIR dir]
 #         source3 source4 [IN_DIR dir] [LINK link] [OUTPUT_DIR dir] [UI user_interface_files])
 #
 # Description:
-#  Define a python module consisting of C++ type wrappers and/or code written in 
+#  Define a python module consisting of C++ type wrappers and/or code written in
 #  Python. user_interface_files are handled with ui_to_python that has blindly
 #  been ported from QT4 to QT5 without testing. Use with care.
 # NAME is the name of
@@ -513,7 +513,7 @@ macro(pymod)
   # deal with arguments
   #-----------------------------------------------------------------------------
   set(_ARG_PREFIX ost)
-  parse_argument_list(_ARG 
+  parse_argument_list(_ARG
                       "NAME;CPP;PY;LINK;OUTPUT_DIR;UI;PREFIX" "" ${ARGN})
   if (NOT _ARG_NAME)
     message(FATAL_ERROR "invalid use of pymod(): a name must be provided")
@@ -548,8 +548,7 @@ macro(pymod)
     if (NOT _CUSTOM_CHECK)
       set(_PARENT_LIB_NAME "${_PARENT_NAME}")
     endif()
-    target_link_libraries("_${_LIB_NAME}" ${_PARENT_LIB_NAME} 
-                          ${Python_LIBRARIES} ${BOOST_PYTHON_LIBRARIES})
+    target_link_libraries("_${_LIB_NAME}" ${_PARENT_LIB_NAME} ${BOOST_PYTHON_LIBRARIES})
 
     set_target_properties("_${_LIB_NAME}"
                           PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${PYMOD_STAGE_DIR})
@@ -573,7 +572,7 @@ macro(pymod)
       set_target_properties("_${_LIB_NAME}" PROPERTIES
                             LINK_FLAGS "-Wl,-rpath,@loader_path/${_REL_PATH}"
                             INSTALL_NAME_DIR "@rpath")
-    endif()                          
+    endif()
     if (NOT WIN32)
       set_target_properties("_${_LIB_NAME}"
                           PROPERTIES PREFIX "")
@@ -591,7 +590,7 @@ macro(pymod)
   #-----------------------------------------------------------------------------
   if (_ARG_UI)
     ui_to_python(${_LIB_NAME} ${PYMOD_DIR} ${PYMOD_STAGE_DIR} ${_ARG_UI})
-  endif()  
+  endif()
   #-----------------------------------------------------------------------------
   # compile python files
   #-----------------------------------------------------------------------------
@@ -616,7 +615,7 @@ macro(pymod)
       compile_py_files(_${_LIB_NAME} ${PYMOD_STAGE_DIR}/${_DIR} compiled_files ${_ABS_PY_FILES})
       install(FILES ${compiled_files} DESTINATION "${LIB_DIR}/${PYMOD_DIR}/${_DIR}")
     endforeach()
-  endif()  
+  endif()
   get_target_property(_MOD_DEPS "${_PARENT_NAME}" MODULE_DEPS)
   if(_MOD_DEPS)
     foreach(dep ${_MOD_DEPS})
@@ -639,7 +638,7 @@ endif()
 #-------------------------------------------------------------------------------
 macro(ost_unittest)
   set(_ARG_PREFIX ost)
-  parse_argument_list(_ARG 
+  parse_argument_list(_ARG
                       "MODULE;PREFIX;SOURCES;LINK" "" ${ARGN})
     set(_SOURCES ${_ARG_SOURCES})
     set(CPP_TESTS)
@@ -647,7 +646,7 @@ macro(ost_unittest)
     set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}/tests")
     foreach(src ${_SOURCES})
       if (${src} MATCHES "\\.py$")
-       list(APPEND PY_TESTS "${src}")      
+       list(APPEND PY_TESTS "${src}")
       else()
         list(APPEND CPP_TESTS "${CMAKE_CURRENT_SOURCE_DIR}/${src}")
      endif()
@@ -669,7 +668,7 @@ macro(ost_unittest)
         set(TEST_COMMAND ${CMAKE_CURRENT_BINARY_DIR}/${_test_name}.exe || echo)
         message(${TEST_COMMAND})
         set(ENV{PP} ${STAGE_DIR}/bin)
-        add_custom_target("${_test_name}_run" 
+        add_custom_target("${_test_name}_run"
                         COMMAND echo %PP%
                         WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
                         COMMENT "running checks for module ${_ARG_MODULE}"
@@ -692,7 +691,7 @@ macro(ost_unittest)
         add_dependencies(check_xml "${_test_name}_run_xml")
         add_dependencies(check "${_test_name}_run")
       endif()
-      
+
       if (_ARG_LINK)
         target_link_libraries("${_test_name}" ${_ARG_LINK})
       endif()
@@ -734,12 +733,12 @@ macro(ost_unittest)
         add_dependencies(check "${py_test}_run")
         add_dependencies(check_xml "${py_test}_run_xml")
       endif()
-      
+
     endforeach()
-    
+
     # get_target_property(OUTT ${_test_name} GENERATOR_FILE_NAME)
     # message("${OUTT}")
-    
+
     # get_target_property(OUTT check GENERATOR_FILE_NAME)
     # message("${OUTT}")
 endmacro()
@@ -788,13 +787,13 @@ macro(ost_find_python_module_alt MODULES)
   endforeach(py_mod ${MODULES})
   if (_IMPORT_ERROR)
     message(FATAL_ERROR "Could not find one of python modules ${_PY_MODS}. Please install one of them.")
-  endif ()    
+  endif ()
 endmacro()
 
 #-------------------------------------------------------------------------------
 # this macro tries to detect a very common problem during configuration stage:
-# it makes sure that boost python is linked against the same version of python 
-# that we are linking against. 
+# it makes sure that boost python is linked against the same version of python
+# that we are linking against.
 #-------------------------------------------------------------------------------
 macro(ost_match_boost_python_version)
   include(CheckCXXSourceRuns)
@@ -806,7 +805,7 @@ macro(ost_match_boost_python_version)
   if (_BP_LENGTH GREATER 1)
     list(FIND _BOOST_PYTHON_LIBRARY optimized _OPTIMIZED_INDEX)
     if (_OPTIMIZED_INDEX EQUAL -1)
-      message(FATAL_ERROR 
+      message(FATAL_ERROR
               "Error while trying to get path of boost python library")
     endif()
     math(EXPR _LIB_INDEX 1+${_OPTIMIZED_INDEX})
@@ -818,7 +817,7 @@ macro(ost_match_boost_python_version)
 "#include <boost/python.hpp>
 
 using namespace boost::python;
-                           
+
 int main( int argc, char ** argv ) {
   try {
     Py_Initialize();
@@ -835,7 +834,7 @@ int main( int argc, char ** argv ) {
   } catch( error_already_set ) {
     PyErr_Print();
     return 1;
-  }   
+  }
   return 0;
 }" PYTHON_VERSION_FOUND_MATCHES_PYTHON_VERSION_BOOST_WAS_COMPILED_WITH)
 
@@ -864,14 +863,8 @@ macro(setup_stage)
   if (UNIX AND NOT APPLE)
     check_architecture()
   endif()
-  set (ARCH ${CMAKE_NATIVE_ARCH})
-  if ("${ARCH}" MATCHES "64" AND NOT _UBUNTU_LAYOUT)
-    set(LIB_DIR lib64  )
-    set(LIB_STAGE_PATH "${STAGE_DIR}/lib64"  )
-  else()
-    set(LIB_DIR lib  )
-    set(LIB_STAGE_PATH "${STAGE_DIR}/lib"  )
-  endif()
+  set(LIB_DIR lib  )
+  set(LIB_STAGE_PATH "${STAGE_DIR}/lib"  )
   if (_UBUNTU_LAYOUT)
     set(LIBEXEC_PATH ${LIB_DIR}/openstructure/libexec  )
     set(LIBEXEC_STAGE_PATH ${LIB_STAGE_PATH}/openstructure/libexec  )
@@ -879,7 +872,7 @@ macro(setup_stage)
     set(LIBEXEC_PATH libexec/openstructure  )
     set(LIBEXEC_STAGE_PATH ${STAGE_DIR}/libexec/openstructure  )
   endif()
- 
+
   include_directories("${HEADER_STAGE_PATH}")
   link_directories(${LIB_STAGE_PATH})
 
@@ -1014,10 +1007,10 @@ endmacro(ost_action_init)
 #-------------------------------------------------------------------------------
 macro(ost_action ACTION TARGET)
   copy_if_different("${CMAKE_CURRENT_SOURCE_DIR}"
-                    "${STAGE_DIR}/${LIBEXEC_PATH}" 
+                    "${STAGE_DIR}/${LIBEXEC_PATH}"
                     "${ACTION}" "TARGETS" ${TARGET})
   install(FILES "${ACTION}" DESTINATION "${LIBEXEC_PATH}"
-          PERMISSIONS WORLD_EXECUTE GROUP_EXECUTE OWNER_EXECUTE 
+          PERMISSIONS WORLD_EXECUTE GROUP_EXECUTE OWNER_EXECUTE
                       WORLD_READ GROUP_READ OWNER_READ)
   # storing tool names for bash completion
   string(REGEX REPLACE "^ost-" "" stripped_action ${ACTION})
diff --git a/modules/conop/src/chemdict_tool.cc b/modules/conop/src/chemdict_tool.cc
index 08b11ae0d..192154dbf 100644
--- a/modules/conop/src/chemdict_tool.cc
+++ b/modules/conop/src/chemdict_tool.cc
@@ -24,7 +24,7 @@
 #include <iostream>
 #include <fstream>
 #include <boost/algorithm/string.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/iostreams/filtering_stream.hpp>
 #include <boost/iostreams/filter/gzip.hpp>
 
@@ -86,14 +86,15 @@ int main(int argc, char const *argv[])
       return 1;
     }
   }
-  boost::iostreams::filtering_stream<boost::iostreams::input>  filtered_istream;  
+  boost::iostreams::filtering_stream<boost::iostreams::input>  filtered_istream;
   std::ifstream istream(argv[2]);
   if (! istream.is_open()) {
       std::cout << "Cannot open " << argv[2] << ": [Errno " << errno << "] "
                 << strerror(errno) << std::endl;
       return 1;
   }
-  if (boost::iequals(".gz", boost::filesystem::extension(argv[2]))) {
+  boost::filesystem::path file_path(argv[2]);
+  if (boost::iequals(file_path.extension().string(), ".gz")) {
     filtered_istream.push(boost::iostreams::gzip_decompressor());
   }
   filtered_istream.push(istream);
diff --git a/modules/gui/src/CMakeLists.txt b/modules/gui/src/CMakeLists.txt
index e475fbdde..4def38754 100644
--- a/modules/gui/src/CMakeLists.txt
+++ b/modules/gui/src/CMakeLists.txt
@@ -437,7 +437,7 @@ endif()
 set(QT_USE_QTOPENGL 1)
 set(QT_USE_QTNETWORK 1)
 
-qt5_wrap_cpp(OST_GUI_MOCS "${HEADERS_TO_BE_MOCCED}" 
+qt5_wrap_cpp(OST_GUI_MOCS "${HEADERS_TO_BE_MOCCED}"
              OPTIONS -DBOOST_TT_HAS_OPERATOR_HPP_INCLUDED
                      -DBOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
 module(NAME gui SOURCES ${OST_GUI_MOCS} ${OST_GUI_SOURCES}
@@ -452,13 +452,12 @@ module(NAME gui SOURCES ${OST_GUI_MOCS} ${OST_GUI_SOURCES}
                ${OST_GUI_HEADERS}
        DEPENDS_ON ost_gfx ost_io ost_mol_alg ost_seq_alg
        LINK ${QT_LIBRARIES}
-            ${Python_LIBRARIES} 
             ${BOOST_PYTHON_LIBRARIES}
             ${SPNAV_LIBRARIES}
         NO_STATIC)
 
 
-   
+
 if (ADDITIONAL_LIBRARIES)
   target_link_libraries(ost_gui "${ADDITIONAL_LIBRARIES}")
 endif()
@@ -469,11 +468,18 @@ qt5_wrap_cpp(OST_GOSTY_MOC "gosty.hh"
              OPTIONS -DBOOST_TT_HAS_OPERATOR_HPP_INCLUDED
                      -DBOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
 
-set(LINK LINK ${QT_LIBRARIES} ${BOOST_PROGRAM_OPTIONS_LIBRARIES})
+find_package(Python 3 COMPONENTS Interpreter Development REQUIRED)
+
+set(GOSTY_LINK_LIBS
+    ${QT_LIBRARIES}
+    ${BOOST_PROGRAM_OPTIONS_LIBRARIES}
+    Python::Python)
+
+executable_libexec(NAME gosty
+                   SOURCES gosty.cc ${OST_GOSTY_MOC} ${OST_QT_RESOURCE}
+                   DEPENDS_ON ost_gui
+                   LINK ${GOSTY_LINK_LIBS})
 
-executable_libexec(NAME gosty SOURCES gosty.cc ${OST_GOSTY_MOC}
-                   ${OST_QT_RESOURCE} DEPENDS_ON ost_gui ${LINK})
-           
 file(GLOB MOC_CXX_FILES moc_*.cxx)
 
 if (MOC_CXX_FILES)
diff --git a/modules/gui/src/gosty.cc b/modules/gui/src/gosty.cc
index 689cbf9ee..f8e8d3c3e 100644
--- a/modules/gui/src/gosty.cc
+++ b/modules/gui/src/gosty.cc
@@ -52,7 +52,7 @@ DelayedScriptExecutor::DelayedScriptExecutor()
 }
 void DelayedScriptExecutor::Exec()
 {
-  PythonInterpreter& interp=PythonInterpreter::Instance();  
+  PythonInterpreter& interp=PythonInterpreter::Instance();
   interp.Start();
 }
 
@@ -60,20 +60,20 @@ void DelayedScriptExecutor::Exec()
 
 namespace {
 
-static void sigint_handler(int) 
-{ 
-  std::cerr << "shutting down..." << std::endl; 
+static void sigint_handler(int)
+{
+  std::cerr << "shutting down..." << std::endl;
   QApplication::exit(-1);
-} 
+}
 
-static void reclaim_signals() 
-{ 
+static void reclaim_signals()
+{
 #ifndef _MSC_VER
-  struct sigaction sa; 
-  sa.sa_sigaction=0; // first assign this in case sigaction is union 
-  sa.sa_handler = sigint_handler; 
-  sa.sa_mask = sigset_t(); 
-  sa.sa_flags = 0; 
+  struct sigaction sa;
+  sa.sa_sigaction=0; // first assign this in case sigaction is union
+  sa.sa_handler = sigint_handler;
+  sa.sa_mask = sigset_t();
+  sa.sa_flags = 0;
   sigaction(SIGINT, &sa, 0);
 #endif
 }
@@ -82,7 +82,7 @@ String get_ost_root()
 {
   QDir dir(QApplication::applicationDirPath());
 
-#if OST_UBUNTU_LAYOUT  
+#if OST_UBUNTU_LAYOUT
   #ifdef _MSC_VER
     dir.cdUp();
     dir.cdUp();
@@ -110,20 +110,16 @@ String setup_python_search_path(const String& root, PythonInterpreter& pi)
   site_pkgs << "python" << PY_MAJOR_VERSION << "." << PY_MINOR_VERSION;
 #ifdef _MSC_VER
   String loc=root+"\\lib\\"+site_pkgs.str()+"\\site-packages";
-#else  
-# if (defined(__ppc64__) || defined(__x86_64__)) && !defined(__APPLE__) && !OST_UBUNTU_LAYOUT
-  String loc=root+"/lib64/"+site_pkgs.str()+"/site-packages";
-# else
+#else
   String loc=root+"/lib/"+site_pkgs.str()+"/site-packages";
-# endif
 #endif
   pi.AppendModulePath(QString::fromStdString(loc));
   // dng is an interactive python session, so add '.' to search path
-  pi.AppendModulePath(".");  
+  pi.AppendModulePath(".");
   return loc;
 }
-  
-int setup_resources(QApplication& app) 
+
+int setup_resources(QApplication& app)
 {
   QResource qr(":/images");
    if(!qr.isValid()) {
@@ -134,9 +130,9 @@ int setup_resources(QApplication& app)
    int i=0;
    QIcon icon;
    while (sizes[i]>0) {
-    icon.addFile(QString(":images/icon")+QString::number(sizes[i]), 
+    icon.addFile(QString(":images/icon")+QString::number(sizes[i]),
                  QSize(sizes[i], sizes[i]));
-    ++i; 
+    ++i;
    }
    app.setWindowIcon(icon);
    return 0;
@@ -147,7 +143,7 @@ void read_logger_settings(const QString& group_name, TextLogger* logger)
 {
   QSettings settings;
   settings.beginGroup("logging");
-  settings.beginGroup(group_name);   
+  settings.beginGroup(group_name);
   logger->SetCodeLogging(settings.value("log_code",QVariant(false)).toBool());
   logger->SetOutputLogging(settings.value("log_output",QVariant(true)).toBool());
   logger->SetErrorLogging(settings.value("log_error",QVariant(true)).toBool());
@@ -171,17 +167,17 @@ int init_python_interpreter()
   TextLogger* console_logger=new TextLogger(stdout);
   read_logger_settings("console", console_logger);
   if (console_logger->GetErrorLogging()) {
-    QObject::connect(&PythonInterpreter::Instance(),  
+    QObject::connect(&PythonInterpreter::Instance(),
                      SIGNAL(ErrorOutput(unsigned int, const QString &)),
                      console_logger,
                      SLOT(AppendOutput(unsigned int, const QString &)));
   }
   if (console_logger->GetOutputLogging()) {
-    QObject::connect(&PythonInterpreter::Instance(), 
+    QObject::connect(&PythonInterpreter::Instance(),
                      SIGNAL(Output(unsigned int, const QString &)),
                      console_logger,
                      SLOT(AppendOutput(unsigned int, const QString &)));
-  }  
+  }
   String python_loc=setup_python_search_path(root, py);
   //py.RunCommand("from ost import *");
   //py.RunCommand("gui_mode=True");
@@ -189,7 +185,7 @@ int init_python_interpreter()
   script_path << python_loc;
 #ifdef _MSC_VER
   script_path << "\\ost\\gui\\";
-#else  
+#else
   script_path << "/ost/gui/";
 #endif
   script_path << "gosty_startup.py";
diff --git a/modules/gui/src/python_shell/python_interpreter.cc b/modules/gui/src/python_shell/python_interpreter.cc
index 4c2afae41..4e4c73b38 100644
--- a/modules/gui/src/python_shell/python_interpreter.cc
+++ b/modules/gui/src/python_shell/python_interpreter.cc
@@ -29,7 +29,7 @@
 #include <string>
 #include <fstream>
 
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <ost/log.hh>
 
 #include <QFile>
@@ -122,8 +122,8 @@ CodeBlockStatus PythonInterpreter::GetCodeBlockStatus(const QString& command)
 /*#ifndef _MSC_VER
   SigIntHandler sh(sig_act_);
 #endif*/
-  QStringList lines=command.split("\n");  
-  String cmd;  
+  QStringList lines=command.split("\n");
+  String cmd;
   for (int i=0; i<lines.size(); ++i) {
     if (status==CODE_BLOCK_ERROR) {
       break;
@@ -145,7 +145,7 @@ CodeBlockStatus PythonInterpreter::GetCodeBlockStatus(const QString& command)
           status=CODE_BLOCK_COMPLETE;
         } catch(bp::error_already_set&) {
           status=CODE_BLOCK_INCOMPLETE;
-          ++i;          
+          ++i;
           PyErr_Clear();
         }
       } catch(bp::error_already_set&) {
diff --git a/modules/img/base/src/phase.cc b/modules/img/base/src/phase.cc
index 8c61d6e34..35049327d 100644
--- a/modules/img/base/src/phase.cc
+++ b/modules/img/base/src/phase.cc
@@ -1,3 +1,9 @@
+
+
+
+
+
+
 //------------------------------------------------------------------------------
 // This file is part of the OpenStructure project <www.openstructure.org>
 //
@@ -61,8 +67,8 @@ const Phase Phase::operator-=(const Phase& rhs)
 Phase Phase::operator-() const
 {
   return Phase(-angle_);
-} 
-  
+}
+
 const Phase Phase::operator*=(Real d)
 {
   angle_=reduce(angle_*d);
diff --git a/modules/io/src/img/map_io_dx_handler.cc b/modules/io/src/img/map_io_dx_handler.cc
index ef43ef502..b557051b3 100644
--- a/modules/io/src/img/map_io_dx_handler.cc
+++ b/modules/io/src/img/map_io_dx_handler.cc
@@ -28,7 +28,7 @@
 #include <boost/iostreams/filter/gzip.hpp>
 #include <boost/iostreams/filtering_stream.hpp>
 #include <boost/filesystem/fstream.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/lexical_cast.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/algorithm/string/trim.hpp>
@@ -72,7 +72,7 @@ String DX::FORMAT_STRING="defined_dx";
 
 DX::DX (bool normalize_on_save):
   ImageFormatBase(FORMAT_STRING),
-  normalize_on_save_(normalize_on_save) 
+  normalize_on_save_(normalize_on_save)
 {
 }
 
@@ -94,7 +94,7 @@ void MapIODxHandler::Import(img::MapHandle& mh, const bf::path& loc,const ImageF
     throw IOException("could not open "+loc.string());
   }
   boost::iostreams::filtering_stream<boost::iostreams::input> in;
-  if (boost::iequals(".gz", boost::filesystem::extension(loc))) {
+  if (boost::iequals(".gz", boost::filesystem::path(loc).extension().string())) {
     in.push(boost::iostreams::gzip_decompressor());
   }
   in.push(infile);
@@ -213,7 +213,7 @@ void MapIODxHandler::Import(img::MapHandle& mh, std::istream& infile, const Imag
         w_spacing=deltas[2][2];
         LOG_DEBUG("          and spatial sampling " << geom::Vec3(u_spacing,v_spacing,w_spacing));
         mh2.SetSpatialSampling(geom::Vec3(u_spacing,v_spacing,w_spacing));
-      } 
+      }
 
       // and read in the values
       // TODO: this is glacially slow
@@ -269,8 +269,8 @@ void MapIODxHandler::Export(const img::MapHandle& mh2,
   geom::Vec3 spa=mh2.GetSpatialSampling();
   outstring << format("origin %.6e %.6e %.6e") % ori[0] % ori[1] % ori[2] << std::endl;
   outstring << format("delta %.6e 0.000000e+00 0.000000e+00") % spa[0] << std::endl;
-  outstring << format("delta 0.000000e+00 %.6e 0.000000e+00") % spa[1] << std::endl; 
-  outstring << format("delta 0.000000e+00 0.000000e+00 %.6e") % spa[2] << std::endl; 
+  outstring << format("delta 0.000000e+00 %.6e 0.000000e+00") % spa[1] << std::endl;
+  outstring << format("delta 0.000000e+00 0.000000e+00 %.6e") % spa[2] << std::endl;
   outstring << "object 2 class gridconnections counts " << u_size << " " << v_size << " " << w_size << std::endl;
   outstring << "object 3 class array type Real rank 0 items " << num_gridpoints << " data follows" << std::endl;
 
diff --git a/modules/io/src/mol/dcd_io.cc b/modules/io/src/mol/dcd_io.cc
index d70074433..d55ec82db 100644
--- a/modules/io/src/mol/dcd_io.cc
+++ b/modules/io/src/mol/dcd_io.cc
@@ -25,7 +25,7 @@
 #include <algorithm>
 
 #include <boost/iostreams/filter/gzip.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 
 #include <ost/stdint.hh>
 #include <ost/log.hh>
@@ -43,7 +43,7 @@
 
 namespace ost { namespace io {
 
-/* 
+/*
    icntrl[1]: number of coordinate sets in file
    icntrl[2]: number of previous dynamic steps
    icntrl[3]: frequency for saving coordinates
@@ -66,13 +66,13 @@ bool less_index(const mol::AtomHandle& a1, const mol::AtomHandle& a2)
   return a1.GetIndex()<a2.GetIndex();
 }
 
-bool read_dcd_header(std::istream& istream, DCDHeader& header, bool& swap_flag, 
+bool read_dcd_header(std::istream& istream, DCDHeader& header, bool& swap_flag,
                      bool& ucell_flag, bool& gap_flag, bool detect_swap, bool byte_swap)
 {
   if (!istream) {
     return false;
   }
-  char dummy[4];  
+  char dummy[4];
   gap_flag=true;
   swap_flag = detect_swap ? false : byte_swap;
 
@@ -134,7 +134,7 @@ bool read_dcd_header(std::istream& istream, DCDHeader& header, bool& swap_flag,
   istream.read(&title[0],sizeof(char)*header.ntitle);
   header.title=std::string(&title[0],header.ntitle);
   LOG_VERBOSE("LoadCHARMMTraj: title string [" << header.title << "]")
-  
+
   if(gap_flag) istream.read(dummy,sizeof(dummy));
   istream.read(reinterpret_cast<char*>(&header.t_atom_count),sizeof(int));
   if(swap_flag) swap_int(&header.t_atom_count,1);
@@ -162,9 +162,9 @@ size_t calc_frame_size(bool ucell_flag, bool gap_flag, size_t num_atoms)
   return frame_size;
 }
 
-  
-bool read_frame(std::istream& istream, const DCDHeader& header, 
-                size_t frame_size, bool ucell_flag, bool gap_flag, 
+
+bool read_frame(std::istream& istream, const DCDHeader& header,
+                size_t frame_size, bool ucell_flag, bool gap_flag,
                 bool swap_flag, std::vector<float>& xlist,
                 std::vector<geom::Vec3>& frame,
                 uint frame_num,geom::Vec3& cell_size,geom::Vec3& cell_angles)
@@ -238,17 +238,17 @@ bool read_frame(std::istream& istream, const DCDHeader& header,
   return true;
 }
 
-bool read_frame(std::istream& istream, const DCDHeader& header, 
-                size_t frame_size, bool ucell_flag, bool gap_flag, 
+bool read_frame(std::istream& istream, const DCDHeader& header,
+                size_t frame_size, bool ucell_flag, bool gap_flag,
                 bool swap_flag, std::vector<float>& xlist,
                 std::vector<geom::Vec3>& frame,uint frame_num)
 {
   geom::Vec3 cell_size=geom::Vec3(),cell_angles=geom::Vec3();
-  return read_frame(istream,header, frame_size,ucell_flag, gap_flag, 
+  return read_frame(istream,header, frame_size,ucell_flag, gap_flag,
                     swap_flag, xlist,frame,frame_num, cell_size, cell_angles);
 }
-  
-  
+
+
 mol::CoordGroupHandle load_dcd(const mol::AtomHandleList& alist, // this atom list is already sorted!
                                const String& trj_fn,
                                unsigned int stride,
@@ -263,12 +263,12 @@ mol::CoordGroupHandle load_dcd(const mol::AtomHandleList& alist, // this atom li
   }
   Profile profile_load("LoadCHARMMTraj");
 
-  DCDHeader header; 
+  DCDHeader header;
   bool swap_flag=false, ucell_flag=false, gap_flag=false;
   read_dcd_header(istream, header, swap_flag, ucell_flag, gap_flag, detect_swap, byte_swap);
   if(alist.size() != static_cast<size_t>(header.t_atom_count)) {
-    LOG_ERROR("LoadCHARMMTraj: atom count mismatch: " << alist.size() 
-               << " in coordinate file, " << header.t_atom_count 
+    LOG_ERROR("LoadCHARMMTraj: atom count mismatch: " << alist.size()
+               << " in coordinate file, " << header.t_atom_count
                << " in each traj frame");
     throw(IOException("invalid trajectory"));
   }
@@ -280,7 +280,7 @@ mol::CoordGroupHandle load_dcd(const mol::AtomHandleList& alist, // this atom li
   size_t frame_size=calc_frame_size(ucell_flag, gap_flag, xlist.size());
   int i=0;
   while(true){
-    if (!read_frame(istream, header, frame_size, ucell_flag, gap_flag, 
+    if (!read_frame(istream, header, frame_size, ucell_flag, gap_flag,
                     swap_flag, xlist, clist, i,cell_size,cell_angles)) {
       break;
     }
@@ -308,9 +308,9 @@ mol::CoordGroupHandle load_dcd(const mol::AtomHandleList& alist, // this atom li
 
 class  DCDCoordSource : public mol::CoordSource {
 public:
-  DCDCoordSource(const mol::AtomHandleList& atoms, const String& filename, 
-                 uint stride, bool detect_swap, bool byte_swap): 
-    mol::CoordSource(atoms), filename_(filename), 
+  DCDCoordSource(const mol::AtomHandleList& atoms, const String& filename,
+                 uint stride, bool detect_swap, bool byte_swap):
+    mol::CoordSource(atoms), filename_(filename),
     stream_(filename.c_str(), std::ios::binary), loaded_(false), stride_(stride),
     detect_swap_(detect_swap), byte_swap_(byte_swap)
   {
@@ -318,15 +318,15 @@ public:
     this->SetMutable(false);
     frame_=mol::CoordFramePtr(new mol::CoordFrame(atoms.size()));
   }
-    
-  
+
+
   virtual uint GetFrameCount() const
-  { 
+  {
     if (!frame_count_)
       const_cast<DCDCoordSource*>(this)->FetchFrame(0);
-    return frame_count_; 
+    return frame_count_;
   }
-  
+
   virtual mol::CoordFramePtr GetFrame(uint frame_id) const {
     const_cast<DCDCoordSource*>(this)->FetchFrame(frame_id);
     return frame_;
@@ -336,7 +336,7 @@ public:
   virtual void AddFrame(const std::vector<geom::Vec3>& coords,const geom::Vec3& box_size,const geom::Vec3& box_angles) {}
   virtual void InsertFrame(int pos, const std::vector<geom::Vec3>& coords) {}
 private:
-  
+
   void FetchFrame(uint frame);
   String               filename_;
   DCDHeader            header_;
@@ -362,14 +362,14 @@ void DCDCoordSource::FetchFrame(uint frame)
     loaded_=true;
     frame_count_=header_.num/stride_;
   }
-  size_t frame_size=calc_frame_size(ucell_flag_, gap_flag_, 
-                                    header_.t_atom_count);  
+  size_t frame_size=calc_frame_size(ucell_flag_, gap_flag_,
+                                    header_.t_atom_count);
   size_t pos=frame_start_+frame_size*frame*stride_;
   stream_.seekg(pos,std::ios_base::beg);
   std::vector<float> xlist(header_.t_atom_count);
-  if (!read_frame(stream_, header_, frame_size, ucell_flag_, gap_flag_, 
+  if (!read_frame(stream_, header_, frame_size, ucell_flag_, gap_flag_,
                   swap_flag_, xlist, *frame_.get(), frame)) {
-  }  
+  }
 }
 
 typedef boost::shared_ptr<DCDCoordSource> DCDCoordSourcePtr;
@@ -392,14 +392,14 @@ mol::CoordGroupHandle LoadCHARMMTraj(const mol::EntityHandle& ent,
     DCDCoordSourcePtr source(new DCDCoordSource(alist, trj_fn, stride, detect_swap, byte_swap));
     return mol::CoordGroupHandle(source);
   }
-  LOG_VERBOSE("LoadCHARMMTraj: importing with lazy_load=false");  
+  LOG_VERBOSE("LoadCHARMMTraj: importing with lazy_load=false");
   return load_dcd(alist, trj_fn, stride, detect_swap, byte_swap);
 }
 
 namespace {
 
 void write_dcd_hdr(std::ofstream& out,
-                   const mol::CoordGroupHandle& coord_group, 
+                   const mol::CoordGroupHandle& coord_group,
                    unsigned int stepsize)
 {
   // size of first header block in bytes
@@ -456,16 +456,16 @@ void write_dcd_hdr(std::ofstream& out,
 
   // atom count block
   out.write(reinterpret_cast<char*>(&four), 4);
-  int32_t atom_count=coord_group.GetAtomCount();  
+  int32_t atom_count=coord_group.GetAtomCount();
   out.write(reinterpret_cast<char*>(&atom_count), 4);
   out.write(reinterpret_cast<char*>(&four), 4);
 }
 } // anon ns
 
-void SaveCHARMMTraj(const mol::CoordGroupHandle& coord_group, 
+void SaveCHARMMTraj(const mol::CoordGroupHandle& coord_group,
                     const String& pdb_filename, const String& dcd_filename,
                     unsigned int stepsize, const IOProfile& profile)
-{  
+{
   if(stepsize==0) stepsize=1;
   if(!pdb_filename.empty()) {
     PDBWriter writer(pdb_filename, profile);
@@ -475,7 +475,7 @@ void SaveCHARMMTraj(const mol::CoordGroupHandle& coord_group,
   write_dcd_hdr(out, coord_group,stepsize);
   int frame_count=coord_group.GetFrameCount();
   int atom_count=coord_group.GetAtomCount();
-  
+
   std::vector<float> x(atom_count);
   std::vector<float> y(atom_count);
   std::vector<float> z(atom_count);
@@ -500,7 +500,7 @@ void SaveCHARMMTraj(const mol::CoordGroupHandle& coord_group,
 
 
     int k=0;
-    for (mol::CoordFrame::iterator j=frame->begin(), 
+    for (mol::CoordFrame::iterator j=frame->begin(),
          e=frame->end(); j!=e; ++j, ++k) {
       x[k]=float((*j)[0]);
       y[k]=float((*j)[1]);
diff --git a/modules/io/src/mol/entity_io_crd_handler.cc b/modules/io/src/mol/entity_io_crd_handler.cc
index 1c2c2327e..118b3a9f9 100644
--- a/modules/io/src/mol/entity_io_crd_handler.cc
+++ b/modules/io/src/mol/entity_io_crd_handler.cc
@@ -24,7 +24,7 @@
 #include <iomanip>
 
 #include <boost/iostreams/filter/gzip.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/lexical_cast.hpp>
 #include <boost/format.hpp>
@@ -60,10 +60,10 @@ CRDReader::CRDReader(const boost::filesystem::path& loc):
   infile_(loc),
   in_()
 {
-  if (boost::iequals(".gz", boost::filesystem::extension(loc))) {
-    in_.push(boost::iostreams::gzip_decompressor());    
+  if (boost::iequals(".gz", boost::filesystem::path(loc).extension().string())) {
+    in_.push(boost::iostreams::gzip_decompressor());
   }
-  in_.push(infile_);  
+  in_.push(infile_);
   if(!infile_) throw IOException("could not open "+loc.string());
 }
 
@@ -103,7 +103,7 @@ void CRDReader::Import(mol::EntityHandle& ent)
     }
 
   LOG_INFO("imported " << chain_count_ << " chains, " << residue_count_
-                << " residues, " << atom_count_ << " atoms");  
+                << " residues, " << atom_count_ << " atoms");
 }
 
 /// \brief Parsing for standard format
@@ -124,12 +124,12 @@ void CRDReader::ParseAndAddAtom(const String& line, mol::EntityHandle& ent)
                   boost::lexical_cast<Real>(boost::trim_copy(line.substr(41,9))));
 
   mol::ResidueKey rkey(rname);
-  
+
   // some postprocessing
   LOG_TRACE( "s_chain: [" << s_chain << "]" );
 
   mol::ResNum rnum(irnum);
-  
+
   // determine chain and residue update
   bool update_chain=false;
   bool update_residue=false;
@@ -147,11 +147,11 @@ void CRDReader::ParseAndAddAtom(const String& line, mol::EntityHandle& ent)
     update_residue=true;
   }
 
-  if(update_chain) {  
+  if(update_chain) {
     if (!(curr_chain_=ent.FindChain(s_chain))) {
-      LOG_DEBUG("new chain " << s_chain);      
+      LOG_DEBUG("new chain " << s_chain);
       curr_chain_=editor.InsertChain(s_chain);
-      ++chain_count_;      
+      ++chain_count_;
     }
   }
 
@@ -173,9 +173,9 @@ void CRDReader::ParseAndAddAtom(const String& line, mol::EntityHandle& ent)
 void CRDReader::ParseAndAddAtomExpanded(const String& line, mol::EntityHandle& ent)
 {
   mol::XCSEditor editor=ent.EditXCS(mol::BUFFERED_EDIT);
-  
+
   LOG_TRACE( "line: [" << line << "]" );
-    
+
   //int anum = boost::lexical_cast<int>(boost::trim_copy(line.substr(0,5)));
   String aname = boost::trim_copy(line.substr(32,8));
   String ele = aname.substr(0,1);
@@ -186,14 +186,14 @@ void CRDReader::ParseAndAddAtomExpanded(const String& line, mol::EntityHandle& e
                   boost::lexical_cast<Real>(boost::trim_copy(line.substr(60,20))),
                   boost::lexical_cast<Real>(boost::trim_copy(line.substr(80,20))));
   Real b_factor = boost::lexical_cast<Real>(boost::trim_copy(line.substr(128,12)));
-    
+
   mol::ResidueKey rkey(rname);
-    
+
   // some postprocessing
   LOG_TRACE( "s_chain: [" << s_chain << "]" );
-    
+
   mol::ResNum rnum(irnum);
-  
+
   // determine chain and residue update
   bool update_chain=false;
   bool update_residue=false;
@@ -204,28 +204,28 @@ void CRDReader::ParseAndAddAtomExpanded(const String& line, mol::EntityHandle& e
     update_chain=true;
     update_residue=true;
   }
-    
+
   if(!curr_residue_) {
     update_residue=true;
   } else if(curr_residue_.GetNumber()!=rnum) {
     update_residue=true;
   }
-    
-  if(update_chain) {  
+
+  if(update_chain) {
     if (!(curr_chain_=ent.FindChain(s_chain))) {
-      LOG_DEBUG("new chain " << s_chain);      
+      LOG_DEBUG("new chain " << s_chain);
       curr_chain_=editor.InsertChain(s_chain);
-      ++chain_count_;      
+      ++chain_count_;
     }
   }
-    
+
   if(update_residue) {
     LOG_DEBUG("new residue " << rkey << " " << rnum);
     curr_residue_=editor.AppendResidue(curr_chain_, rkey, rnum);
     assert(curr_residue_.IsValid());
     ++residue_count_;
   }
-    
+
   // finally add atom
   LOG_DEBUG("adding atom " << aname << " (" << ele << ") @" << apos);
   mol::AtomHandle ah = editor.InsertAtom(curr_residue_, aname, apos, ele,
@@ -260,9 +260,9 @@ void CRDWriter::WriteHeader(const mol::EntityView& ent)
 {
   outstream_  << "* COOR FILE CREATED BY OPENSTRUCTURE" << std::endl;
   outstream_  << "*" << std::endl;
-  
+
   atom_total_ = ent.GetAtomCount();
-	
+
   if (atom_total_ > 99999 || ext_) {
     outstream_  << format("%10i") % ent.GetAtomCount() << "  EXT" << std::endl;
   }
@@ -315,7 +315,7 @@ bool CRDWriter::VisitAtom(const mol::AtomHandle& atom)
   if (e_name=="") {
     e_name="MOL";
   }
-	
+
   mol::ResidueHandle res=atom.GetResidue();
 
   if (atom_total_ > 99999 || ext_) {
@@ -404,7 +404,7 @@ bool EntityIOCRDHandler::ProvidesExport(const boost::filesystem::path& loc,
   return crd_handler_is_responsible_for(loc, type);
 }
 
-mol::EntityHandle LoadCRD(const String& file_name) 
+mol::EntityHandle LoadCRD(const String& file_name)
 {
   Profile profile_load("LoadCRD");
   CRDReader reader(file_name);
@@ -419,7 +419,7 @@ mol::EntityHandle LoadCRD(const String& file_name)
 }
 
 
-void EntityIOCRDHandler::Import(mol::EntityHandle& ent, 
+void EntityIOCRDHandler::Import(mol::EntityHandle& ent,
                                 std::istream& stream)
 {
   throw IOException("CRD format does not support import from stream");
diff --git a/modules/io/src/mol/entity_io_mae_handler.cc b/modules/io/src/mol/entity_io_mae_handler.cc
index 98e4a830f..cbc841aa4 100644
--- a/modules/io/src/mol/entity_io_mae_handler.cc
+++ b/modules/io/src/mol/entity_io_mae_handler.cc
@@ -28,7 +28,7 @@
 #include <ctype.h>
 
 #include <boost/iostreams/filter/gzip.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/format.hpp>
 #include <boost/regex.hpp>
@@ -57,10 +57,10 @@ MAEReader::MAEReader(const boost::filesystem::path& loc):
   infile_(loc),
   in_()
 {
-  if (boost::iequals(".gz", boost::filesystem::extension(loc))) {
-    in_.push(boost::iostreams::gzip_decompressor());    
+  if (boost::iequals(".gz", boost::filesystem::path(loc).extension().string())) {
+    in_.push(boost::iostreams::gzip_decompressor());
   }
-  in_.push(infile_);  
+  in_.push(infile_);
   if(!infile_) throw IOException("could not open "+loc.string());
 }
 
@@ -89,7 +89,7 @@ void MAEReader::Import(mol::EntityHandle& ent)
   mol::XCSEditor editor=ent.EditXCS(mol::BUFFERED_EDIT);
 
   boost::shared_array<char> xline(new char[512]);
-  
+
   while(std::getline(in_,line)) {
     //line = boost::trim_copy(line);
     if(in_ct_block) {
@@ -111,7 +111,7 @@ void MAEReader::Import(mol::EntityHandle& ent)
             memset(xline.get(),0,512);
             strncpy(xline.get(),line.c_str(),511);
             parse_and_add_atom(ent,editor,xline.get(),line.size(),
-                               i_atom_name, i_atom_xpos, i_atom_ypos, i_atom_zpos, 
+                               i_atom_name, i_atom_xpos, i_atom_ypos, i_atom_zpos,
                                i_res_name, i_res_num, i_chain_name);
           }
         } else { // not parsing atoms
@@ -170,7 +170,7 @@ void MAEReader::Import(mol::EntityHandle& ent)
   }
 
   LOG_INFO("imported " << chain_count_ << " chains, " << residue_count_
-                << " residues, " << atom_count_ << " atoms");  
+                << " residues, " << atom_count_ << " atoms");
 }
 
 
@@ -184,7 +184,7 @@ void MAEReader::parse_and_add_atom(mol::EntityHandle ent,
                                    int i_atom_zpos,
                                    int i_res_name,
                                    int i_res_num,
-                                   int i_chain_name)  
+                                   int i_chain_name)
 {
   std::string aname("X");
   std::string rname("UNK");
@@ -264,9 +264,9 @@ void MAEReader::parse_and_add_atom(mol::EntityHandle ent,
   if(isdigit(ele[0])) ele="H";
 
   mol::ResidueKey rkey(rname);
-  
+
   mol::ResNum rnum(irnum);
-  
+
   // determine chain and residue update
   bool update_chain=false;
   bool update_residue=false;
@@ -284,13 +284,13 @@ void MAEReader::parse_and_add_atom(mol::EntityHandle ent,
     update_residue=true;
   }
 
-  if(update_chain) {  
+  if(update_chain) {
     if (!(curr_chain_=ent.FindChain(cname))) {
       curr_chain_=editor.InsertChain(cname);
-      LOG_TRACE("new chain " << curr_chain_);      
-      ++chain_count_;      
+      LOG_TRACE("new chain " << curr_chain_);
+      ++chain_count_;
     } else {
-      LOG_TRACE("old chain " << curr_chain_);      
+      LOG_TRACE("old chain " << curr_chain_);
     }
   }
 
@@ -326,7 +326,7 @@ void MAEReader::parse_and_add_atom(mol::EntityHandle ent,
   ++atom_count_;
   mol::AtomHandle ah = editor.InsertAtom(curr_residue_, aname, apos, ele);
 }
-  
+
 
 
 
@@ -378,7 +378,7 @@ bool EntityIOMAEHandler::ProvidesExport(const boost::filesystem::path& loc,
   return false;
 }
 
-mol::EntityHandle LoadMAE(const String& file_name) 
+mol::EntityHandle LoadMAE(const String& file_name)
 {
   MAEReader reader(file_name);
   mol::EntityHandle ent=mol::CreateEntity();
@@ -392,14 +392,14 @@ mol::EntityHandle LoadMAE(const String& file_name)
 }
 
 
-void EntityIOMAEHandler::Import(mol::EntityHandle& ent, 
+void EntityIOMAEHandler::Import(mol::EntityHandle& ent,
                                 std::istream& stream)
 {
   throw IOException("MAE format does not support import from stream");
 }
 
 
-void EntityIOMAEHandler::Export(const mol::EntityView& ent, 
+void EntityIOMAEHandler::Export(const mol::EntityView& ent,
                                 std::ostream& stream) const
 {
   throw IOException("MAE format does not support export to stream");
diff --git a/modules/io/src/mol/entity_io_mmcif_handler.cc b/modules/io/src/mol/entity_io_mmcif_handler.cc
index fe5674788..caa68079e 100644
--- a/modules/io/src/mol/entity_io_mmcif_handler.cc
+++ b/modules/io/src/mol/entity_io_mmcif_handler.cc
@@ -24,7 +24,7 @@
 #include <iomanip>
 
 #include <boost/algorithm/string.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/format.hpp>
 #include <boost/lexical_cast.hpp>
 
@@ -45,14 +45,14 @@ bool EntityIOMMCIFHandler::RequiresProcessor() const
 
 
 void EntityIOMMCIFHandler::Export(const mol::EntityView& ent,
-                                const boost::filesystem::path& loc) const 
+                                const boost::filesystem::path& loc) const
 {
 }
 
-void EntityIOMMCIFHandler::Import(mol::EntityHandle& ent, 
+void EntityIOMMCIFHandler::Import(mol::EntityHandle& ent,
                                 std::istream& stream)
 {
-  MMCifReader reader(stream,ent,  
+  MMCifReader reader(stream,ent,
                      IOProfileRegistry::Instance().GetDefault());
   reader.Parse();
   // branch links are already connect in Parse call
@@ -60,7 +60,7 @@ void EntityIOMMCIFHandler::Import(mol::EntityHandle& ent,
 }
 
 void EntityIOMMCIFHandler::Export(const mol::EntityView& ent,
-                                std::ostream& stream) const 
+                                std::ostream& stream) const
 {
 }
 
@@ -68,7 +68,7 @@ void EntityIOMMCIFHandler::Import(mol::EntityHandle& ent,
                                 const boost::filesystem::path& loc)
 {
   std::string filename=loc.string();
-  MMCifReader reader(filename, ent,  
+  MMCifReader reader(filename, ent,
                      IOProfileRegistry::Instance().GetDefault());
   reader.Parse();
   // branch links are already connect in Parse call
diff --git a/modules/io/src/mol/entity_io_pdb_handler.cc b/modules/io/src/mol/entity_io_pdb_handler.cc
index f9f76eca6..99a00578f 100644
--- a/modules/io/src/mol/entity_io_pdb_handler.cc
+++ b/modules/io/src/mol/entity_io_pdb_handler.cc
@@ -24,7 +24,7 @@
 #include <iomanip>
 
 #include <boost/algorithm/string.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/format.hpp>
 #include <boost/lexical_cast.hpp>
 
@@ -46,16 +46,16 @@ bool EntityIOPDBHandler::RequiresProcessor() const
 
 
 void EntityIOPDBHandler::Export(const mol::EntityView& ent,
-                                const boost::filesystem::path& loc) const 
+                                const boost::filesystem::path& loc) const
 {
   PDBWriter writer(loc, IOProfileRegistry::Instance().GetDefault());
-  if (boost::iequals(boost::filesystem::extension(loc), ".pqr")) {
+  if (boost::iequals(boost::filesystem::path(loc).extension().string(), ".pqr")) {
     writer.SetIsPQR(true);
   }
   writer.Write(ent);
 }
 
-void EntityIOPDBHandler::Import(mol::EntityHandle& ent, 
+void EntityIOPDBHandler::Import(mol::EntityHandle& ent,
                                 std::istream& stream)
 {
   PDBReader reader(stream, IOProfileRegistry::Instance().GetDefault());
@@ -65,7 +65,7 @@ void EntityIOPDBHandler::Import(mol::EntityHandle& ent,
 }
 
 void EntityIOPDBHandler::Export(const mol::EntityView& ent,
-                                std::ostream& stream) const 
+                                std::ostream& stream) const
 {
   PDBWriter writer(stream, IOProfileRegistry::Instance().GetDefault());
   writer.Write(ent);
diff --git a/modules/io/src/mol/entity_io_pqr_handler.cc b/modules/io/src/mol/entity_io_pqr_handler.cc
index ada62fb92..26207e59f 100644
--- a/modules/io/src/mol/entity_io_pqr_handler.cc
+++ b/modules/io/src/mol/entity_io_pqr_handler.cc
@@ -25,7 +25,7 @@
 #include <iomanip>
 
 #include <boost/iostreams/filter/gzip.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/lexical_cast.hpp>
 #include <boost/format.hpp>
@@ -58,10 +58,10 @@ PQRReader::PQRReader(const boost::filesystem::path& loc):
   infile_(loc),
   in_()
 {
-  if (boost::iequals(".gz", boost::filesystem::extension(loc))) {
-    in_.push(boost::iostreams::gzip_decompressor());    
+  if (boost::iequals(".gz", boost::filesystem::path(loc).extension().string())) {
+    in_.push(boost::iostreams::gzip_decompressor());
   }
-  in_.push(infile_);  
+  in_.push(infile_);
   if(!infile_) throw IOException("could not open "+loc.string());
 }
 
@@ -84,7 +84,7 @@ void PQRReader::Import(mol::EntityHandle& ent)
   }
 
   LOG_INFO("imported " << chain_count_ << " chains, " << residue_count_
-                << " residues, " << atom_count_ << " atoms");  
+                << " residues, " << atom_count_ << " atoms");
 }
 
 /// \brief Parsing for standard format
@@ -115,13 +115,13 @@ void PQRReader::ParseAndAddAtom(const String& line, mol::EntityHandle& ent)
   } catch (boost::bad_lexical_cast& e) {
     return;
   }
-  
+
   geom::Vec3 apos(ax,ay,az);
 
   mol::ResidueKey rkey(rname);
-  
+
   mol::ResNum rnum(irnum);
-  
+
   // determine chain and residue update
   bool update_chain=false;
   bool update_residue=false;
@@ -146,7 +146,7 @@ void PQRReader::ParseAndAddAtom(const String& line, mol::EntityHandle& ent)
     } else if(curr_chain_.GetName()!=s_chain) {
       update_chain=true;
       update_residue=true;
-    }  
+    }
   }
 
   if(!curr_residue_) {
@@ -155,10 +155,10 @@ void PQRReader::ParseAndAddAtom(const String& line, mol::EntityHandle& ent)
     update_residue=true;
   }
 
-  if(update_chain) {  
-    LOG_DEBUG("new chain " << s_chain);      
+  if(update_chain) {
+    LOG_DEBUG("new chain " << s_chain);
     curr_chain_=editor.InsertChain(s_chain);
-    ++chain_count_;      
+    ++chain_count_;
   }
 
   if(update_residue) {
@@ -237,7 +237,7 @@ bool PQRWriter::VisitAtom(const mol::AtomHandle& atom)
   if (e_name=="") {
     e_name="MOL";
   }
-	
+
   mol::ResidueHandle res=atom.GetResidue();
 /*
   outstream_  << format("%5i") % atom_count_
@@ -252,7 +252,7 @@ bool PQRWriter::VisitAtom(const mol::AtomHandle& atom)
               << format("%8.5f") % atom.GetBFactor()
               << std::endl;
               */
- 
+
   return true;
 }
 
@@ -313,7 +313,7 @@ bool EntityIOPQRHandler::ProvidesExport(const boost::filesystem::path& loc,
   return pqr_handler_is_responsible_for(loc, type);
 }
 
-mol::EntityHandle LoadPQR(const String& file_name) 
+mol::EntityHandle LoadPQR(const String& file_name)
 {
   Profile profile_load("LoadPQR");
   IOProfile default_profile=IOProfileRegistry::Instance().GetDefault();
@@ -321,13 +321,13 @@ mol::EntityHandle LoadPQR(const String& file_name)
   mol::EntityHandle ent=mol::CreateEntity();
   mol::XCSEditor editor=ent.EditXCS(mol::BUFFERED_EDIT);
   reader.Import(ent);
-  if (default_profile.processor) 
+  if (default_profile.processor)
     default_profile.processor->Process(ent);
   return ent;
 }
 
 
-void EntityIOPQRHandler::Import(mol::EntityHandle& ent, 
+void EntityIOPQRHandler::Import(mol::EntityHandle& ent,
                                 std::istream& stream)
 {
   throw IOException("PQR format does not support import from stream");
diff --git a/modules/io/src/mol/pdb_reader.cc b/modules/io/src/mol/pdb_reader.cc
index af1e5f729..408a3a973 100644
--- a/modules/io/src/mol/pdb_reader.cc
+++ b/modules/io/src/mol/pdb_reader.cc
@@ -17,7 +17,7 @@
 // 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 //------------------------------------------------------------------------------
 #include <boost/iostreams/filter/gzip.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/algorithm/string/trim.hpp>
 
@@ -74,7 +74,7 @@ PDBReader::PDBReader(const String& filename, const IOProfile& profile)
   this->Init(boost::filesystem::path(filename));
 }
 
-PDBReader::PDBReader(const boost::filesystem::path& loc, 
+PDBReader::PDBReader(const boost::filesystem::path& loc,
                      const IOProfile& profile):
   infile_(loc), instream_(infile_), compnds_(), profile_(profile)
 {
@@ -88,7 +88,7 @@ void PDBReader::Init(const boost::filesystem::path& loc)
   warned_rule_based_=false;
   charmm_style_=profile_.dialect=="CHARMM";
   num_model_records_=0;
-  if (boost::iequals(".gz", boost::filesystem::extension(loc))) {
+  if (boost::iequals(".gz", boost::filesystem::path(loc).extension().string())) {
     in_.push(boost::iostreams::gzip_decompressor());
   }
   in_.push(instream_);
@@ -96,7 +96,7 @@ void PDBReader::Init(const boost::filesystem::path& loc)
                      std::string(strerror(errno)) +
                      ": '" + loc.string() + "'");
   line_num_=0;
-  if(boost::iequals(boost::filesystem::extension(loc), ".pqr")) {
+  if(boost::iequals(boost::filesystem::path(loc).extension().string(), ".pqr")) {
     is_pqr_=true;
   } else {
     is_pqr_=false;
@@ -106,7 +106,7 @@ void PDBReader::Init(const boost::filesystem::path& loc)
   data_continues_=false;
   old_key_="";
   mol_id_=std::make_pair(false, 0);
-  
+
 }
 
 void PDBReader::ThrowFaultTolerant(const String& msg) {
@@ -121,7 +121,7 @@ void PDBReader::ParseCompndEntry (const StringRef& line, int line_num)
 {
   if (line.size()<12) {
     if (profile_.fault_tolerant) {
-      LOG_WARNING("invalid COMPND record on line " << line_num 
+      LOG_WARNING("invalid COMPND record on line " << line_num
                   << ": record is too short");
       return;
     }
@@ -132,7 +132,7 @@ void PDBReader::ParseCompndEntry (const StringRef& line, int line_num)
   }
   if (line.rtrim().size()>80) {
     if (profile_.fault_tolerant) {
-      LOG_WARNING("invalid COMPND record on line " << line_num 
+      LOG_WARNING("invalid COMPND record on line " << line_num
                   << ": record is too long");
       return;
     }
@@ -187,14 +187,14 @@ void PDBReader::ParseCompndEntry (const StringRef& line, int line_num)
     return;
   } else if (data_continues_){
     data=entry.trim();
-    
+
     if(data.size()<1){
       ThrowFaultTolerant(str(format("invalid COMPND record on line %d, record after\
                                     ':' was empty")%line_num));
     }
     key=StringRef(old_key_.data(), old_key_.size());
 
-  } 
+  }
       //currently only these are parsed
   if (!(key.str()=="MOL_ID")&&!(key.str()=="CHAIN")){
     LOG_INFO("reading COMPND record on line " << line_num<< " is not supported");
@@ -204,7 +204,7 @@ void PDBReader::ParseCompndEntry (const StringRef& line, int line_num)
       return;
     }
   }
-  
+
   std::vector<StringRef> chain_list;
   std::vector<String> chains;
   if ((IEquals(key, StringRef("MOL_ID", 6)))) {
@@ -241,11 +241,11 @@ void PDBReader::ParseSeqRes(const StringRef& line, int line_num)
 {
   conop::CompoundLibPtr comp_lib;
   comp_lib = conop::Conopology::Instance().GetDefaultLib();
-   
+
   if (!comp_lib) {
     if (!warned_rule_based_) {
-      LOG_WARNING("SEQRES import requires a compound library. Ignoring" 
-                  "SEQRES records");      
+      LOG_WARNING("SEQRES import requires a compound library. Ignoring"
+                  "SEQRES records");
     }
     warned_rule_based_=true;
     return;
@@ -255,7 +255,7 @@ void PDBReader::ParseSeqRes(const StringRef& line, int line_num)
   }
   if (line.size()<17) {
     if (profile_.fault_tolerant) {
-      LOG_WARNING("invalid SEQRES record on line " << line_num 
+      LOG_WARNING("invalid SEQRES record on line " << line_num
                   << ": record is too short");
       return;
     }
@@ -266,7 +266,7 @@ void PDBReader::ParseSeqRes(const StringRef& line, int line_num)
   }
   String chain(1, line[11]);
   seq::SequenceHandle curr_seq;
-  if (seqres_.GetCount()==0 || 
+  if (seqres_.GetCount()==0 ||
       seqres_[seqres_.GetCount()-1].GetName()!=chain) {
     curr_seq=seq::CreateSequence(chain, "");
     seqres_.AddSequence(curr_seq);
@@ -284,11 +284,11 @@ void PDBReader::ParseSeqRes(const StringRef& line, int line_num)
     if (trimmed.empty()) {
       return;
     }
-    conop::CompoundPtr compound=comp_lib->FindCompound(trimmed.str(), 
+    conop::CompoundPtr compound=comp_lib->FindCompound(trimmed.str(),
                                                        conop::Compound::PDB);
     if (!compound) {
       if (rname!=StringRef("UNK", 3)) {
-     
+
         LOG_WARNING("unknown residue '" << trimmed << "' in SEQRES record. "
                     "Setting one-letter-code to '?'");
       }
@@ -308,7 +308,7 @@ bool PDBReader::HasNext()
   // a HELIX/SHEET entry implies a next model.
   while (std::getline(in_, curr_line_) && ++line_num_) {
      StringRef curr_line(curr_line_.c_str(), curr_line_.length());
-     if (curr_line.size()>5 && 
+     if (curr_line.size()>5 &&
          (IEquals(curr_line.substr(0, 6), StringRef("ATOM  ", 6)) ||
          (!profile_.no_hetatms &&
           IEquals(curr_line.substr(0, 6),StringRef("HETATM ", 6))) ||
@@ -351,12 +351,12 @@ void PDBReader::Import(mol::EntityHandle& ent,
         }
         if (IEquals(curr_line.substr(0, 6), StringRef("ATOM  ", 6))) {
           LOG_TRACE("processing ATOM entry");
-          this->ParseAndAddAtom(curr_line, line_num_, ent, 
+          this->ParseAndAddAtom(curr_line, line_num_, ent,
                                 StringRef("ATOM", 4));
         } else if (IEquals(curr_line.substr(0, 6), StringRef("ANISOU", 6))) {
           if (!charmm_style_) {
             LOG_TRACE("processing ANISOU entry");
-            this->ParseAnisou(curr_line, line_num_, ent);            
+            this->ParseAnisou(curr_line, line_num_, ent);
           }
         }
         break;
@@ -403,11 +403,11 @@ void PDBReader::Import(mol::EntityHandle& ent,
           if (profile_.no_hetatms)
             continue;
           LOG_TRACE("processing HETATM entry");
-          this->ParseAndAddAtom(curr_line, line_num_, ent, 
+          this->ParseAndAddAtom(curr_line, line_num_, ent,
                                 StringRef("HETATM", 6));
         } else if (IEquals(curr_line.substr(0, 6), StringRef("HELIX ", 6))) {
           if (!charmm_style_) {
-            this->ParseHelixEntry(curr_line);            
+            this->ParseHelixEntry(curr_line);
           }
         } else if (IEquals(curr_line.substr(0, 6), StringRef("HET   ", 6))) {
           // remember het entry to mark the residues as ligand during ATOM import
@@ -432,7 +432,7 @@ void PDBReader::Import(mol::EntityHandle& ent,
           continue;
         }
         if (IEquals(curr_line.substr(0, 6), StringRef("MODEL ", 6))) {
-          ++num_model_records_;          
+          ++num_model_records_;
           if (num_model_records_<2) {
             continue;
           }
@@ -477,7 +477,7 @@ void PDBReader::Import(mol::EntityHandle& ent,
     mol::ResidueHandle res=ent.FindResidue(String(1, i->chain), i->num);
     if (res.IsValid()) {
       res.SetIsLigand(true);
-    }      
+    }
   }
 }
 
@@ -568,15 +568,15 @@ bool PDBReader::EnsureLineLength(const StringRef& line, size_t size)
   if (line.length()<size) {
     if (profile_.fault_tolerant) {
       return false;
-    }    
+    }
     throw IOException(str(format("premature end of line %d") %line_num_));
-  }  
+  }
   return true;
 }
 
-bool PDBReader::ParseAtomIdent(const StringRef& line, int line_num, 
+bool PDBReader::ParseAtomIdent(const StringRef& line, int line_num,
                                String& chain_name,  StringRef& res_name,
-                               mol::ResNum& resnum, StringRef& atom_name, 
+                               mol::ResNum& resnum, StringRef& atom_name,
                                char& alt_loc, const StringRef& record_type,
                                int& serial)
 {
@@ -592,14 +592,14 @@ bool PDBReader::ParseAtomIdent(const StringRef& line, int line_num,
   if (charmm_style_) {
     if (line.size()>73) {
       size_t width=std::min(line.size()-72, size_t(4));
-      chain_name=line.substr(72, width).trim().str();      
+      chain_name=line.substr(72, width).trim().str();
     }
   } else {
-    chain_name=String(1, line[21]);    
+    chain_name=String(1, line[21]);
     if (! restrict_chains_.empty() &&
       restrict_chains_.find(chain_name)==String::npos) {
       return false;
-    }    
+    }
   }
 
   alt_loc=line[16];
@@ -612,7 +612,7 @@ bool PDBReader::ParseAtomIdent(const StringRef& line, int line_num,
     throw IOException(str(format("invalid res number on line %d") % line_num));
   }
 
-  char  ins_c=line[26];  
+  char  ins_c=line[26];
   resnum=to_res_num(res_num.second, ins_c);
 
   std::pair<bool, int> tmp = line.substr(6, 5).trim().to_int();
@@ -624,23 +624,23 @@ bool PDBReader::ParseAtomIdent(const StringRef& line, int line_num,
   return true;
 }
 
-void PDBReader::ParseAnisou(const StringRef& line, int line_num, 
+void PDBReader::ParseAnisou(const StringRef& line, int line_num,
                             mol::EntityHandle& ent)
 {
   if (!this->EnsureLineLength(line, 77)) {
     return;
-  }  
+  }
   String chain_name;
   char alt_loc=0;
   StringRef res_name, atom_name;
   mol::ResNum res_num(0);
   int serial = -1;
-  if (!this->ParseAtomIdent(line, line_num, chain_name, res_name, res_num, 
+  if (!this->ParseAtomIdent(line, line_num, chain_name, res_name, res_num,
                             atom_name, alt_loc, StringRef("ANISOU", 6),
                             serial)) {
-    return;                            
+    return;
   }
-  double anisou[6]={0.0, 0.0, 0.0, 0.0, 0.0, 0.0};  
+  double anisou[6]={0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
   for (int i=0;i<6; ++i) {
     std::pair<bool, int> result=line.substr(29+i*7, 6).ltrim().to_int();
     if (!result.first) {
@@ -653,13 +653,13 @@ void PDBReader::ParseAnisou(const StringRef& line, int line_num,
   }
   String aname(atom_name.str());
   if (!curr_residue_.IsValid()) {
-    if (profile_.fault_tolerant || 
-        profile_.calpha_only || 
+    if (profile_.fault_tolerant ||
+        profile_.calpha_only ||
         profile_.no_hetatms) {
       return;
-    } 
+    }
     const char* fmt_str="invalid ANISOU record for inexistent atom on line %d";
-    throw IOException(str(format(fmt_str) % line_num));      
+    throw IOException(str(format(fmt_str) % line_num));
   }
   mol::AtomHandle atom=curr_residue_.FindAtom(aname);
   if (!atom.IsValid()) {
@@ -670,10 +670,10 @@ void PDBReader::ParseAnisou(const StringRef& line, int line_num,
       return;
     }
     const char* fmt_str="invalid ANISOU record for inexistent atom on line %d";
-    throw IOException(str(format(fmt_str) % line_num));      
+    throw IOException(str(format(fmt_str) % line_num));
   }
   //get properties which are already set and extend them by adding the ANISOU info
-  
+
 
   geom::Mat3 mat(anisou[0], anisou[3], anisou[4],
                  anisou[3], anisou[1], anisou[5],
@@ -683,7 +683,7 @@ void PDBReader::ParseAnisou(const StringRef& line, int line_num,
 }
 
 void PDBReader::ParseAndAddAtom(const StringRef& line, int line_num,
-                                mol::EntityHandle& ent, 
+                                mol::EntityHandle& ent,
                                 const StringRef& record_type)
 {
   if (!this->EnsureLineLength(line, 54)) {
@@ -695,9 +695,9 @@ void PDBReader::ParseAndAddAtom(const StringRef& line, int line_num,
   StringRef res_name, atom_name;
   mol::ResNum res_num(0);
   int serial = -1;
-  if (!this->ParseAtomIdent(line, line_num, chain_name, res_name, res_num, 
+  if (!this->ParseAtomIdent(line, line_num, chain_name, res_name, res_num,
                             atom_name, alt_loc, record_type, serial)) {
-    return;                            
+    return;
   }
 
   std::pair<bool, Real> charge = std::make_pair(false, 0.0);
@@ -728,10 +728,10 @@ void PDBReader::ParseAndAddAtom(const StringRef& line, int line_num,
     }
   } else {
     if (line.length()>=60) {
-      occ=line.substr(54,6).ltrim().to_float();      
+      occ=line.substr(54,6).ltrim().to_float();
     }
     if (line.length()>=66) {
-      temp=line.substr(60, 6).ltrim().to_float();      
+      temp=line.substr(60, 6).ltrim().to_float();
     }
     if (line.length()>=80) {
       // example charge formatting: 1+, 2- etc.
@@ -755,26 +755,26 @@ void PDBReader::ParseAndAddAtom(const StringRef& line, int line_num,
   }
   LOG_TRACE( "line: [" << line << "]" );
   String s_ele;
-  // determine element from element column (77-78, right justified) if 
-  // present otherwise set to empty String. It is up to the builder to 
+  // determine element from element column (77-78, right justified) if
+  // present otherwise set to empty String. It is up to the builder to
   // determine the correct element in that case.
   if (line.length()>=78) {                       // element column present
     if(line[76]==' ' && line[77]==' ') {         // both characters are empty
-      s_ele="";                                  
+      s_ele="";
     } else if(line[76]!=' ' || line[77]!=' ') {  // at least one character not
                                                  // empty
       if(line[76]==' ' && line[77]!=' ') {       // single character element,
                                                  // right justified
-        s_ele=line.substr(77,1).str();           
+        s_ele=line.substr(77,1).str();
       } else if(line[76]!=' ' && line[77]==' ') {// single character element,
                                                  // left justified
-        s_ele=line.substr(76,1).str();           
+        s_ele=line.substr(76,1).str();
       } else {                                   // Real character element
-        s_ele=line.substr(76,2).str();            
+        s_ele=line.substr(76,2).str();
       }
     }
   }
-  String aname(atom_name.str());  
+  String aname(atom_name.str());
   // some postprocessing
   LOG_TRACE( "s_chain: [" << chain_name << "]" );
 
@@ -830,7 +830,7 @@ void PDBReader::ParseAndAddAtom(const StringRef& line, int line_num,
         LOG_DEBUG("appended new residue " << res_name << " " << res_num);
       }
       warned_name_mismatch_=false;
-      ++residue_count_; 
+      ++residue_count_;
     }
     assert(curr_residue_.IsValid());
   }
@@ -847,11 +847,11 @@ void PDBReader::ParseAndAddAtom(const StringRef& line, int line_num,
     if (!warned_name_mismatch_) {
       if (alt_loc==' ') {
         LOG_WARNING("Residue with number " << res_num << " has more than one name. "
-                    "Ignoring atoms for everything but the first");        
+                    "Ignoring atoms for everything but the first");
       } else {
-        LOG_WARNING("Residue with number " << res_num 
+        LOG_WARNING("Residue with number " << res_num
                     << " contains a microheterogeneity. Everything but atoms for "
-                    << "the residue '" << curr_residue_.GetName() 
+                    << "the residue '" << curr_residue_.GetName()
                     << "' will be ignored");
       }
     }
@@ -882,7 +882,7 @@ void PDBReader::ParseAndAddAtom(const StringRef& line, int line_num,
     mol::AtomHandle atom=curr_residue_.FindAtom(aname);
     if (atom.IsValid()) {
       if (profile_.fault_tolerant) {
-        LOG_WARNING("duplicate atom '" << aname << "' in residue " 
+        LOG_WARNING("duplicate atom '" << aname << "' in residue "
                     << curr_residue_ << " only first atom added");
         return;
       }
@@ -918,10 +918,10 @@ void PDBReader::ParseHelixEntry(const StringRef& line)
   if (!start_num.first || !end_num.first) {
     if (profile_.fault_tolerant) {
       return;
-    }    
+    }
     throw IOException(str(format("invalid helix entry on line %d") % line_num_));
   }
-  LOG_DEBUG("making helix entry: " << start_num.second << ", " 
+  LOG_DEBUG("making helix entry: " << start_num.second << ", "
              << line[25] << " " << end_num.second << " " << line[37]);
   HSEntry hse = {to_res_num(start_num.second, line[25]),
                  to_res_num(end_num.second, line[37]),
@@ -937,7 +937,7 @@ void PDBReader::ParseStrandEntry(const StringRef& line)
 {
   if (!this->EnsureLineLength(line, 38)) {
     return;
-  }  
+  }
   std::pair<bool, int>  start_num=line.substr(22, 4).ltrim().to_int();
   std::pair<bool, int>  end_num=line.substr(33, 4).ltrim().to_int();
   if (!start_num.first || !end_num.first) {
@@ -946,7 +946,7 @@ void PDBReader::ParseStrandEntry(const StringRef& line)
     }
     throw IOException(str(format("invalid strand entry on line %d")%line_num_));
   }
-  LOG_DEBUG("making strand entry: " << start_num.second << ", " << line[26] 
+  LOG_DEBUG("making strand entry: " << start_num.second << ", " << line[26]
             << " " << end_num.second << " " << line[37] << " chain=" << line[21]);
   HSEntry hse = {to_res_num(start_num.second, line[26]),
                  to_res_num(end_num.second, line[37]),
@@ -961,7 +961,7 @@ void PDBReader::ParseConectEntry (const StringRef& line, int line_num, mol::Enti
 {
   if (line.size()<16) {
     if (profile_.fault_tolerant) {
-      LOG_WARNING("invalid CONECT record on line " << line_num 
+      LOG_WARNING("invalid CONECT record on line " << line_num
                   << ": record is too short");
       return;
     }
@@ -972,7 +972,7 @@ void PDBReader::ParseConectEntry (const StringRef& line, int line_num, mol::Enti
   }
   if (line.rtrim().size()>80) {
     if (profile_.fault_tolerant) {
-      LOG_WARNING("invalid CONECT record on line " << line_num 
+      LOG_WARNING("invalid CONECT record on line " << line_num
                   << ": record is too long");
       return;
     }
diff --git a/modules/io/src/mol/pdb_writer.cc b/modules/io/src/mol/pdb_writer.cc
index 265a8a024..d888815c9 100644
--- a/modules/io/src/mol/pdb_writer.cc
+++ b/modules/io/src/mol/pdb_writer.cc
@@ -25,7 +25,7 @@
 
 #include <boost/format.hpp>
 #include <boost/iostreams/filter/gzip.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 
 #include <ost/base.hh>
@@ -47,8 +47,8 @@ namespace {
 
 // determine whether the element name has to be shifted to to the left by one
 // column.
-bool shift_left(const String& atom_name, bool is_hetatm, 
-                const String& element, float mass) 
+bool shift_left(const String& atom_name, bool is_hetatm,
+                const String& element, float mass)
 {
   if (atom_name.length()==4) {
     return true;
@@ -63,10 +63,10 @@ bool shift_left(const String& atom_name, bool is_hetatm,
   if (mass>34) {
     if (element=="W" || element=="V") {
       return false;
-    }    
+    }
     return true;
   }
-  return (element=="K" || element=="CA" || element=="NA" || 
+  return (element=="K" || element=="CA" || element=="NA" ||
           element=="MG" || element=="LI");
 }
 
@@ -80,7 +80,7 @@ bool atom_pos_ok(geom::Vec3 p) {
   return true;
 }
 
-// write the serial field for ATOM and TER records, use '*****' for 
+// write the serial field for ATOM and TER records, use '*****' for
 // indexes > 99999 (borrowed from charmm)
 void write_serial(int serial, FormattedLine& line) {
   // Avoid writing out atomnumbers larger than 5 digits
@@ -91,15 +91,15 @@ void write_serial(int serial, FormattedLine& line) {
   }
 }
 
-void write_atom(std::ostream& ostr, FormattedLine& line, 
-                const mol::AtomHandle& atom, int atomnum, 
+void write_atom(std::ostream& ostr, FormattedLine& line,
+                const mol::AtomHandle& atom, int atomnum,
                 bool is_pqr, bool charmm_style)
 {
   mol::ResidueHandle res=atom.GetResidue();
   char ins_code=res.GetNumber().GetInsCode();
   StringRef record_name(atom.IsHetAtom() ? "HETATM" : "ATOM  ", 6);
   std::vector<String> names=atom.GetAltGroupNames();
-  
+
   geom::Vec3 p=atom.GetPos();
   line( 0, 6)=record_name;
   write_serial(atomnum, line);
@@ -109,7 +109,7 @@ void write_atom(std::ostream& ostr, FormattedLine& line,
                       "' is too long for PDB output. At most 4 character "
                       "are allowed");
   }
-  if (shift_left(atom_name, atom.IsHetAtom(), atom.GetElement(), 
+  if (shift_left(atom_name, atom.IsHetAtom(), atom.GetElement(),
                  atom.GetMass())) {
     line(12, 4)=fmt::RPadded(atom_name);
   } else {
@@ -128,10 +128,10 @@ void write_atom(std::ostream& ostr, FormattedLine& line,
                         "' is too long for PDB output. At most 3 characters "
                         "are allowed");
     }
-    line(17, 3)=fmt::LPadded(res.GetKey());    
+    line(17, 3)=fmt::LPadded(res.GetKey());
   }
 
-  
+
   String chain_name=res.GetChain().GetName();
   if (!charmm_style) {
       if (! chain_name.empty()) {
@@ -140,20 +140,20 @@ void write_atom(std::ostream& ostr, FormattedLine& line,
       } else {
         throw IOException("PDB format only support single-letter chain names");
       }
-    }    
+    }
   }
 
   int num = res.GetNumber().GetNum();
   if(num < -999 || num > 9999) {
     throw IOException("Residue number from " + res.GetQualifiedName() +
-                      " is out of range supported by the PDB format " 
+                      " is out of range supported by the PDB format "
                       "(-999 to 9999)");
   }
   line(22, 4)=fmt::LPaddedInt(num);
   if (ins_code!=0) {
     line[26]=ins_code;
   }
-  
+
   // deal with alternative atom locations
   if (names.empty()) {
     if (!atom_pos_ok(p)) {
@@ -162,7 +162,7 @@ void write_atom(std::ostream& ostr, FormattedLine& line,
     line(30, 8)=fmt::LPaddedFloat(p[0],  3);
     line(38, 8)=fmt::LPaddedFloat(p[1],  3);
     line(46, 8)=fmt::LPaddedFloat(p[2],  3);
-    
+
     if (is_pqr) {
       line(55, 7)=fmt::LPaddedFloat(atom.GetCharge(), 4);
       line(63, 6)=fmt::LPaddedFloat(atom.GetRadius(), 4);
@@ -244,7 +244,7 @@ void write_conect(std::ostream& ostr, int atom_index,
 
 class PDBWriterImpl : public mol::EntityVisitor {
 public:
-  PDBWriterImpl(std::ostream& ostream, FormattedLine& line, 
+  PDBWriterImpl(std::ostream& ostream, FormattedLine& line,
                 std::map<long,int>& atom_indices, bool charmm_style)
     : ostr_(ostream), counter_(0), is_pqr_(false),
       atom_indices_(atom_indices), line_(line), peptide_(false),
@@ -260,7 +260,7 @@ public:
     }
     return true;
   }
-  
+
   virtual bool VisitResidue(const mol::ResidueHandle& res)
   {
     if (res.IsPeptideLinking()) {
@@ -274,7 +274,7 @@ public:
     prev_=res;
     return true;
   }
-  
+
   virtual bool VisitChain(const mol::ChainHandle& chain)
   {
     if (chain.GetResidueCount()!=0) {
@@ -302,7 +302,7 @@ public:
       line_(17, 4)=fmt::RPadded(res.GetKey());
     }
     else{
-      line_(17, 3)=fmt::LPadded(res.GetKey()); 
+      line_(17, 3)=fmt::LPadded(res.GetKey());
     }
     if (!res.GetChain().GetName().empty() && !charmm_style_) {
       line_[21]=res.GetChain().GetName()[0];
@@ -312,11 +312,11 @@ public:
     char ins_code=res.GetNumber().GetInsCode();
     if (ins_code!=0) {
       line_[26]=ins_code;
-    }    
+    }
     ostr_ << line_;
     line_.Clear();
   }
-  
+
   void SetIsPQR(bool t) {
     is_pqr_=t;
   }
@@ -347,7 +347,7 @@ virtual bool VisitAtom(const mol::AtomHandle& atom) {
         for (auto partner : partners){
           mol::BondHandle bond = atom.FindBondToAtom(partner);
           int pind=atom_indices_[partner.GetHashCode()];
-          if (pind!=0) {   
+          if (pind!=0) {
             for (int i=0; i < int(bond.GetBondOrder()); i++)
               {partner_indices.push_back(pind);}
             has_partner=true;
@@ -385,25 +385,25 @@ PDBWriter::PDBWriter(std::ostream& stream, const IOProfile& profile):
   out_.push(outstream_);
 }
 
-PDBWriter::PDBWriter(const boost::filesystem::path& filename, 
+PDBWriter::PDBWriter(const boost::filesystem::path& filename,
                      const IOProfile& profile):
   outfile_(BFPathToString(filename).c_str()), outstream_(outfile_),
-  mol_count_(0), line_(80), multi_model_(false), 
+  mol_count_(0), line_(80), multi_model_(false),
   charmm_style_(profile.dialect=="CHARMM"), is_pqr_(false),
   profile_(profile), filename_("")
 {
-  if (boost::iequals(".pqr", boost::filesystem::extension(filename))) {
+  if (boost::iequals(".pqr", boost::filesystem::path(filename).extension().string())) {
     is_pqr_=true;
   }
-  if (boost::iequals(".gz", boost::filesystem::extension(filename))) {
+  if (boost::iequals(".gz", boost::filesystem::path(filename).extension().string())) {
     out_.push(boost::iostreams::gzip_compressor());
   }
   out_.push(outstream_);
 }
 
 PDBWriter::PDBWriter(const String& filename, const IOProfile& profile):
-  outfile_(filename.c_str()), outstream_(outfile_), mol_count_(0), line_(80), 
-  multi_model_(false), charmm_style_(profile.dialect=="CHARMM"), 
+  outfile_(filename.c_str()), outstream_(outfile_), mol_count_(0), line_(80),
+  multi_model_(false), charmm_style_(profile.dialect=="CHARMM"),
   is_pqr_(false), profile_(profile), filename_(filename)
 {
   if (!outfile_.is_open()) {
@@ -411,10 +411,10 @@ PDBWriter::PDBWriter(const String& filename, const IOProfile& profile):
                       std::string(strerror(errno)) +
                       ": '" + filename + "'");
   }
-  if (boost::iequals(".pqr", boost::filesystem::extension(filename))) {
+  if (boost::iequals(".pqr", boost::filesystem::path(filename).extension().string())) {
     is_pqr_=true;
   }
-  if (boost::iequals(".gz", boost::filesystem::extension(filename))) {
+  if (boost::iequals(".gz", boost::filesystem::path(filename).extension().string())) {
     out_.push(boost::iostreams::gzip_compressor());
   }
   out_.push(outstream_);
@@ -482,7 +482,7 @@ void PDBWriter::Write(const mol::AtomHandleList& atoms)
   this->WriteModelTrailer();
 }
 
-  
+
 PDBWriter::~PDBWriter()
 {
   out_ << "END   " << std::endl;
diff --git a/modules/io/src/mol/sdf_reader.cc b/modules/io/src/mol/sdf_reader.cc
index edafc0ff1..4f87451a4 100644
--- a/modules/io/src/mol/sdf_reader.cc
+++ b/modules/io/src/mol/sdf_reader.cc
@@ -21,7 +21,7 @@
  */
 
 #include <boost/algorithm/string.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/format.hpp>
 #include <boost/iostreams/filter/gzip.hpp>
 #include <boost/lexical_cast.hpp>
@@ -122,7 +122,7 @@ void SDFReader::Import(mol::EntityHandle& ent)
 
 void SDFReader::ClearState(const boost::filesystem::path& loc)
 {
-  if (boost::iequals(".gz", boost::filesystem::extension(loc))) {
+  if (boost::iequals(".gz", boost::filesystem::path(loc).extension().string())) {
     in_.push(boost::iostreams::gzip_decompressor());
   }
   in_.push(instream_);
@@ -284,8 +284,8 @@ void SDFReader::AddAtom(const atom_data& atom_tuple, int line_num, mol::EntityHa
   String upper_ele=ele;
   std::transform(upper_ele.begin(),upper_ele.end(),upper_ele.begin(),toupper);
   String aname=boost::lexical_cast<String>(anum);
-  
-  Real charge=0.0;  
+
+  Real charge=0.0;
   try {
     charge=boost::lexical_cast<Real>(boost::trim_copy(s_charge));
     if (charge!=0) {
@@ -393,9 +393,9 @@ void SDFReader::AddBond(const bond_data& bond_tuple, int line_num, mol::EntityHa
 
   mol::AtomHandle first,second;
 
-  first = ent.FindAtom(curr_chain_.GetName(), mol::ResNum(residue_count_), 
+  first = ent.FindAtom(curr_chain_.GetName(), mol::ResNum(residue_count_),
                        first_name);
-  second = ent.FindAtom(curr_chain_.GetName(), mol::ResNum(residue_count_), 
+  second = ent.FindAtom(curr_chain_.GetName(), mol::ResNum(residue_count_),
                         second_name);
 
   if (first.IsValid() && second.IsValid()) {
@@ -407,7 +407,7 @@ void SDFReader::AddBond(const bond_data& bond_tuple, int line_num, mol::EntityHa
     throw IOException(str(format(msg) % line_num % first % second));
   }
 
-  LOG_DEBUG("adding bond " << s_first_name << " " << s_second_name << " (" 
+  LOG_DEBUG("adding bond " << s_first_name << " " << s_second_name << " ("
             << s_type << ") ");
 }
 
diff --git a/modules/io/src/mol/sdf_writer.hh b/modules/io/src/mol/sdf_writer.hh
index 929be1d35..36cc8bd29 100644
--- a/modules/io/src/mol/sdf_writer.hh
+++ b/modules/io/src/mol/sdf_writer.hh
@@ -27,7 +27,7 @@
 #include <iomanip>
 
 #include <boost/filesystem/fstream.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/lexical_cast.hpp>
 #include <boost/format.hpp>
diff --git a/modules/io/src/mol/star_writer.cc b/modules/io/src/mol/star_writer.cc
index 73ff08f94..f426848f3 100644
--- a/modules/io/src/mol/star_writer.cc
+++ b/modules/io/src/mol/star_writer.cc
@@ -49,7 +49,7 @@ void StarWriter::Write(const String& data_name, const String& filename) {
                         ": '" + filename + "'");
   }
   boost::iostreams::filtering_stream<boost::iostreams::output> stream;
-  if (boost::iequals(".gz", boost::filesystem::extension(filename))) {
+  if (boost::iequals(".gz", boost::filesystem::path(filename).extension().string())) {
     stream.push(boost::iostreams::gzip_compressor());
   }
   stream.push(fstream);
diff --git a/modules/io/src/mol/surface_io_msms_handler.cc b/modules/io/src/mol/surface_io_msms_handler.cc
index 25c45b925..47122b7b3 100644
--- a/modules/io/src/mol/surface_io_msms_handler.cc
+++ b/modules/io/src/mol/surface_io_msms_handler.cc
@@ -22,7 +22,7 @@
 #include <sstream>
 
 #include <ost/log.hh>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include "surface_io_msms_handler.hh"
 
 namespace bf = boost::filesystem;
@@ -31,10 +31,13 @@ namespace ost { namespace io {
 
 namespace {
 
-std::pair<bf::path,bf::path> detect_files(const bf::path& loc)
+std::pair<bf::path, bf::path> detect_files(const bf::path& loc)
 {
-  return std::make_pair(bf::change_extension(loc, ".vert"),
-                        bf::change_extension(loc, ".face"));
+  bf::path v = loc;
+  v.replace_extension(".vert");
+  bf::path f = loc;
+  f.replace_extension(".face");
+  return std::make_pair(v, f);
 }
 
 }
@@ -109,7 +112,7 @@ void SurfaceIOMSMSHandler::Export(const mol::SurfaceHandle& sh,
   // empty
 }
 
-bool SurfaceIOMSMSHandler::ProvidesImport(const bf::path& loc, 
+bool SurfaceIOMSMSHandler::ProvidesImport(const bf::path& loc,
                                           const String& format)
 {
   if(format=="auto") {
@@ -121,7 +124,7 @@ bool SurfaceIOMSMSHandler::ProvidesImport(const bf::path& loc,
   return false;
 }
 
-bool SurfaceIOMSMSHandler::ProvidesExport(const bf::path& loc, 
+bool SurfaceIOMSMSHandler::ProvidesExport(const bf::path& loc,
                                           const String& format)
 {
   return false;
diff --git a/modules/io/src/seq/clustal_io_handler.cc b/modules/io/src/seq/clustal_io_handler.cc
index 8eb8eb650..699fe95ff 100644
--- a/modules/io/src/seq/clustal_io_handler.cc
+++ b/modules/io/src/seq/clustal_io_handler.cc
@@ -20,7 +20,7 @@
 #include <map>
 #include <ost/message.hh>
 #include <boost/filesystem/fstream.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/format.hpp>
 
@@ -38,8 +38,8 @@ using boost::format;
 namespace ost { namespace io {
 
 void ClustalIOHandler::Import(seq::SequenceList& aln,
-                              const boost::filesystem::path& loc) {                        
-    boost::filesystem::ifstream infile(loc);    
+                              const boost::filesystem::path& loc) {
+    boost::filesystem::ifstream infile(loc);
     this->Import(aln, infile);
 }
 
@@ -48,7 +48,7 @@ void ClustalIOHandler::Export(const seq::ConstSequenceList& msa,
 }
 
 
-bool ClustalIOHandler::ProvidesImport(const boost::filesystem::path& loc, 
+bool ClustalIOHandler::ProvidesImport(const boost::filesystem::path& loc,
                                     const String& format) {
   if (format=="auto") {
    String match_suf_string=loc.string();
@@ -59,10 +59,10 @@ bool ClustalIOHandler::ProvidesImport(const boost::filesystem::path& loc,
   } else if(format=="clustal") {
     return true;
   }
-  return false;                
+  return false;
 }
 
-bool ClustalIOHandler::ProvidesExport(const boost::filesystem::path& loc, 
+bool ClustalIOHandler::ProvidesExport(const boost::filesystem::path& loc,
                                       const String& format) {
   return false;
 }
@@ -70,7 +70,7 @@ bool ClustalIOHandler::ProvidesExport(const boost::filesystem::path& loc,
 void ClustalIOHandler::Import(seq::SequenceList& aln,
                               std::istream& instream)
 {
-  static const char* whitespace="\t\r\n ";  
+  static const char* whitespace="\t\r\n ";
   int line_num=0;
   String line;
   typedef std::map<String, seq::SequenceHandle> SeqMap;
@@ -80,14 +80,14 @@ void ClustalIOHandler::Import(seq::SequenceList& aln,
     throw IOException("Can't import CLUSTAL alignment. Inexisting file "
                       "or invalid stream.");
   }
-  
+
   // skip empty lines
   while (std::getline(instream, line)) {
     line_num+=1;
     size_t pos=line.find_first_not_of(whitespace);
     if (pos!=String::npos) {
       break;
-    }    
+    }
   }
   if (line.find("CLUSTAL")!=0) {
     throw IOException("bad CLUSTAL file. First line must contain CLUSTAL");
@@ -105,7 +105,7 @@ void ClustalIOHandler::Import(seq::SequenceList& aln,
     size_t seq_id_end=line.find_first_of(whitespace);
     if (seq_id_end==String::npos) {
       std::stringstream ss;
-      ss << "Bad CLUSTAL file on line " << line_num 
+      ss << "Bad CLUSTAL file on line " << line_num
          << ": Whitespace expected after sequence name";
       throw IOException(ss.str());
     }
@@ -114,7 +114,7 @@ void ClustalIOHandler::Import(seq::SequenceList& aln,
     size_t start=line.find_first_not_of(whitespace, seq_id_end);
     size_t end=line.find_first_of(whitespace, start);
     end=end==String::npos ? line.length() : end;
-    String seq_string=line.substr(start, end-start);      
+    String seq_string=line.substr(start, end-start);
     SeqMap::iterator entry=seq_map.find(seq_id);
     if (entry!=seq_map.end()) {
       entry->second.SetString(entry->second.GetString()+seq_string);
@@ -123,8 +123,8 @@ void ClustalIOHandler::Import(seq::SequenceList& aln,
       seq_map.insert(std::make_pair(seq_id, sequence));
       order.push_back(sequence);
     }
-  }    
-  for (std::vector<seq::SequenceHandle>::iterator i=order.begin(), 
+  }
+  for (std::vector<seq::SequenceHandle>::iterator i=order.begin(),
        e=order.end(); i!=e; ++i) {
     aln.AddSequence(*i);
   }
diff --git a/modules/io/src/seq/fasta_io_handler.cc b/modules/io/src/seq/fasta_io_handler.cc
index 61bb43ba0..038d4ef2a 100644
--- a/modules/io/src/seq/fasta_io_handler.cc
+++ b/modules/io/src/seq/fasta_io_handler.cc
@@ -19,7 +19,7 @@
 #include "fasta_io_handler.hh"
 #include <ost/message.hh>
 #include <boost/filesystem/fstream.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/format.hpp>
 
@@ -34,12 +34,12 @@ using boost::format;
 namespace ost { namespace io {
 
 void FastaIOHandler::Import(seq::SequenceList& aln,
-                            const boost::filesystem::path& loc) 
+                            const boost::filesystem::path& loc)
 {
     if (!boost::filesystem::exists(loc)) {
       throw IOException("File does not exist");
     }
-    
+
     boost::filesystem::ifstream infile(loc);
     this->Import(aln, infile);
 }
@@ -59,7 +59,7 @@ void FastaIOHandler::Export(const seq::ConstSequenceList& msa,
 
 
 
-bool FastaIOHandler::ProvidesImport(const boost::filesystem::path& loc, 
+bool FastaIOHandler::ProvidesImport(const boost::filesystem::path& loc,
                                     const String& format) {
   if (format=="auto") {
    String match_suf_string=loc.string();
@@ -72,10 +72,10 @@ bool FastaIOHandler::ProvidesImport(const boost::filesystem::path& loc,
   } else if(format=="fasta") {
     return true;
   }
-  return false;                
+  return false;
 }
 
-bool FastaIOHandler::ProvidesExport(const boost::filesystem::path& loc, 
+bool FastaIOHandler::ProvidesExport(const boost::filesystem::path& loc,
                            const String& format) {
   return FastaIOHandler::ProvidesImport(loc, format);
 }
@@ -83,10 +83,10 @@ bool FastaIOHandler::ProvidesExport(const boost::filesystem::path& loc,
 void FastaIOHandler::Import(seq::SequenceList& aln,
                             std::istream& instream)
 {
-  const char* error_msg="Bad FASTA file: Expected '>', but '%1%' found.";  
-  
+  const char* error_msg="Bad FASTA file: Expected '>', but '%1%' found.";
+
   String line;
-  std::getline(instream, line);    
+  std::getline(instream, line);
   int seq_count=0;
   while (!instream.eof()) {
     // parse header information. cut after first "|"
@@ -110,11 +110,11 @@ void FastaIOHandler::Import(seq::SequenceList& aln,
         }
         seq_string << *i;
       }
-    }    
+    }
     if (!seq_string.str().empty()) {
       try {
         seq::SequenceHandle seq=seq::CreateSequence(name, seq_string.str());
-        aln.AddSequence(seq);          
+        aln.AddSequence(seq);
         seq_count+=1;
       } catch (seq::InvalidSequence& e) {
         throw seq::InvalidSequence("Failed for sequence \"" + name + "\" (" +
@@ -123,10 +123,10 @@ void FastaIOHandler::Import(seq::SequenceList& aln,
     } else {
       throw IOException("Bad FASTA file: Sequence is empty.");
     }
-  }    
+  }
   if (seq_count==0) {
     throw IOException("Bad FASTA file: File is empty");
-  }                        
+  }
 
 }
 
diff --git a/modules/io/src/seq/hhm_io_handler.cc b/modules/io/src/seq/hhm_io_handler.cc
index 3d976a571..97cdd7876 100644
--- a/modules/io/src/seq/hhm_io_handler.cc
+++ b/modules/io/src/seq/hhm_io_handler.cc
@@ -20,11 +20,11 @@
 /*
   Author: Gerardo Tauriello, Gabriel Studer
  */
-  
+
 #include "hhm_io_handler.hh"
 
 #include <boost/algorithm/string/predicate.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/filesystem/fstream.hpp>
 #include <boost/iostreams/filter/gzip.hpp>
 #include <boost/iostreams/filtering_stream.hpp>
@@ -59,12 +59,12 @@ seq::ProfileColumn GetColumn(const std::vector<ost::StringRef>& chunks,
   return pc;
 }
 
-seq::HMMDataPtr GetHMMData(const std::vector<ost::StringRef>& chunks, 
-                           const std::vector<uint>& idx, 
+seq::HMMDataPtr GetHMMData(const std::vector<ost::StringRef>& chunks,
+                           const std::vector<uint>& idx,
                            const std::vector<seq::HMMTransition>& transitions,
                            int neff_idx,
                            int neff_i_idx,
-                           int neff_d_idx, 
+                           int neff_d_idx,
                            const String& exception) {
 
   // check chunks size
@@ -130,7 +130,7 @@ void HhmIOHandler::Import(seq::ProfileHandle& prof,
     throw IOException("Could not open " + loc.string());
   }
   // add unzip if necessary
-  if (boost::iequals(".gz", boost::filesystem::extension(loc))) {
+  if (boost::iequals(".gz", boost::filesystem::path(loc).extension().string())) {
     in.push(boost::iostreams::gzip_decompressor());
   }
   in.push(stream);
@@ -138,7 +138,7 @@ void HhmIOHandler::Import(seq::ProfileHandle& prof,
   this->Import(prof, in);
 }
 
-void HhmIOHandler::ImportFromString(seq::ProfileHandle& prof, 
+void HhmIOHandler::ImportFromString(seq::ProfileHandle& prof,
                                     const String& data) {
   std::stringstream ss(data);
   this->Import(prof, ss);
@@ -149,7 +149,7 @@ void HhmIOHandler::Export(const seq::ProfileHandle& prof,
   throw IOException("Cannot write hhm files.");
 }
 
-bool HhmIOHandler::ProvidesImport(const boost::filesystem::path& loc, 
+bool HhmIOHandler::ProvidesImport(const boost::filesystem::path& loc,
                                   const String& format) {
   if (format=="auto") {
     String match_suf_string = loc.string();
@@ -165,7 +165,7 @@ bool HhmIOHandler::ProvidesImport(const boost::filesystem::path& loc,
   return false;
 }
 
-bool HhmIOHandler::ProvidesExport(const boost::filesystem::path& loc, 
+bool HhmIOHandler::ProvidesExport(const boost::filesystem::path& loc,
                                   const String& format) {
   // no writers here
   return false;
@@ -174,7 +174,7 @@ bool HhmIOHandler::ProvidesExport(const boost::filesystem::path& loc,
 void HhmIOHandler::Import(seq::ProfileHandle& prof, std::istream& in) {
   // reset profile
   prof.clear();
-  
+
   // tmp. storage
   std::string line;
   ost::StringRef sline;
@@ -182,7 +182,7 @@ void HhmIOHandler::Import(seq::ProfileHandle& prof, std::istream& in) {
   std::string neff_line;
   char olcs[20];
   std::vector<ost::seq::HMMTransition> transitions;
-  std::vector<uint> transition_idx; 
+  std::vector<uint> transition_idx;
   int neff_idx = -1;
   int neff_i_idx = -1;
   int neff_d_idx = -1;
@@ -193,13 +193,13 @@ void HhmIOHandler::Import(seq::ProfileHandle& prof, std::istream& in) {
   bool neff_found = false;
   while (std::getline(in, line)) {
     sline = ost::StringRef(line.c_str(), line.length());
-    if (sline.length()>4 && 
+    if (sline.length()>4 &&
         sline.substr(0, 5) == ost::StringRef("NULL ", 5)) {
       null_line = line;
       null_found = true;
       break;
     }
-    if (sline.length()>4 && 
+    if (sline.length()>4 &&
         sline.substr(0, 5) == ost::StringRef("NEFF ", 5)) {
       neff_line = line;
       neff_found = true;
@@ -236,25 +236,25 @@ void HhmIOHandler::Import(seq::ProfileHandle& prof, std::istream& in) {
       for (uint i = 0; i < 10; ++i) {
         if(chunks[i] == ost::StringRef("M->M", 4)) {
           transition_idx.push_back(i);
-          transitions.push_back(ost::seq::HMM_M2M);  
+          transitions.push_back(ost::seq::HMM_M2M);
         } else if(chunks[i] == ost::StringRef("M->I", 4)) {
           transition_idx.push_back(i);
-          transitions.push_back(ost::seq::HMM_M2I); 
+          transitions.push_back(ost::seq::HMM_M2I);
         } else if(chunks[i] == ost::StringRef("M->D", 4)) {
           transition_idx.push_back(i);
-          transitions.push_back(ost::seq::HMM_M2D); 
+          transitions.push_back(ost::seq::HMM_M2D);
         } else if(chunks[i] == ost::StringRef("I->M", 4)) {
           transition_idx.push_back(i);
-          transitions.push_back(ost::seq::HMM_I2M); 
+          transitions.push_back(ost::seq::HMM_I2M);
         } else if(chunks[i] == ost::StringRef("I->I", 4)) {
           transition_idx.push_back(i);
-          transitions.push_back(ost::seq::HMM_I2I); 
+          transitions.push_back(ost::seq::HMM_I2I);
         } else if(chunks[i] == ost::StringRef("D->M", 4)) {
           transition_idx.push_back(i);
-          transitions.push_back(ost::seq::HMM_D2M); 
+          transitions.push_back(ost::seq::HMM_D2M);
         } else if(chunks[i] == ost::StringRef("D->D", 4)) {
           transition_idx.push_back(i);
-          transitions.push_back(ost::seq::HMM_D2D); 
+          transitions.push_back(ost::seq::HMM_D2D);
         } else if(chunks[i] == ost::StringRef("Neff", 4)) {
           neff_idx = i;
         } else if(chunks[i] == ost::StringRef("Neff_I", 6)) {
@@ -262,7 +262,7 @@ void HhmIOHandler::Import(seq::ProfileHandle& prof, std::istream& in) {
         } else if(chunks[i] == ost::StringRef("Neff_D", 6)) {
           neff_d_idx = i;
         } else {
-          throw IOException("Badly formatted HMM line: " + line); 
+          throw IOException("Badly formatted HMM line: " + line);
         }
       }
 
@@ -272,10 +272,10 @@ void HhmIOHandler::Import(seq::ProfileHandle& prof, std::istream& in) {
       }
 
       if(transition_idx.size() != 7) {
-        throw IOException("Badly formatted HMM line: " + line);      
+        throw IOException("Badly formatted HMM line: " + line);
       }
 
-      // skip one line 
+      // skip one line
       std::getline(in, line);
       hmm_found = true;
       break;
@@ -307,7 +307,7 @@ void HhmIOHandler::Import(seq::ProfileHandle& prof, std::istream& in) {
     if (sline.trim().empty()) continue;
     if (sline.trim() == ost::StringRef("//", 2)) break;
     chunks = sline.split();
-    prof.back().SetHMMData(GetHMMData(chunks, transition_idx, 
+    prof.back().SetHMMData(GetHMMData(chunks, transition_idx,
                            transitions, neff_idx, neff_i_idx, neff_d_idx,
                            "Badly formatted line\n" + line));
   }
diff --git a/modules/io/src/seq/pir_io_handler.cc b/modules/io/src/seq/pir_io_handler.cc
index a84710b7c..31eca300d 100644
--- a/modules/io/src/seq/pir_io_handler.cc
+++ b/modules/io/src/seq/pir_io_handler.cc
@@ -19,7 +19,7 @@
 #include "pir_io_handler.hh"
 #include <ost/message.hh>
 #include <boost/filesystem/fstream.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/format.hpp>
 
@@ -34,12 +34,12 @@ using boost::format;
 namespace ost { namespace io {
 
 void PirIOHandler::Import(seq::SequenceList& aln,
-                            const boost::filesystem::path& loc) 
+                            const boost::filesystem::path& loc)
 {
     if (!boost::filesystem::exists(loc)) {
       throw IOException("File does not exist");
     }
-    
+
     boost::filesystem::ifstream infile(loc);
     this->Import(aln, infile);
 }
@@ -53,7 +53,7 @@ void PirIOHandler::Export(const seq::ConstSequenceList& msa,
 
 
 
-bool PirIOHandler::ProvidesImport(const boost::filesystem::path& loc, 
+bool PirIOHandler::ProvidesImport(const boost::filesystem::path& loc,
                                     const String& format) {
   if (format=="auto") {
    String match_suf_string=loc.string();
@@ -67,21 +67,21 @@ bool PirIOHandler::ProvidesImport(const boost::filesystem::path& loc,
   return false;
 }
 
-bool PirIOHandler::ProvidesExport(const boost::filesystem::path& loc, 
+bool PirIOHandler::ProvidesExport(const boost::filesystem::path& loc,
                            const String& format) {
   return PirIOHandler::ProvidesImport(loc, format);
 }
 
 void PirIOHandler::Import(seq::SequenceList& aln, std::istream& instream)
 {
-  const char* error_msg="Expected %1%, but '%2%' found.";  
+  const char* error_msg="Expected %1%, but '%2%' found.";
   const char* premature_end="Premature end in PIR file on line %1%";
   const char* empty_seq="PIR file contains empty sequence on line %1%";
   String line;
   int line_num=1, seq_count=0;
-  // we can't use a normal while(std::getline(...)) here, because the PIR format 
-  // requires us to perform a one-line look-ahead. 
-  std::getline(instream, line);  
+  // we can't use a normal while(std::getline(...)) here, because the PIR format
+  // requires us to perform a one-line look-ahead.
+  std::getline(instream, line);
   while (!instream.eof()) {
     // skip empty lines
     if (line.find_first_not_of("\n\t ")==String::npos) {
@@ -96,8 +96,8 @@ void PirIOHandler::Import(seq::SequenceList& aln, std::istream& instream)
       throw IOException(error);
     }
     String seq_type=line.substr(1, 2);
-    if (!(seq_type=="P1" || seq_type=="F1" || seq_type=="DL" || 
-          seq_type=="DC" || seq_type=="RL" || seq_type=="RC" || 
+    if (!(seq_type=="P1" || seq_type=="F1" || seq_type=="DL" ||
+          seq_type=="DC" || seq_type=="RL" || seq_type=="RC" ||
           seq_type=="XX")) {
       throw IOException("Bad PIR file: Unknown sequence type"/*" '%1%' on line %2%" % seq_type % line_nu*m*/);
     }
@@ -136,7 +136,7 @@ void PirIOHandler::Import(seq::SequenceList& aln, std::istream& instream)
     }
     try {
       seq::SequenceHandle ss=seq::CreateSequence(name, seq_string.str());
-      aln.AddSequence(ss);          
+      aln.AddSequence(ss);
       seq_count+=1;
     } catch (seq::InvalidSequence& e) {
       throw e;
diff --git a/modules/io/src/seq/promod_io_handler.cc b/modules/io/src/seq/promod_io_handler.cc
index 612ca2b10..50c6b67a0 100644
--- a/modules/io/src/seq/promod_io_handler.cc
+++ b/modules/io/src/seq/promod_io_handler.cc
@@ -24,7 +24,7 @@
 
 #include <ost/message.hh>
 #include <boost/filesystem/fstream.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/format.hpp>
 #include <boost/algorithm/string/erase.hpp>
@@ -37,19 +37,19 @@ using boost::format;
 namespace ost { namespace io {
 
 void PromodIOHandler::Import(seq::SequenceList& ali,
-                              const boost::filesystem::path& loc) {                        
+                              const boost::filesystem::path& loc) {
   boost::filesystem::ifstream infile(loc);
   this->Import(ali, infile);
 }
 
 void PromodIOHandler::Export(const seq::ConstSequenceList& msa,
-                             const boost::filesystem::path& loc) const 
+                             const boost::filesystem::path& loc) const
 {
   throw IOException("Export of alignments to PROMOD Format is not supported");
 }
 
 
-bool PromodIOHandler::ProvidesImport(const boost::filesystem::path& loc, 
+bool PromodIOHandler::ProvidesImport(const boost::filesystem::path& loc,
                                     const String& format) {
   if (format=="auto") {
    String match_suf_string=loc.string();
@@ -60,10 +60,10 @@ bool PromodIOHandler::ProvidesImport(const boost::filesystem::path& loc,
   } else if(format=="promod") {
     return true;
   }
-  return false;                
+  return false;
 }
 
-bool PromodIOHandler::ProvidesExport(const boost::filesystem::path& loc, 
+bool PromodIOHandler::ProvidesExport(const boost::filesystem::path& loc,
                                       const String& format) {
   return false;
 }
@@ -73,8 +73,8 @@ void PromodIOHandler::Import(seq::SequenceList& ali,
 {
   static const char* whitespace="\t ";
   typedef std::map<String, seq::SequenceHandle> SeqMap;
-  SeqMap seq_map;  
-  String line;  
+  SeqMap seq_map;
+  String line;
   std::vector<int> starts;
   while (std::getline(instream, line)) {
     size_t pos=line.find_first_not_of(whitespace);
@@ -117,16 +117,16 @@ void PromodIOHandler::Import(seq::SequenceList& ali,
        i!=e; ++i) {
     min_start=std::min(min_start, *i);
   }
-  
+
   if (seq_map.size()==0) {
     throw IOException("Bad PROMOD file: File is empty");
   }
-    
+
   for (SeqMap::iterator i=seq_map.begin(), e=seq_map.end(); i!=e; ++i) {
     int start=starts[std::distance(i, seq_map.begin())];
     if (min_start<start) {
       i->second.SetString(String(start-min_start, '-')+i->second.GetString());
-    }    
+    }
     ali.AddSequence(i->second);
   }
 
diff --git a/modules/io/src/seq/pssm_io_handler.cc b/modules/io/src/seq/pssm_io_handler.cc
index 892bf10c7..25a185c9f 100644
--- a/modules/io/src/seq/pssm_io_handler.cc
+++ b/modules/io/src/seq/pssm_io_handler.cc
@@ -24,7 +24,7 @@
 #include "pssm_io_handler.hh"
 
 #include <boost/algorithm/string/predicate.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/filesystem/fstream.hpp>
 #include <boost/iostreams/filter/gzip.hpp>
 #include <boost/iostreams/filtering_stream.hpp>
@@ -44,7 +44,7 @@ void PssmIOHandler::Import(seq::ProfileHandle& prof,
     throw IOException("Could not open " + loc.string());
   }
   // add unzip if necessary
-  if (boost::iequals(".gz", boost::filesystem::extension(loc))) {
+  if (boost::iequals(".gz", boost::filesystem::path(loc).extension().string())) {
     in.push(boost::iostreams::gzip_decompressor());
   }
   in.push(stream);
@@ -63,7 +63,7 @@ void PssmIOHandler::Export(const seq::ProfileHandle& prof,
   throw IOException("Cannot write pssm files.");
 }
 
-bool PssmIOHandler::ProvidesImport(const boost::filesystem::path& loc, 
+bool PssmIOHandler::ProvidesImport(const boost::filesystem::path& loc,
                                   const String& format) {
   if (format=="auto") {
     String match_suf_string = loc.string();
@@ -79,7 +79,7 @@ bool PssmIOHandler::ProvidesImport(const boost::filesystem::path& loc,
   return false;
 }
 
-bool PssmIOHandler::ProvidesExport(const boost::filesystem::path& loc, 
+bool PssmIOHandler::ProvidesExport(const boost::filesystem::path& loc,
                                   const String& format) {
   // no writers here
   return false;
diff --git a/modules/mol/alg/src/entity_to_density.cc b/modules/mol/alg/src/entity_to_density.cc
index b6ac49efc..ec74b8256 100644
--- a/modules/mol/alg/src/entity_to_density.cc
+++ b/modules/mol/alg/src/entity_to_density.cc
@@ -2,7 +2,7 @@
 #include <cmath>
 
 #include <boost/filesystem/fstream.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp>
 
 #include <ost/log.hh>
@@ -139,7 +139,7 @@ public:
       while (found != true && table_iter!=scatt_props_table_.end())
       {
         if ( (*table_iter).element == (*ai).GetElement())
-        {        
+        {
           geom::Vec3 coord = ai->GetPos();
 
           if (coord[0] >= map_start_[0] &&
diff --git a/modules/mol/alg/src/lddt.cc b/modules/mol/alg/src/lddt.cc
index 4b913efdb..843ed4c47 100644
--- a/modules/mol/alg/src/lddt.cc
+++ b/modules/mol/alg/src/lddt.cc
@@ -24,7 +24,7 @@
 #endif
 #include <boost/program_options.hpp>
 #include <boost/filesystem/fstream.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <ost/base.hh>
 #include <ost/boost_filesystem_helper.hh>
 #include <ost/mol/chain_view.hh>
@@ -71,7 +71,7 @@ EntityHandle load(const String& file, const IOProfile& profile)
 
       if (ent.GetChainList().size()!=1) {
         std::cout << "WARNING: File " << file << " has more than one chain" << std::endl;
-      }    
+      }
       return ent;
     }
     std::cerr << "ERROR: '" << file << "' does not contain any ATOM records. "
@@ -105,22 +105,22 @@ void usage()
 CompoundLibPtr load_compound_lib(const String& custom_path)
 {
   if (custom_path!="") {
-    if (fs::exists(custom_path)) {  
+    if (fs::exists(custom_path)) {
       return CompoundLib::Load(custom_path);
     } else {
       std::cerr << "Could not find compounds.chemlib at the provided location, trying other options" << std::endl;
     }
-  } 
+  }
   if (fs::exists("compounds.chemlib")) {
     return CompoundLib::Load("compounds.chemlib");
   }
-  char result[ 1024 ]; 
+  char result[ 1024 ];
   CompoundLibPtr lib;
-  String exe_path; 
+  String exe_path;
   #if defined(__APPLE__)
   uint32_t size=1023;
   if (!_NSGetExecutablePath(result, &size)) {
-    exe_path=String(result); 
+    exe_path=String(result);
   }
   #else
     #if defined (_MSC_VER)
@@ -130,20 +130,20 @@ CompoundLibPtr load_compound_lib(const String& custom_path)
       exe_path = std::string( result, (count > 0) ? count : 0 );
     #endif
   #endif
-  if (exe_path.empty()) { 
+  if (exe_path.empty()) {
     std::cerr << "Could not determine the path of the lddt executable. Will only "
        "look for compounds.chemlib in the current working directory" << std::endl;
   } else {
     fs::path path_and_exe(exe_path);
-    fs::path path_only=path_and_exe.branch_path();
-    fs::path share_path = path_only.branch_path();
+    fs::path path_only=path_and_exe.parent_path();
+    fs::path share_path = path_only.parent_path();
     share_path = share_path / "share" / "openstructure" / "compounds.chemlib";
 
     String share_path_string=BFPathToString(share_path);
-      
+
     if (fs::exists(share_path_string)) {
       return CompoundLib::Load(share_path_string);
-    }  
+    }
   }
   if (!lib) {
     std::cerr << "Could not load compounds.chemlib" << std::endl;
@@ -239,7 +239,7 @@ int main (int argc, char **argv)
   if (vm.count("verbosity")) {
     verbosity_level=vm["verbosity"].as<int>();
     if (verbosity_level==0) {
-      ost_verbosity_level=2;    
+      ost_verbosity_level=2;
     } else if (verbosity_level==1) {
       ost_verbosity_level=3;
     } else if (verbosity_level==2) {
@@ -265,12 +265,12 @@ int main (int argc, char **argv)
     settings.sequence_separation=vm["sequence_separation"].as<int>();
   }
 
-  std::vector<EntityView> ref_list;  
-    
-  // loads the reference file and creates the list of distances to check in lddt    
+  std::vector<EntityView> ref_list;
+
+  // loads the reference file and creates the list of distances to check in lddt
   // if the reference file is a comma-separated list of files, switches to multi-
   // reference mode
-  GlobalRDMap glob_dist_list; 
+  GlobalRDMap glob_dist_list;
   String ref_file=files.back();
   ost::StringRef ref_file_sr(ref_file.c_str(),ref_file.length());
   std::vector<StringRef> ref_file_split_sr=ref_file_sr.split(',');
@@ -326,7 +326,7 @@ int main (int argc, char **argv)
     exit(-1);
   }
 
-  // cycles through the models to evaluate 
+  // cycles through the models to evaluate
   for (size_t i=0; i<files.size(); ++i) {
     EntityHandle model=load(files[i], profile);
     if (!model) {
@@ -349,7 +349,7 @@ int main (int argc, char **argv)
         std::cout << e.what() << std::endl;
         exit(-1);
       }
-      
+
       try {
         CheckStructure(model_view,
                        stereochemical_params.bond_table,
@@ -376,7 +376,7 @@ int main (int argc, char **argv)
       }
     }
 
-    // computes the lddt score   
+    // computes the lddt score
     LocalDistDiffTest(model_view, ref_list, glob_dist_list, settings);
 
     // prints the residue-by-residue statistics
diff --git a/modules/mol/alg/src/local_dist_diff_test.cc b/modules/mol/alg/src/local_dist_diff_test.cc
index 1182dc375..fe09f7cf8 100644
--- a/modules/mol/alg/src/local_dist_diff_test.cc
+++ b/modules/mol/alg/src/local_dist_diff_test.cc
@@ -5,7 +5,7 @@
 #include <ost/platform.hh>
 #include "local_dist_diff_test.hh"
 #include <boost/concept_check.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <ost/mol/alg/consistency_checks.hh>
 
 namespace ost { namespace mol { namespace alg {
@@ -30,24 +30,24 @@ bool within_tolerance(Real mdl_dist, const std::pair<Real,Real>& values, Real to
   // this considers min & max distance observed in all reference structures
   // -> for single reference case values.first and values.second are the same
   return (values.first-tol)<=mdl_dist && (values.second+tol)>=mdl_dist;
-}      
+}
 
 // helper function
 std::pair<long int, long int> calc_overlap1(const ResidueRDMap& res_distance_list, const ResNum& rnum,
                                     ChainView mdl_chain, int sequence_separation,
-                                    std::vector<Real>& tol_list, bool only_fixed, 
+                                    std::vector<Real>& tol_list, bool only_fixed,
                                     bool swap,std::vector<std::pair<long int, long int> >& overlap_list, bool log )
 {
   std::pair<long int, long int> overlap(0, 0);
-  ResidueView mdl_res=mdl_chain.FindResidue(rnum); 
+  ResidueView mdl_res=mdl_chain.FindResidue(rnum);
   for (ResidueRDMap::const_iterator ai=res_distance_list.begin(); ai!=res_distance_list.end(); ++ai) {
-    const UAtomIdentifiers& uais = ai->first; 
+    const UAtomIdentifiers& uais = ai->first;
     const std::pair <Real,Real>& values = ai->second;
     const UniqueAtomIdentifier& first_atom=uais.first;
     const UniqueAtomIdentifier& second_atom=uais.second;
     String name=swap ? SwappedName(first_atom.GetAtomName()) : first_atom.GetAtomName();
     AtomView av1=mdl_res ? mdl_res.FindAtom(name) : AtomView();
- 
+
     if (only_fixed) {
        if (std::abs(first_atom.GetResNum().GetNum()-second_atom.GetResNum().GetNum())<=sequence_separation) {
           continue;
@@ -56,10 +56,10 @@ std::pair<long int, long int> calc_overlap1(const ResidueRDMap& res_distance_lis
           continue;
       }
     }
-    if (!only_fixed) {   
+    if (!only_fixed) {
       if (first_atom.GetResNum().GetNum()<=(second_atom.GetResNum().GetNum()+sequence_separation)) {
         continue;
-      }    
+      }
     }
     ResidueView rv2=mdl_chain.FindResidue(second_atom.GetResNum());
     overlap.second+=tol_list.size();
@@ -80,7 +80,7 @@ std::pair<long int, long int> calc_overlap1(const ResidueRDMap& res_distance_lis
     Real mdl_dist=geom::Length(av1.GetPos()-av2.GetPos());
     std::vector<Real>::const_reverse_iterator rend_it=tol_list.rend();
     for (std::vector<Real>::const_reverse_iterator tol_list_it=tol_list.rbegin();tol_list_it!=rend_it;++tol_list_it) {
-      Real tol = * tol_list_it; 
+      Real tol = * tol_list_it;
       if (within_tolerance(mdl_dist,values,tol)) {
         if (log) {
           LOG_VERBOSE("LDDT:" << " " << av1.GetResidue().GetChain() << " "
@@ -108,17 +108,17 @@ std::pair<long int, long int> calc_overlap1(const ResidueRDMap& res_distance_lis
                       << " " << mdl_dist << " " << values.first << " "
                       << values.second << " " << tol << " " << "FAIL");
         }
-        break;  
+        break;
       }
-    }    
+    }
   }
   return overlap;
-}  
+}
 
 // helper function used by the alignment-based Local Distance Difference Test
 std::pair<Real, Real> calc_overlap2(const seq::ConstSequenceHandle& ref_seq,
                                     const seq::ConstSequenceHandle& mdl_seq,
-                                    int pos, Real tol, Real max_dist, 
+                                    int pos, Real tol, Real max_dist,
                                     bool only_fixed, bool swap)
 {
   std::pair<Real, Real> overlap(0.0, 0.0);
@@ -132,20 +132,20 @@ std::pair<Real, Real> calc_overlap2(const seq::ConstSequenceHandle& ref_seq,
   AtomViewList within;
   if (max_dist<0) {
     within=ref.GetAtomList();
-  }  
+  }
   for (AtomViewList::iterator ai=ref_atoms.begin(),
        ae=ref_atoms.end(); ai!=ae; ++ai) {
     if (ai->GetElement()=="H") { continue; }
     String name=swap ? SwappedName(ai->GetName()) : ai->GetName();
     AtomView av1=mdl_res ? mdl_res.FindAtom(name) : AtomView();
-    if (max_dist>=0){ 
+    if (max_dist>=0){
       within=ref.FindWithin(ai->GetPos(), max_dist);
     }
     for (AtomViewList::iterator aj=within.begin(),
          ae2=within.end(); aj!=ae2; ++aj) {
-      if (aj->GetElement()=="H" || 
-          aj->GetResidue().GetChain()!=ai->GetResidue().GetChain()) { 
-          continue; 
+      if (aj->GetElement()=="H" ||
+          aj->GetResidue().GetChain()!=ai->GetResidue().GetChain()) {
+          continue;
       }
       if (only_fixed) {
         if (aj->GetResidue().GetNumber()==ref_res.GetNumber()) {
@@ -175,7 +175,7 @@ std::pair<Real, Real> calc_overlap2(const seq::ConstSequenceHandle& ref_seq,
         continue;
       } else {
         if (aj->GetResidue().GetNumber()>ref_res.GetNumber()) {
-          overlap.second+=1.0;    
+          overlap.second+=1.0;
 
           try {
            int aln_pos=ref_seq.GetPos(aj->GetResidue().GetIndex());
@@ -193,27 +193,27 @@ std::pair<Real, Real> calc_overlap2(const seq::ConstSequenceHandle& ref_seq,
               overlap.first+=1;
             }
           } catch (...) { }
-        }  
+        }
       }
-    }      
+    }
   }
   return overlap;
 }
 
-// for each residue with multiple possible nomenclature conventions, checks which choice (switched or not) 
-// of atom nomenclature gives the highest lddt score then changes the naming convention of the input 
+// for each residue with multiple possible nomenclature conventions, checks which choice (switched or not)
+// of atom nomenclature gives the highest lddt score then changes the naming convention of the input
 // entity view accordingly
 void check_and_swap(const GlobalRDMap& glob_dist_list, const EntityView& mdl, std::vector<Real> cutoff_list, int sequence_separation,  std::vector<std::pair<long int, long int> > overlap_list)
 {
-  ChainView mdl_chain=mdl.GetChainList()[0]; 
+  ChainView mdl_chain=mdl.GetChainList()[0];
   XCSEditor edi=mdl.GetHandle().EditXCS(BUFFERED_EDIT);
-  for (GlobalRDMap::const_iterator i=glob_dist_list.begin(); i!=glob_dist_list.end(); ++i) {  
+  for (GlobalRDMap::const_iterator i=glob_dist_list.begin(); i!=glob_dist_list.end(); ++i) {
     ResNum rnum =  i->first;
     if (i->second.size()==0) {
       continue;
     }
-    ResidueView mdl_res=mdl_chain.FindResidue(rnum); 
-    if (!mdl_res) {   
+    ResidueView mdl_res=mdl_chain.FindResidue(rnum);
+    if (!mdl_res) {
       continue;
     }
     String rname = mdl_res.GetName();
@@ -222,12 +222,12 @@ void check_and_swap(const GlobalRDMap& glob_dist_list, const EntityView& mdl, st
       continue;
     }
     std::pair<long int, long int> ov1=calc_overlap1(i->second, rnum,mdl_chain, sequence_separation,
-                                          cutoff_list, true, 
+                                          cutoff_list, true,
                                           false, overlap_list,false);
- 
+
     std::pair<long int, long int> ov2=calc_overlap1(i->second, rnum, mdl_chain, sequence_separation,
-                                          cutoff_list, true, 
-                                          true, overlap_list,false); 
+                                          cutoff_list, true,
+                                          true, overlap_list,false);
 
     if (static_cast<Real>(ov1.first)/ov1.second<
         static_cast<Real>(ov2.first)/ov2.second) {
@@ -237,7 +237,7 @@ void check_and_swap(const GlobalRDMap& glob_dist_list, const EntityView& mdl, st
           edi.RenameAtom(j->GetHandle(), SwappedName(j->GetName()));
         }
       }
-    } 
+    }
   }
 }
 
@@ -252,22 +252,22 @@ void update_existence_map (ExistenceMap& ex_map, const EntityView& ev, int ref_c
 }
 
 // helper function for super-fast lookup of atom existence in multiple reference input structures
-int in_existence_map(const ExistenceMap& ex_map, const UniqueAtomIdentifier& uai) 
+int in_existence_map(const ExistenceMap& ex_map, const UniqueAtomIdentifier& uai)
 {
   ExistenceMap::const_iterator find_uai_ci = ex_map.find(uai);
   return find_uai_ci!=ex_map.end() ? find_uai_ci->second : 0;
-}    
+}
 
 // merges distance lists from multiple reference structures. The login is described in the code
 void merge_distance_lists(GlobalRDMap& ref_dist_map, const GlobalRDMap& new_dist_map, ExistenceMap& ex_map, const EntityView& ref,int ref_counter)
 {
-  // iterate over the residues in the ref_dist_map   
+  // iterate over the residues in the ref_dist_map
   for (GlobalRDMap::iterator ref_dist_map_it=ref_dist_map.begin();ref_dist_map_it!=ref_dist_map.end();++ref_dist_map_it) {
     ResNum ref_resnum = ref_dist_map_it->first;
     GlobalRDMap::const_iterator find_new_res_ci = new_dist_map.find(ref_resnum);
-    //if the residue is found in new_dist_map,  
+    //if the residue is found in new_dist_map,
     if (find_new_res_ci != new_dist_map.end()) {
-      //iterate over the the reference distances in the ResidueDistanceMap  
+      //iterate over the the reference distances in the ResidueDistanceMap
       //It's on purpose that we don't increase the loop variable inside
       //the for statement! This is required to make iteration work when erasing
       //an element from the map while iterating over it.
@@ -278,17 +278,17 @@ void merge_distance_lists(GlobalRDMap& ref_dist_map, const GlobalRDMap& new_dist
         bool erased=false;
         std::pair<Real,Real>& ref_minmax = ref_res_map_it->second;
         ResidueRDMap::const_iterator find_new_rd_ci = find_new_res_ci->second.find(ref_rd);
-        // if you find the distance in the residue new, udate min and max  
+        // if you find the distance in the residue new, udate min and max
         if (find_new_rd_ci != find_new_res_ci->second.end()) {
           if (find_new_rd_ci->second.first < ref_minmax.first) {
             ref_minmax.first=find_new_rd_ci->second.first;
           } else if (find_new_rd_ci->second.second > ref_minmax.second) {
             ref_minmax.second=find_new_rd_ci->second.second;
           }
-        } else {              
-          // if you don't find it in the residue new, check that it is not missing because it is too long  
+        } else {
+          // if you don't find it in the residue new, check that it is not missing because it is too long
           UniqueAtomIdentifier first_atom_to_find = ref_rd.first;
-          UniqueAtomIdentifier second_atom_to_find = ref_rd.second;  
+          UniqueAtomIdentifier second_atom_to_find = ref_rd.second;
           // if both atoms are there, remove the distance from the ref_dist_map,
           if ((ref.FindAtom(first_atom_to_find.GetChainName(),first_atom_to_find.GetResNum(),first_atom_to_find.GetAtomName()).IsValid() &&
                ref.FindAtom(second_atom_to_find.GetChainName(),second_atom_to_find.GetResNum(),second_atom_to_find.GetAtomName()).IsValid()) ) {
@@ -305,20 +305,20 @@ void merge_distance_lists(GlobalRDMap& ref_dist_map, const GlobalRDMap& new_dist
         UAtomIdentifiers new_rd = new_res_map_it->first;
         std::pair<Real,Real> new_minmax = new_res_map_it->second;
         ResidueRDMap::const_iterator find_ref_rd_ci = ref_dist_map_it->second.find(new_rd);
-        // if the distance is found in the residue ref, 
+        // if the distance is found in the residue ref,
         // it has been taken care of before. If not
         if (find_ref_rd_ci==ref_dist_map_it->second.end()) {
           UniqueAtomIdentifier first_atom_to_find = new_rd.first;
           UniqueAtomIdentifier second_atom_to_find = new_rd.second;
           // check that there isn't a structure already processed where both atoms are in
-          // if there is none, add the distance to the residue ref map 
+          // if there is none, add the distance to the residue ref map
           if (!(in_existence_map(ex_map,first_atom_to_find) & in_existence_map(ex_map,second_atom_to_find))) {
-            ref_dist_map_it->second[new_rd]= new_minmax; 
+            ref_dist_map_it->second[new_rd]= new_minmax;
           }
-        }      
-      } 
+        }
+      }
     }
-  // if the residue was not found in the new list, it means that it is 
+  // if the residue was not found in the new list, it means that it is
   // absent in the new structure, no new information
   }
   // now iterate over the residues in the new_list
@@ -328,7 +328,7 @@ void merge_distance_lists(GlobalRDMap& ref_dist_map, const GlobalRDMap& new_dist
     // if the residue is found in new_dist_map, it has been taken care before,
     // if not, add it to the res_dist_map:
       if (find_ref_res_ci == ref_dist_map.end()) {
-      ref_dist_map[new_resnum] = new_dist_map_it->second;           
+      ref_dist_map[new_resnum] = new_dist_map_it->second;
     }
   }
 }
@@ -343,9 +343,9 @@ std::pair<int,int> ComputeCoverage(const EntityView& v,const GlobalRDMap& glob_d
   if (v.GetResidueList().size()==0) {
     if (glob_dist_list.size()==0) {
       return std::make_pair(0,-1);
-    } else {    
+    } else {
       return std::make_pair(0,glob_dist_list.size());
-    }  
+    }
   }
   ChainView vchain=v.GetChainList()[0];
   for (GlobalRDMap::const_iterator i=glob_dist_list.begin();i!=glob_dist_list.end();++i)
@@ -376,7 +376,7 @@ bool IsStandardResidue(String rn)
 {
   String upper_rn=rn;
   std::transform(rn.begin(),rn.end(),rn.begin(),toupper);
-  if (upper_rn == "ALA" ||    
+  if (upper_rn == "ALA" ||
   upper_rn == "ARG" ||
   upper_rn == "ASN" ||
   upper_rn == "ASP" ||
@@ -384,20 +384,20 @@ bool IsStandardResidue(String rn)
   upper_rn == "GLU" ||
   upper_rn == "LYS" ||
   upper_rn == "SER" ||
-  upper_rn == "CYS" ||      
-  upper_rn == "TYR" ||  
-  upper_rn == "TRP" || 
+  upper_rn == "CYS" ||
+  upper_rn == "TYR" ||
+  upper_rn == "TRP" ||
   upper_rn == "THR" ||
   upper_rn == "VAL" ||
   upper_rn == "ILE" ||
   upper_rn == "MET" ||
-  upper_rn == "LEU" ||  
-  upper_rn == "GLY" ||  
-  upper_rn == "PRO" ||  
-  upper_rn == "HIS" ||  
+  upper_rn == "LEU" ||
+  upper_rn == "GLY" ||
+  upper_rn == "PRO" ||
+  upper_rn == "HIS" ||
   upper_rn == "PHE") {
     return true;
-  }  
+  }
   return false;
 }
 
@@ -413,7 +413,7 @@ StereoChemicalProps::StereoChemicalProps(
     angle_table(init_angle_table),
     nonbonded_table(init_nonbonded_table) {}
 
-lDDTSettings::lDDTSettings(): radius(15.0), 
+lDDTSettings::lDDTSettings(): radius(15.0),
                               sequence_separation(0),
                               label("locallddt") {
     cutoffs.push_back(0.5);
@@ -422,11 +422,11 @@ lDDTSettings::lDDTSettings(): radius(15.0),
     cutoffs.push_back(4.0);
   }
 
-lDDTSettings::lDDTSettings(Real init_radius, 
+lDDTSettings::lDDTSettings(Real init_radius,
                            int init_sequence_separation,
                            std::vector<Real>& init_cutoffs,
                            String init_label):
-                    radius(init_radius), 
+                    radius(init_radius),
                     sequence_separation(init_sequence_separation),
                     cutoffs(init_cutoffs),
                     label(init_label) {}
@@ -462,7 +462,7 @@ lDDTLocalScore::lDDTLocalScore(String init_cname,
                                String init_quality_problems,
                                Real init_local_lddt,
                                int init_conserved_dist,
-                               int init_total_dist): 
+                               int init_total_dist):
                                        cname(init_cname),
                                        rname(init_rname),
                                        rnum(init_rnum),
@@ -515,7 +515,7 @@ lDDTScorer::lDDTScorer(std::vector<EntityView>& init_references,
     _num_tot_con = -1;
     _global_score = -1.0;
     CleanlDDTReferences(references_view);
-    _PrepareGlobalRDMap();  
+    _PrepareGlobalRDMap();
   }
 
 Real lDDTScorer::GetGlobalScore(){
@@ -611,61 +611,61 @@ void lDDTScorer::_GetLocallDDT(){
 
 GlobalRDMap CreateDistanceList(const EntityView& ref,Real max_dist)
 {
- GlobalRDMap dist_list; 
+ GlobalRDMap dist_list;
  if (!ref.GetChainCount()) {
    return dist_list;
  }
- ResidueViewList ref_residues=ref.GetChainList()[0].GetResidueList(); 
+ ResidueViewList ref_residues=ref.GetChainList()[0].GetResidueList();
  for (ResidueViewList::iterator i=ref_residues.begin(), e=ref_residues.end(); i!=e; ++i) {
    if (IsStandardResidue(i->GetName())) {
      ResidueRDMap res_dist_list;
-     ResNum rnum = i->GetNumber();  
+     ResNum rnum = i->GetNumber();
      AtomViewList ref_atoms=i->GetAtomList();
      AtomViewList within;
      if (max_dist<0){
        within=ref.GetAtomList();
-     }  
+     }
      for (AtomViewList::iterator ai=ref_atoms.begin(), ae=ref_atoms.end(); ai!=ae; ++ai) {
        UniqueAtomIdentifier first_atom(ai->GetResidue().GetChain().GetName(),ai->GetResidue().GetNumber(),ai->GetResidue().GetName(),ai->GetName());
        if (ai->GetElement()=="H") { continue; }
-       if (max_dist>=0){ 
+       if (max_dist>=0){
          within=ref.FindWithin(ai->GetPos(), max_dist);
        }
-       for (AtomViewList::iterator aj=within.begin(), ae2=within.end(); aj!=ae2; ++aj) {      
+       for (AtomViewList::iterator aj=within.begin(), ae2=within.end(); aj!=ae2; ++aj) {
          UniqueAtomIdentifier second_atom(aj->GetResidue().GetChain().GetName(),aj->GetResidue().GetNumber(),aj->GetResidue().GetName(),aj->GetName());
          if (aj->GetElement()=="H" ||
              aj->GetResidue().GetChain()!=ai->GetResidue().GetChain()) {
              continue;
          }
          Real dist=geom::Length(ai->GetPos()-aj->GetPos());
-         UAtomIdentifiers atoms = std::make_pair(first_atom,second_atom); 
-         std::pair<Real,Real> values = std::make_pair(dist,dist);  
+         UAtomIdentifiers atoms = std::make_pair(first_atom,second_atom);
+         std::pair<Real,Real> values = std::make_pair(dist,dist);
          res_dist_list[atoms]=values;
        }
-     }   
+     }
      dist_list[rnum]=res_dist_list;
    }
- } 
+ }
  return dist_list;
-} 
+}
 
 GlobalRDMap CreateDistanceListFromMultipleReferences(const std::vector<EntityView>& ref_list, std::vector<Real>& cutoff_list, int sequence_separation, Real max_dist)
 {
-  int ref_counter=0;  
-  ExistenceMap ex_map;  
+  int ref_counter=0;
+  ExistenceMap ex_map;
   GlobalRDMap glob_dist_list = CreateDistanceList(ref_list[0],max_dist);
   update_existence_map (ex_map,ref_list[0],ref_counter);
-  ref_counter++;  
+  ref_counter++;
   for (std::vector<EntityView>::const_iterator ref_list_it=ref_list.begin()+1;ref_list_it!=ref_list.end();++ref_list_it) {
        EntityView ref = *ref_list_it;
        std::vector<std::pair<long int, long int> > overlap_list(ref.GetResidueCount(), std::pair<long int, long int>(0, 0));
        check_and_swap(glob_dist_list,ref,cutoff_list,sequence_separation,overlap_list);
        GlobalRDMap new_dist_list=CreateDistanceList(ref,max_dist);
        merge_distance_lists(glob_dist_list,new_dist_list,ex_map,ref,ref_counter);
-       update_existence_map (ex_map,ref,ref_counter); 
+       update_existence_map (ex_map,ref,ref_counter);
        ref_counter++;
-  }    
-  return glob_dist_list;  
+  }
+  return glob_dist_list;
 }
 
 void PrintResidueRDMap(const ResidueRDMap& res_dist_list)
@@ -675,17 +675,17 @@ void PrintResidueRDMap(const ResidueRDMap& res_dist_list)
     std::pair<Real,Real> minmax = res_dist_list_it->second;
     std::cout << uais.first.GetChainName() << " " << uais.first.GetResNum() << " " << uais.first.GetResidueName() << " " << uais.first.GetAtomName() << " " <<
                  uais.second.GetChainName() << " " << uais.second.GetResNum() << " " << uais.second.GetResidueName() << " " << uais.second.GetAtomName() << " " <<
-                 minmax.first << " " << minmax.second << std::endl;       
+                 minmax.first << " " << minmax.second << std::endl;
   }
 }
 
 
 void PrintGlobalRDMap(const GlobalRDMap& glob_dist_list){
   for (GlobalRDMap::const_iterator glob_dist_list_it = glob_dist_list.begin();glob_dist_list_it!=glob_dist_list.end();++glob_dist_list_it) {
-    if (glob_dist_list_it->second.size()!=0) {  
+    if (glob_dist_list_it->second.size()!=0) {
       PrintResidueRDMap(glob_dist_list_it->second);
-    }    
-  }    
+    }
+  }
 }
 
 
@@ -703,13 +703,13 @@ std::pair<long int,long int> LocalDistDiffTest(const EntityView& mdl, const Glob
   }
   std::vector<std::pair<long int, long int> > overlap_list(mdl.GetResidueCount(), std::pair<long int, long int>(0, 0));
   check_and_swap(glob_dist_list,mdl,cutoff_list,sequence_separation,overlap_list);
-  ChainView mdl_chain=mdl.GetChainList()[0];  
+  ChainView mdl_chain=mdl.GetChainList()[0];
   overlap_list.clear();
   std::pair<long int, long int> total_ov(0, 0);
   for (GlobalRDMap::const_iterator i=glob_dist_list.begin(), e=glob_dist_list.end(); i!=e; ++i) {
     ResNum rn = i->first;
     if (i->second.size()!=0) {
-      std::pair<long int, long int> ov1=calc_overlap1(i->second, rn, mdl_chain, sequence_separation, cutoff_list, 
+      std::pair<long int, long int> ov1=calc_overlap1(i->second, rn, mdl_chain, sequence_separation, cutoff_list,
                                             false, false, overlap_list,true);
       total_ov.first+=ov1.first;
       total_ov.second+=ov1.second;
@@ -739,7 +739,7 @@ Real LocalDistDiffTest(const EntityView& mdl, const EntityView& target, Real cut
    std::vector<Real> cutoffs;
    cutoffs.push_back(cutoff);
    GlobalRDMap glob_dist_list = CreateDistanceList(target,max_dist);
-   int sequence_separation = 0; 
+   int sequence_separation = 0;
    std::pair<long int,long int>  total_ov = LocalDistDiffTest(mdl, glob_dist_list, cutoffs, sequence_separation, local_lddt_property_string);
    return static_cast<Real>(total_ov.first)/(static_cast<Real>(total_ov.second) ? static_cast<Real>(total_ov.second) : 1);
 }
@@ -773,7 +773,7 @@ Real LocalDistDiffTest(const ost::seq::AlignmentHandle& aln,
                    Real cutoff, Real max_dist, int ref_index, int mdl_index)
 {
   seq::ConstSequenceHandle ref_seq=aln.GetSequence(ref_index);
-  seq::ConstSequenceHandle mdl_seq=aln.GetSequence(mdl_index);  
+  seq::ConstSequenceHandle mdl_seq=aln.GetSequence(mdl_index);
   if (!ref_seq.HasAttachedView()) {
     LOG_ERROR("reference sequence doesn't have a view attached.");
     return 0.0;
@@ -789,19 +789,19 @@ Real LocalDistDiffTest(const ost::seq::AlignmentHandle& aln,
       continue;
     }
     String rname=mdl_res.GetName();
-    if (!(rname=="GLU" || rname=="ASP" || rname=="VAL" || rname=="TYR" || 
+    if (!(rname=="GLU" || rname=="ASP" || rname=="VAL" || rname=="TYR" ||
          rname=="PHE" || rname=="LYS" || rname=="ARG")) {
       continue;
     }
     std::pair<Real, Real> ov1=calc_overlap2(ref_seq, mdl_seq, i,
-                                            cutoff, max_dist, true, 
+                                            cutoff, max_dist, true,
                                             false);
     std::pair<Real, Real> ov2=calc_overlap2(ref_seq, mdl_seq, i,
-                                            cutoff, max_dist, true, 
+                                            cutoff, max_dist, true,
                                             true);
     if (ov1.first/ov1.second<ov2.first/ov2.second) {
      AtomViewList atoms=mdl_res.GetAtomList();
-     for (AtomViewList::iterator j=atoms.begin(), 
+     for (AtomViewList::iterator j=atoms.begin(),
           e2=atoms.end(); j!=e2; ++j) {
        if (Swappable(rname, j->GetName())) {
          edi.RenameAtom(j->GetHandle(), SwappedName(j->GetName()));
@@ -811,7 +811,7 @@ Real LocalDistDiffTest(const ost::seq::AlignmentHandle& aln,
   }
   std::pair<Real, Real> total_ov(0.0, 0.0);
   for (int i=0; i<aln.GetLength(); ++i) {
-     std::pair<Real, Real> ov1=calc_overlap2(ref_seq, mdl_seq, i, cutoff, 
+     std::pair<Real, Real> ov1=calc_overlap2(ref_seq, mdl_seq, i, cutoff,
                                              max_dist, false, false);
      total_ov.first+=ov1.first;
      total_ov.second+=ov1.second;
@@ -867,12 +867,12 @@ void CheckStructure(EntityView& ent,
                     Real angle_tolerance){
   // performs structural checks and filters the structure
   StereoChemistryInfo stereo_chemistry_info;
-  try { 
+  try {
     std::pair<EntityView,StereoChemistryInfo> csc_result = alg::CheckStereoChemistry(ent,bond_table,angle_table,bond_tolerance,angle_tolerance);
     ent = csc_result.first;
     stereo_chemistry_info = csc_result.second;
-  } catch (std::exception& e) {       
-    std::cout << "An error occurred during the structure quality checks, stage 1:" << std::endl;    
+  } catch (std::exception& e) {
+    std::cout << "An error occurred during the structure quality checks, stage 1:" << std::endl;
     std::cout << e.what() << std::endl;
     exit(-1);
   }
@@ -895,7 +895,7 @@ void CheckStructure(EntityView& ent,
     clash_info = fc_result.second;
   } catch (std::exception& e) {
     std::stringstream serr;
-    serr << "An error occurred during the structure quality checks, stage 2: " << e.what();    
+    serr << "An error occurred during the structure quality checks, stage 2: " << e.what();
     throw ost::Error(serr.str());
   }
   std::cout << clash_info.GetClashCount() << " non-bonded short-range distances shorter than tolerance distance" << std::endl;
@@ -931,11 +931,11 @@ std::vector<lDDTLocalScore> GetlDDTPerResidueStats(EntityView& model,
         assessed = true;
         assessed_string="Yes";
       }
-      if (ritv.HasProp("stereo_chemical_violation_sidechain") || 
+      if (ritv.HasProp("stereo_chemical_violation_sidechain") ||
           ritv.HasProp("steric_clash_sidechain")) {
         quality_problems_string="Yes";
       }
-      if (ritv.HasProp("stereo_chemical_violation_backbone") || 
+      if (ritv.HasProp("stereo_chemical_violation_backbone") ||
           ritv.HasProp("steric_clash_backbone")) {
         quality_problems_string="Yes+";
       }
@@ -1008,15 +1008,15 @@ Real OldStyleLDDTHA(EntityView& v, const GlobalRDMap& global_dist_list)
     Real lddt05 = lddt05o.first/(lddt05o.second ? lddt05o.second : 1);
     Real lddt1 = lddt1o.first/(lddt1o.second ? lddt1o.second : 1);
     Real lddt2 = lddt2o.first/(lddt2o.second ? lddt2o.second : 1);
-    Real lddt4 = lddt4o.first/(lddt4o.second ? lddt4o.second : 1);            
+    Real lddt4 = lddt4o.first/(lddt4o.second ? lddt4o.second : 1);
     lddt = (lddt05+lddt1+lddt2+lddt4)/4.0;
     for (ResidueViewIter rit=v.ResiduesBegin();rit!=v.ResiduesEnd();++rit){
       ResidueView ritv = *rit;
       if (ritv.HasProp("locallddt0.5")) {
         Real lddt_local = (ritv.GetFloatProp("locallddt0.5")+ritv.GetFloatProp("locallddt1")+ritv.GetFloatProp("locallddt2")+ritv.GetFloatProp("locallddt4"))/4.0;
         ritv.SetFloatProp("locallddt",lddt_local);
-      }    
-    }    
+      }
+    }
     return lddt;
 }
 */
diff --git a/modules/seq/alg/src/hmm_pseudo_counts.cc b/modules/seq/alg/src/hmm_pseudo_counts.cc
index 37d2d490b..e1e84b30a 100644
--- a/modules/seq/alg/src/hmm_pseudo_counts.cc
+++ b/modules/seq/alg/src/hmm_pseudo_counts.cc
@@ -1,7 +1,7 @@
 #include <ost/seq/alg/hmm_pseudo_counts.hh>
 
 #include <boost/algorithm/string/predicate.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <boost/filesystem/fstream.hpp>
 #include <boost/iostreams/filter/gzip.hpp>
 #include <boost/iostreams/filtering_stream.hpp>
@@ -15,7 +15,7 @@
 namespace {
 
   // to mimic the HHblits behaviour, R is based on the Gonnet substitution matrix
-  // every entry R[a][b] corresponds to P(a|b) 
+  // every entry R[a][b] corresponds to P(a|b)
   const Real R[20][20] = {
     {0.133435, 0.0861429, 0.0716694, 0.0767892, 0.0451931, 0.0861612, 0.0638644, 0.0638589, 0.0700223, 0.0582424, 0.065352, 0.0716654, 0.0822722, 0.0733284, 0.0668668, 0.0989164, 0.0881558, 0.0785747, 0.0335151, 0.0462615},
     {0.0212019, 0.266857, 0.00903972, 0.009469, 0.0157131, 0.01193, 0.0140111, 0.0146727, 0.00991927, 0.013372, 0.0153475, 0.0124885, 0.00924679, 0.0108782, 0.0113849, 0.0193327, 0.0168459, 0.018897, 0.0149936, 0.0168408},
@@ -143,7 +143,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
     throw Error("Could not open " + filename);
   }
   // add unzip if necessary
-  if(boost::iequals(".gz", boost::filesystem::extension(filename))) {
+  if(boost::iequals(".gz", boost::filesystem::path(filename).extension().string())) {
     in.push(boost::iostreams::gzip_decompressor());
   }
   in.push(stream);
@@ -165,7 +165,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
       throw Error("Require to read SIZE and LENG before first ContextProfile");
     }
 
-    if(sline.length()>4 && 
+    if(sline.length()>4 &&
         sline.substr(0, 4) == ost::StringRef("SIZE", 4)) {
       chunks = sline.split();
       if(chunks.size() != 2) {
@@ -178,7 +178,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
       size = s.second;
     }
 
-    if(sline.length()>4 && 
+    if(sline.length()>4 &&
         sline.substr(0, 4) == ost::StringRef("LENG", 4)) {
       chunks = sline.split();
       if(chunks.size() != 2) {
@@ -220,7 +220,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
       continue;
     }
 
-    if(sline.length()>4 && 
+    if(sline.length()>4 &&
         sline.substr(0, 4) == ost::StringRef("BIAS", 4)) {
       chunks = sline.split();
       if(chunks.size() != 2) {
@@ -234,7 +234,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
       continue;
     }
 
-    if(sline.length()>4 && 
+    if(sline.length()>4 &&
         sline.substr(0, 4) == ost::StringRef("LENG", 4)) {
       chunks = sline.split();
       if(chunks.size() != 2) {
@@ -248,7 +248,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
       continue;
     }
 
-    if(sline.length()>4 && 
+    if(sline.length()>4 &&
         sline.substr(0, 4) == ost::StringRef("ALPH", 4)) {
 
       chunks = sline.split();
@@ -263,7 +263,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
       continue;
     }
 
-    if(sline.length()>7 && 
+    if(sline.length()>7 &&
         sline.substr(0, 7) == ost::StringRef("WEIGHTS", 7)) {
 
       if(cp_alph == -1 || cp_leng == -1) {
@@ -290,7 +290,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
         if(sline.length()>=2 &&
            sline.substr(0, 2) == ost::StringRef("//", 2)) {
           throw Error("Arrived at end of entry before reading all weights");
-        }        
+        }
 
         chunks = sline.split();
 
@@ -298,7 +298,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
           throw Error("Failed to load all WEIGHTS in entry");
         }
 
-        // read the position of the weights. if it can't be parsed to int, 
+        // read the position of the weights. if it can't be parsed to int,
         // something is fishy (e.g. already another key word)
         std::pair<bool, int> p = chunks[0].to_int();
         if(!p.first) {
@@ -320,7 +320,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
       continue;
     }
 
-    if(sline.length()>2 && 
+    if(sline.length()>2 &&
         sline.substr(0, 2) == ost::StringRef("PC", 2)) {
 
       chunks = sline.split();
@@ -356,7 +356,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
         throw Error("Expect ALPH to be 20 for all entries");
       }
       if(cp_olcs.empty()) {
-        throw Error("Observed Entry without WEIGHTS value");          
+        throw Error("Observed Entry without WEIGHTS value");
       }
       if(cp_olcs.size() != 20) {
         throw Error("Expect exactly 20 items after WEIGHTS key word");
@@ -405,7 +405,7 @@ ContextProfileDBPtr ContextProfileDB::FromCRF(const String& filename) {
       cp_weights = std::vector<std::vector<Real> >();
       cp_pc = std::vector<Real>();
       in_crf_state = false;
-    }      
+    }
   }
 
   if(db->size() != static_cast<size_t>(size)) {
@@ -421,7 +421,7 @@ void AddTransitionPseudoCounts(ost::seq::ProfileHandle& profile,
 
   // a priori probabilities estimated with default values of HHblits
   Real pM2D = gapd * 0.0286;
-  Real pM2I = pM2D; 
+  Real pM2I = pM2D;
   Real pM2M = 1 - pM2D - pM2I;
   Real pI2I = 1.0 * gape / (gape - 1 + 1.0 / 0.75);;
   Real pI2M = 1 - pI2I;
@@ -494,18 +494,18 @@ void AddAAPseudoCounts(ost::seq::ProfileHandle& profile,
   int cp_length = db.profile_length();
   if(cp_length % 2 != 1) {
     throw Error("Length of profiles in db must be an odd number");
-  } 
+  }
   // extension from center to both directions
   int cp_ext = (cp_length - 1) / 2;
 
-  std::vector<std::vector<Real> > 
+  std::vector<std::vector<Real> >
   count_profile(profile.size(), std::vector<Real>(20, 0.0));
-  std::vector<std::vector<Real> > 
+  std::vector<std::vector<Real> >
   context_profile(profile.size(), std::vector<Real>(20, 0.0));
 
   // fill counts profile
   for(size_t col_idx = 0; col_idx < profile.size(); ++col_idx) {
-    HMMDataPtr hmm_data = profile[col_idx].GetHMMData(); 
+    HMMDataPtr hmm_data = profile[col_idx].GetHMMData();
     Real neff = hmm_data->GetNeff();
     Real* col_freq = profile[col_idx].freqs_begin();
     std::vector<Real>& counts = count_profile[col_idx];
@@ -517,9 +517,9 @@ void AddAAPseudoCounts(ost::seq::ProfileHandle& profile,
   // process columns
   for(size_t col_idx = 0; col_idx < count_profile.size(); ++col_idx) {
     int min = std::max(0, static_cast<int>(col_idx) - cp_ext);
-    int max = std::min(col_idx + cp_ext, count_profile.size() - 1); 
-    int cp_min = static_cast<int>(col_idx) < cp_ext ? 
-                 std::abs(static_cast<int>(col_idx) - cp_ext) : 0; 
+    int max = std::min(col_idx + cp_ext, count_profile.size() - 1);
+    int cp_min = static_cast<int>(col_idx) < cp_ext ?
+                 std::abs(static_cast<int>(col_idx) - cp_ext) : 0;
     Real max_score = -std::numeric_limits<Real>::max();
     // estimate score for each context profile in db
     for(size_t cp_idx = 0; cp_idx < db.size(); ++cp_idx) {
@@ -586,11 +586,11 @@ void AddNullPseudoCounts(ost::seq::ProfileHandle& profile) {
   Real null_freq[20];
   for(int i = 0; i < 20; ++i) {
     null_freq[i] = current_null_freq[i] * mixing_factor;
-  } 
+  }
   for(size_t i = 0; i < profile.size(); ++i) {
     const Real* freq = profile[i].freqs_begin();
     for(int j = 0; j < 20; ++j) {
-      null_freq[j] += freq[j]; 
+      null_freq[j] += freq[j];
     }
   }
   // normalize
diff --git a/scripts/dng.in b/scripts/dng.in
index 93e7d862e..f11b3392a 100755
--- a/scripts/dng.in
+++ b/scripts/dng.in
@@ -19,13 +19,29 @@
 #------------------------------------------------------------------------------
 # Startup script for a protein-centric user interface
 # Author: Marco Biasini
+if [ -h "$0" ]; then
+  TARGET="$0"
+  while [ -h "$TARGET" ]; do
+    DIR="$(cd -P "$(dirname "$TARGET")" && pwd)"
+    TARGET="$(readlink "$TARGET")"
+    [[ $TARGET != /* ]] && TARGET="$DIR/$TARGET"
+  done
+  SCRIPT_PATH="$DIR/$(basename "$TARGET")"
+else
+  SCRIPT_PATH="$0"
+fi
 
-if [ -h "$0" ] ; then
-  SCRIPT_NAME=`readlink "$0"`
+# Get the absolute path of the script
+if command -v realpath >/dev/null 2>&1; then
+  SCRIPT_PATH="$(realpath "$SCRIPT_PATH")"
+elif command -v readlink >/dev/null 2>&1; then
+  SCRIPT_PATH="$(readlink -f "$SCRIPT_PATH")"
 else
-  SCRIPT_NAME="$0"
+  # Fallback for systems without realpath or readlink
+  SCRIPT_PATH="$(cd "$(dirname "$SCRIPT_PATH")" && pwd -P)/$(basename "$SCRIPT_PATH")"
 fi
-BIN_DIR=`dirname "$SCRIPT_NAME"`
+
+BIN_DIR=$(dirname "$SCRIPT_PATH")
 source "$BIN_DIR/../@LIBEXEC_PATH@/ost_config"
 
 
diff --git a/scripts/ost.in b/scripts/ost.in
index b85886a39..fc48014e0 100755
--- a/scripts/ost.in
+++ b/scripts/ost.in
@@ -22,12 +22,29 @@
 # convenience wrapper for non-gui openstructure interface 'ost'
 #
 # Self detect important directories
-if [ -h "$0" ] ; then
-  SCRIPT_NAME=`readlink "$0"`
+if [ -h "$0" ]; then
+  TARGET="$0"
+  while [ -h "$TARGET" ]; do
+    DIR="$(cd -P "$(dirname "$TARGET")" && pwd)"
+    TARGET="$(readlink "$TARGET")"
+    [[ $TARGET != /* ]] && TARGET="$DIR/$TARGET"
+  done
+  SCRIPT_PATH="$DIR/$(basename "$TARGET")"
 else
-  SCRIPT_NAME="$0"
+  SCRIPT_PATH="$0"
 fi
-BIN_DIR=`dirname "$SCRIPT_NAME"`
+
+# Get the absolute path of the script
+if command -v realpath >/dev/null 2>&1; then
+  SCRIPT_PATH="$(realpath "$SCRIPT_PATH")"
+elif command -v readlink >/dev/null 2>&1; then
+  SCRIPT_PATH="$(readlink -f "$SCRIPT_PATH")"
+else
+  # Fallback for systems without realpath or readlink
+  SCRIPT_PATH="$(cd "$(dirname "$SCRIPT_PATH")" && pwd -P)/$(basename "$SCRIPT_PATH")"
+fi
+
+BIN_DIR=$(dirname "$SCRIPT_PATH")
 OST_EXEC_DIR=$(cd $BIN_DIR/../@LIBEXEC_PATH@ && pwd)
 export OST_EXEC_DIR
 
diff --git a/tools/molck/main.cc b/tools/molck/main.cc
index efed0e21f..208069725 100644
--- a/tools/molck/main.cc
+++ b/tools/molck/main.cc
@@ -1,7 +1,7 @@
 #include <unistd.h>
 #include <boost/program_options.hpp>
 #include <boost/filesystem/path.hpp>
-#include <boost/filesystem/convenience.hpp>
+#include <boost/filesystem.hpp>
 #include <ost/base.hh>
 #include <ost/boost_filesystem_helper.hh>
 #include <ost/platform.hh>
@@ -27,7 +27,7 @@ const char* USAGE=
 "Usage: molck [options] file1.pdb [file2.pdb [...]]\n"
 "Options\n"
 "  --complib=path       Location of the compound library file. If not provided,\n"
-"                       the following locations are searched in this order:\n" 
+"                       the following locations are searched in this order:\n"
 "                       1. Working directory,\n"
 "                       2. OpenStructure standard library location (if the\n"
 "                          executable is part of a standard OpenStructure\n"
@@ -54,7 +54,7 @@ void usage()
 {
   LOG_INFO(USAGE);
   exit(0);
-}	
+}
 
 EntityHandle load_x(const String& file, const IOProfile& profile)
 {
@@ -90,41 +90,41 @@ EntityHandle load_x(const String& file, const IOProfile& profile)
 ost::conop::CompoundLibPtr load_compound_lib(const String& custom_path)
 {
   if (custom_path!="") {
-    if (fs::exists(custom_path)) {  
+    if (fs::exists(custom_path)) {
       return ost::conop::CompoundLib::Load(custom_path);
     } else {
       LOG_INFO("Could not find compounds.chemlib at the provided location, trying other options");
     }
-  } 
+  }
   if (fs::exists("compounds.chemlib")) {
     return ost::conop::CompoundLib::Load("compounds.chemlib");
   }
-  char result[ 1024 ]; 
+  char result[ 1024 ];
   ost::conop::CompoundLibPtr lib;
-  String exe_path; 
+  String exe_path;
   #if defined(__APPLE__)
   uint32_t size=1023;
   if (!_NSGetExecutablePath(result, &size)) {
-    exe_path=String(result); 
+    exe_path=String(result);
   }
-  #else 
+  #else
   ssize_t count = readlink( "/proc/self/exe", result, 1024 );
   exe_path = std::string( result, (count > 0) ? count : 0 );
   #endif
-  if (exe_path.empty()) { 
+  if (exe_path.empty()) {
     LOG_INFO("Could not determine the path of the molck executable. Will only "
              "look for compounds.chemlib in the current working directory");
   } else {
     fs::path path_and_exe(exe_path);
-    fs::path path_only=path_and_exe.branch_path();
-    fs::path share_path = path_only.branch_path();
+    fs::path path_only=path_and_exe.parent_path();
+    fs::path share_path = path_only.parent_path();
     share_path = share_path / "share" / "openstructure" / "compounds.chemlib";
 
     String share_path_string=BFPathToString(share_path);
-      
+
     if (fs::exists(share_path_string)) {
       return ost::conop::CompoundLib::Load(share_path_string);
-    }  
+    }
   }
   if (!lib) {
     LOG_ERROR("Could not load compounds.chemlib");
@@ -172,7 +172,7 @@ int main(int argc, char *argv[])
   p.add("files", -1);
   std::vector<String> files;
   po::variables_map vm;
-  
+
   try {
     po::store(po::command_line_parser(argc, argv).
                 options(desc).positional(p).run(),
@@ -182,7 +182,7 @@ int main(int argc, char *argv[])
     usage();
     exit(-1);
   }
-  po::notify(vm); 
+  po::notify(vm);
   if (vm.count("files")) {
     files = vm["files"].as<std::vector<String> >();
   } else {
@@ -191,7 +191,7 @@ int main(int argc, char *argv[])
   }
   if (vm.count("complib")) {
     custom_path = vm["complib"].as<String>();
-  }    
+  }
   if (vm.count("stdout")) {
     write_to_stdout = true;
   } else {
@@ -204,7 +204,7 @@ int main(int argc, char *argv[])
   if (vm.count("fix-ele")) {
     settings.assign_elem = true;
   }
-  
+
   std::vector<StringRef> rms=StringRef(rm.c_str(), rm.size()).split(',');
   for (size_t i=0; i<rms.size(); ++i) {
     if (rms[i] == StringRef("unk", 3)) {
@@ -230,20 +230,20 @@ int main(int argc, char *argv[])
   } else if (color == "on" || color == "1" || color == "yes") {
     settings.colored = true;
   } else if (color == "off" || color == "0" || color == "no") {
-    settings.colored = false;	
+    settings.colored = false;
   } else {
     usage();
     exit(-1);
   }
-  ost::conop::CompoundLibPtr lib=load_compound_lib(custom_path);  
+  ost::conop::CompoundLibPtr lib=load_compound_lib(custom_path);
   for (unsigned int i = 0; i < files.size(); ++i) {
     EntityHandle ent=load_x(files[i], prof);
     if (!ent.IsValid()) {
       continue;
     }
-    
+
     ost::mol::alg::Molck(ent, lib, settings);
- 
+
     if (write_to_stdout) {
       PDBWriter writer(std::cout, prof);
       writer.Write(ent);
@@ -252,11 +252,11 @@ int main(int argc, char *argv[])
       fs::path input_file_path(files[i]);
       fs::path input_filename = BFPathStem(input_file_path);
       String input_filename_string=BFPathToString(input_filename);
-      size_t replstart =output_blueprint_string.find('%');	
+      size_t replstart =output_blueprint_string.find('%');
       String output_blueprint_string_copy = output_blueprint_string;
       if (replstart != String::npos) {
-        output_blueprint_string_copy.replace(replstart,1,input_filename_string); 
-      } 
+        output_blueprint_string_copy.replace(replstart,1,input_filename_string);
+      }
       try {
         fs::path out_path(output_blueprint_string_copy);
         if (out_path.has_parent_path() && !exists(out_path.parent_path())) {
@@ -265,7 +265,7 @@ int main(int argc, char *argv[])
         }
       } catch (std::exception& e) {
 
-        size_t perden = String(e.what()).find("Permission denied");	
+        size_t perden = String(e.what()).find("Permission denied");
 
         if (perden != String::npos) {
           LOG_ERROR("Cannot write into output directory: " + output_blueprint_string_copy);
@@ -280,6 +280,6 @@ int main(int argc, char *argv[])
       writer.Write(ent);
     }
   }
- 
+
   return 0;
 }
