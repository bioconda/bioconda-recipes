From 007d7bce6d09791baf33b78a5d862131f15c8ca6 Mon Sep 17 00:00:00 2001
From: 4less <joachim.fritscher@gmail.com>
Date: Tue, 29 Jul 2025 20:31:47 +0200
Subject: [PATCH] Change Utils path due to potential conflict on MacOS

---
 src/Alignment/AlignmentUtils.h            |   2 +-
 src/CMakeLists.txt                        |  18 +-
 src/Hash/Seedmap.h                        |   2 +-
 src/Hash/SeedmapFlex.h                    |   2 +-
 src/Options.h                             |   2 +-
 src/Profiling/TreeFilter.h                |   2 +-
 src/RunProtal.h                           |   2 +-
 src/SequenceUtils/GenomeLoader.h          |   2 +-
 src/Taxonomy/Taxonomy.cpp                 |   2 +-
 src/Utilities/Benchmark.h                 | 113 ++++++
 src/Utilities/BinaryClassifierEvaluator.h |  87 +++++
 src/Utilities/LineSplitter.h              |  77 ++++
 src/Utilities/Matrix.h                    | 182 +++++++++
 src/Utilities/ProgressBar.h               | 127 +++++++
 src/Utilities/Utilities.h                 | 428 ++++++++++++++++++++++
 src/Utilities/xxhash64.h                  | 202 ++++++++++
 16 files changed, 1233 insertions(+), 17 deletions(-)
 create mode 100755 src/Utilities/Benchmark.h
 create mode 100755 src/Utilities/BinaryClassifierEvaluator.h
 create mode 100755 src/Utilities/LineSplitter.h
 create mode 100644 src/Utilities/Matrix.h
 create mode 100755 src/Utilities/ProgressBar.h
 create mode 100755 src/Utilities/Utilities.h
 create mode 100755 src/Utilities/xxhash64.h

diff --git a/src/Alignment/AlignmentUtils.h b/src/Alignment/AlignmentUtils.h
index 2deaedb..3cb51af 100755
--- a/src/Alignment/AlignmentUtils.h
+++ b/src/Alignment/AlignmentUtils.h
@@ -8,7 +8,7 @@
 #include <iostream>
 #include "assert.h"
 #include "SamHandler.h"
-#include "Utils.h"
+#include "Utilities.h"
 #include "Constants.h"
 #include <tuple>
 
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 1e8f190..5c1b0ee 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -39,12 +39,12 @@ add_library(protal_lib
         Options.h
         Build.h
         Classify.h
-        Utils/Benchmark.h
-        Utils/Utils.h
-        Utils/ProgressBar.h
-        Utils/xxhash64.h
-        Utils/BinaryClassifierEvaluator.h
-        Utils/LineSplitter.h
+        Utilities/Benchmark.h
+        Utilities/Utilities.h
+        Utilities/ProgressBar.h
+        Utilities/xxhash64.h
+        Utilities/BinaryClassifierEvaluator.h
+        Utilities/LineSplitter.h
         SequenceUtils/SeqReader.h
         SequenceUtils/KmerIterator.h
         SequenceUtils/KmerUtils.h
@@ -96,7 +96,7 @@ add_library(protal_lib
         SequenceUtils/VariantHandler.h
         Strains/Distances.h
         IO/TaxonStatisticsOutput.h
-        Utils/Matrix.h
+        Utilities/Matrix.h
         Strains/MSA.h
         Profiling/TreeFilter.h
         Alignment/WFA2Wrapper2.h
@@ -110,7 +110,7 @@ target_include_directories(protal_lib
         Core
         VarkitInterface
         Alignment
-        Utils
+        Utilities
         Profiling
         SequenceUtils
         Taxonomy
@@ -127,7 +127,7 @@ target_link_directories(protal_lib
         ../Core
         ../VarkitInterface
         ../Alignment
-        ../Utils
+        ../Utilities
         ../Profiling
         # ../Profiler
         ../SequenceUtils
diff --git a/src/Hash/Seedmap.h b/src/Hash/Seedmap.h
index 284b48f..9b1e96f 100644
--- a/src/Hash/Seedmap.h
+++ b/src/Hash/Seedmap.h
@@ -11,7 +11,7 @@
 #include <iostream>
 #include <tuple>
 #include <fstream>
-#include "Utils.h"
+#include "Utilities.h"
 #include <bit>
 #include <bits/stdc++.h>
 
diff --git a/src/Hash/SeedmapFlex.h b/src/Hash/SeedmapFlex.h
index f814f04..f2cf7ca 100644
--- a/src/Hash/SeedmapFlex.h
+++ b/src/Hash/SeedmapFlex.h
@@ -12,7 +12,7 @@
 #include <iostream>
 #include <tuple>
 #include <fstream>
-#include "Utils.h"
+#include "Utilities.h"
 
 namespace protal {
     template<uint64_t taxid_bits, uint64_t geneid_bits, uint64_t genepos_bits>
diff --git a/src/Options.h b/src/Options.h
index 921dde1..9f4eab7 100755
--- a/src/Options.h
+++ b/src/Options.h
@@ -10,7 +10,7 @@
 #include "LineSplitter.h"
 #include <fstream>
 #include <regex>
-#include "Utils.h"
+#include "Utilities.h"
 
 
 namespace protal {
diff --git a/src/Profiling/TreeFilter.h b/src/Profiling/TreeFilter.h
index 4259e65..40e0185 100644
--- a/src/Profiling/TreeFilter.h
+++ b/src/Profiling/TreeFilter.h
@@ -12,7 +12,7 @@
 #include <iostream>
 #include <fstream>
 #include <unordered_map>
-#include "Utils.h"
+#include "Utilities.h"
 
 namespace protal {
     using ClosestNeighborMatrix = std::vector<std::vector<uint32_t>>;
diff --git a/src/RunProtal.h b/src/RunProtal.h
index c44761e..9760695 100755
--- a/src/RunProtal.h
+++ b/src/RunProtal.h
@@ -2,7 +2,7 @@
 
 #include "Profiler.h"
 #include <iostream>
-#include "Utils/Benchmark.h"
+#include "Benchmark.h"
 #include "Options.h"
 #include "Build.h"
 #include "Alignment/WFA2Wrapper.h"
diff --git a/src/SequenceUtils/GenomeLoader.h b/src/SequenceUtils/GenomeLoader.h
index a8ad97d..3fd43f1 100755
--- a/src/SequenceUtils/GenomeLoader.h
+++ b/src/SequenceUtils/GenomeLoader.h
@@ -14,7 +14,7 @@
 
 #include <sparse_set.h>
 
-#include "Utils.h"
+#include "Utilities.h"
 #include <sysexits.h>
 
 #include "Benchmark.h"
diff --git a/src/Taxonomy/Taxonomy.cpp b/src/Taxonomy/Taxonomy.cpp
index ad6d734..dd89517 100755
--- a/src/Taxonomy/Taxonomy.cpp
+++ b/src/Taxonomy/Taxonomy.cpp
@@ -3,7 +3,7 @@
 ////
 //
 #include "Taxonomy.h"
-#include "Utils.h"
+#include "Utilities.h"
 #include <iostream>
 #include <fstream>
 #include <unordered_set>
diff --git a/src/Utilities/Benchmark.h b/src/Utilities/Benchmark.h
new file mode 100755
index 0000000..31b6f5b
--- /dev/null
+++ b/src/Utilities/Benchmark.h
@@ -0,0 +1,113 @@
+//
+// Created by joachim on 05/06/2020.
+//
+
+#pragma once
+
+#include <string>
+#include <chrono>
+#include <iostream>
+
+using namespace std::chrono;
+using namespace std;
+
+namespace protal {
+    enum Time {
+        days, hours, minutes, seconds, milliseconds, microseconds
+    };
+
+    class Benchmark {
+        string name;
+        long time_sum = 0;
+        size_t samplings = 0;
+        size_t threads_sampled = 0;
+        time_point<high_resolution_clock> start_time;
+
+    public:
+        Benchmark(string name, size_t threads_sampled=0) : name(name), threads_sampled(threads_sampled) {
+            //Start();
+        }
+
+        std::string GetName() const {
+            return name;
+        }
+
+        void AddObservation() {
+            samplings++;
+        }
+
+        void Start(bool new_sample=true) {
+            samplings += new_sample;
+            start_time = high_resolution_clock::now();
+        }
+
+        void Stop() {
+//            if (time_sum != 0) return;
+            auto stop_time = high_resolution_clock::now();
+            auto duration = duration_cast<std::chrono::microseconds>(stop_time - start_time);
+//            std::cout << "Duration count : " << duration.count() << std::endl;
+            time_sum += duration.count();
+        }
+
+        uint64_t GetDuration(Time format) {
+//            if (time_sum == 0) {
+//                Stop();
+//            }
+
+            switch (format) {
+                case Time::microseconds:
+                    return time_sum;
+                case Time::milliseconds:
+                    return time_sum / 1'000;
+                case Time::seconds:
+                    return time_sum / 1'000'000;
+                case Time::minutes:
+                    return time_sum / 60'000'000;
+                case Time::hours:
+                    return time_sum / 3'600'000'000;
+                case Time::days:
+                    return time_sum / 86'400'000'000;
+            }
+            return 0L;
+        }
+
+        void Join(Benchmark const& other, bool add_thread=true) {
+            if (add_thread && other.samplings > 0) threads_sampled++;
+            time_sum += other.time_sum;
+        }
+
+        void PrintResults() {
+            if (time_sum == 0) {
+                Stop();
+            }
+
+            if (samplings > 0) {
+                threads_sampled++;
+            }
+
+            if (threads_sampled > 1) {
+                time_sum /= static_cast<double>(threads_sampled);
+            }
+
+            auto time_sum_local = time_sum;
+
+            uint hours = time_sum_local / 3600000000;
+            time_sum_local -= hours * 3600000000;
+            uint mins = time_sum_local / 60000000;
+            time_sum_local -= mins * 60000000;
+            uint secs = time_sum_local / 1000000;
+            time_sum_local -= secs * 1000000;
+            uint msecs = time_sum_local / 1000;
+
+            std::cout << name << " took ";
+            if (hours) std::cout << hours << "h ";
+            if (mins) std::cout << mins << "m ";
+            if (secs) std::cout << secs << "s ";
+            if (msecs) std::cout << msecs << "ms";
+            if (!hours && !mins && !secs && !msecs) std::cout << " less than 0ms";
+            if (samplings > 1) std::cout << " (" << std::to_string(samplings) << ")";
+            if (threads_sampled > 1) std::cout << " mean over " << threads_sampled << " threads";
+            std::cout << std::endl;
+        }
+    };
+}
diff --git a/src/Utilities/BinaryClassifierEvaluator.h b/src/Utilities/BinaryClassifierEvaluator.h
new file mode 100755
index 0000000..c615819
--- /dev/null
+++ b/src/Utilities/BinaryClassifierEvaluator.h
@@ -0,0 +1,87 @@
+//
+// Created by fritsche on 03/02/2022.
+//
+
+#pragma once
+
+#include <cstddef>
+#include <ostream>
+#include <iostream>
+
+struct BinaryClassifierEvaluator {
+    std::string name {};
+
+    size_t tp = 0;
+    size_t tn = 0;
+    size_t fp = 0;
+    size_t fn = 0;
+
+    BinaryClassifierEvaluator() = default;
+    explicit BinaryClassifierEvaluator(std::string name) :
+        name(name) {};
+
+    void SetName(std::string name) {
+        this->name = name;
+    }
+
+    double Sensitivity() const {
+        if (tp + fn == 0) return -1;
+        return (double) tp/static_cast<double>(tp + fn);
+    }
+
+    double Specificity() const {
+        if (tn + fp == 0) return -1;
+        return (double) tn/static_cast<double>(tn + fp);
+    }
+
+    double Precision() const {
+        if (tp + fp == 0) return -1;
+        return (double) tp/static_cast<double>(tp + fp);
+    }
+
+    double Accuracy() const {
+        if (tp + fp + tn + fn == 0) return -1;
+        return (double) (tp + tn)/static_cast<double>(tp + tn + fp + fn);
+    }
+
+    double F1() const {
+        if (tp + fp + tn + fn == 0) return -1;
+        return (double) 2*tp/static_cast<double>(2 * tp + fp + fn);
+    }
+
+
+    void WriteStats(std::ostream &os=std::cout) const {
+        os << "Evaluate binary classifier: " << std::endl;
+        os << "tp: " << tp << " fp: " << fp << " tn: " << tn << " fn: " << fn << std::endl;
+        os << "Sensitivity:\t\t" << Sensitivity() << std::endl;
+        os << "Specificity:\t\t" << Specificity() << std::endl;
+        os << "Precision:  \t\t" << Precision() << std::endl;
+        os << "Accuracy:   \t\t" << Accuracy() << std::endl;
+        os << "F1:         \t\t" << F1() << std::endl;
+    }
+
+    static void WriteRowHeader(std::ostream &os=std::cout, std::string row_prefix="") {
+        os << row_prefix << "Name\tTP\tFP\tTN\tFN\tSensitivity\tSpecificity\tPrecision\tAccuracy\tF1" << std::endl;
+    }
+
+    void Join(BinaryClassifierEvaluator const& other) {
+        this->tp += other.tp;
+        this->tn += other.tn;
+        this->fp += other.fp;
+        this->fn += other.fn;
+    }
+
+    void WriteRowStats(std::ostream &os=std::cout, std::string row_prefix="") const {
+        os << row_prefix;
+        os << name << '\t';
+        os << tp << '\t';
+        os << fp << '\t';
+        os << tn << '\t';
+        os << fn << '\t';
+        os << Sensitivity() << '\t';
+        os << Specificity() << '\t';
+        os << Precision() << '\t';
+        os << Accuracy() << '\t';
+        os << F1() << std::endl;
+    }
+};
\ No newline at end of file
diff --git a/src/Utilities/LineSplitter.h b/src/Utilities/LineSplitter.h
new file mode 100755
index 0000000..fd2a9e0
--- /dev/null
+++ b/src/Utilities/LineSplitter.h
@@ -0,0 +1,77 @@
+//
+// Created by fritsche on 18/10/22.
+//
+
+#pragma once
+
+#include <vector>
+#include <string>
+#include <stdexcept>
+
+namespace protal {
+    class LineSplitter {
+        std::vector<std::string> m_tokens;
+        std::string m_delimiter = "\t";
+
+    public:
+        static bool IsDelim(std::string &str, std::string& delim, int pos) {
+            for (int i = 0; i < delim.length() && pos+i < str.length(); i++) {
+                if (str[pos+i] != delim[i]) return false;
+            }
+            return true;
+        }
+
+        static void Split(std::string& line, std::string& delimiter, std::vector<std::string> &tokens) {
+            tokens.clear();
+            if (line.empty()) return;
+
+            size_t delim_size = delimiter.length();
+
+            size_t start = 0;
+
+            for (int i = 0; i <= line.length() - delim_size; i++) {
+                if (IsDelim(line, delimiter, i)) {
+                    tokens.emplace_back(std::string(line.c_str() + start, i  - start));
+                    i += delim_size;
+                    start = i;
+                }
+            }
+            tokens.emplace_back(std::string(line.c_str() + start, line.length() - start));
+        }
+
+        std::vector<std::string>& Tokens() {
+            return m_tokens;
+        }
+
+        static void Split(std::string& line, std::string&& delimiter, std::vector<std::string> &tokens) {
+            tokens.clear();
+
+            size_t delim_size = delimiter.length();
+
+            size_t start = 0;
+
+            if (line.length() < delimiter.length()) return;
+
+            for (int i = 0; i <= line.length() - delim_size; i++) {
+                if (IsDelim(line, delimiter, i)) {
+                    tokens.emplace_back(std::string(line.c_str() + start, i  - start));
+                    i += delim_size;
+                    start = i;
+                }
+            }
+            tokens.emplace_back(std::string(line.c_str() + start, line.length() - start));
+        }
+
+
+        void Split(std::string line) {
+            Split(line, m_delimiter, m_tokens);
+        }
+
+        std::string operator[] (size_t index) {
+            if (index >= m_tokens.size()) {
+                throw std::out_of_range("Line splitter: trying to access index " + std::to_string(index) + " of split line. Number of tokens is " + std::to_string(m_tokens.size()));
+            }
+            return m_tokens[index];
+        }
+    };
+}
\ No newline at end of file
diff --git a/src/Utilities/Matrix.h b/src/Utilities/Matrix.h
new file mode 100644
index 0000000..de29167
--- /dev/null
+++ b/src/Utilities/Matrix.h
@@ -0,0 +1,182 @@
+//
+// Created by fritsche on 27/07/23.
+//
+
+#ifndef PROTAL_MATRIX_H
+#define PROTAL_MATRIX_H
+
+#include <cstdio>
+#include <vector>
+#include <robin_map.h>
+#include <iostream>
+#include <iomanip>
+#include <unordered_map>
+#include <math.h>
+
+using Key = std::string;
+using Value = size_t;
+
+//template<typename K, typename V>
+//using Map = std::unordered_map<K, V>;
+
+template<typename K, typename V>
+using Map = tsl::robin_map<K, V>;
+
+template<typename T>
+class Matrix {
+    template<typename K, typename V>
+    using Map = std::unordered_map<K, V>;
+    using NamesDict = Map<std::string, size_t>;
+    using NamesList = std::vector<std::string>;
+    using RowType = std::vector<T>;
+    using MatrixType = std::vector<RowType>;
+
+    NamesDict m_row_names_to_index;
+    NamesDict m_col_names_to_index;
+    NamesList m_row_names;
+    NamesList m_col_names;
+    MatrixType m_matrix;
+
+    bool any_set = false;
+
+public:
+    Matrix(size_t row_size, size_t col_size, T default_value) :
+            m_matrix(std::vector<RowType>(row_size, RowType(col_size, default_value))) {};
+    Matrix() {};
+
+    void SetNames(NamesList& from, NamesList& to_list, NamesDict& to_dict) {
+        to_list = from;
+        to_dict.clear();
+        for (auto i = 0; i < to_list.size(); i++) {
+            to_dict.insert({to_list[i], i});
+        }
+    }
+
+    void AddName(std::string new_name) {
+        m_row_names_to_index.insert( { new_name, m_row_names.size() });
+        m_col_names_to_index.insert( { new_name, m_col_names.size() });
+        m_row_names.emplace_back(new_name);
+        m_col_names.emplace_back(new_name);
+
+        m_matrix.resize(m_matrix.size() + 1, RowType(m_matrix.size(), NAN));
+        std::for_each(m_matrix.begin(), m_matrix.end(), [](RowType& row) {
+            row.resize(row.size() + 1, NAN);
+        });
+    }
+
+    void SetColNames(NamesList& col_names) {
+        SetNames(col_names, m_col_names, m_col_names_to_index);
+    }
+    void SetRowNames(NamesList& row_names) {
+        SetNames(row_names, m_row_names, m_row_names_to_index);
+    }
+    void SetColNames(NamesList&& col_names) {
+        SetNames(col_names, m_col_names, m_col_names_to_index);
+    }
+    void SetRowNames(NamesList&& row_names) {
+        SetNames(row_names, m_row_names, m_row_names_to_index);
+    }
+
+    std::string GetName(NamesList const& names, size_t index) const {
+        if (names.empty()) {
+            return std::to_string(index);
+        } else {
+            return names[index];
+        }
+    }
+
+    bool HasName(std::string& name) {
+        return m_row_names_to_index.count(name) > 0;
+    }
+
+    bool HasIdx(uint32_t index) {
+        return index < m_row_names.size();
+    }
+
+    bool AnySet() const {
+        return any_set;
+    }
+
+    void SetValue(size_t row_idx, size_t col_idx, T value) {
+        if (row_idx >= m_matrix.size()) {
+            std::cerr << "row_idx out of bounds." << row_idx << std::endl;
+            exit(9);
+        }
+        if (m_matrix.empty() || col_idx >= m_matrix.front().size()) {
+            std::cerr << "col_idx out of bounds." << col_idx << std::endl;
+            exit(9);
+        }
+        m_matrix[row_idx][col_idx] = value;
+        any_set = true;
+    }
+
+    void SetValue(std::string& row_name, std::string& col_name, T value) {
+        auto row_idx_find = m_row_names_to_index.find(row_name);
+        auto col_idx_find = m_col_names_to_index.find(col_name);
+
+        if (row_idx_find == m_row_names_to_index.end()) {
+            std::cerr << "row has no name " << row_name << std::endl;
+            exit(9);
+        }
+        if (col_idx_find == m_col_names_to_index.end()) {
+            std::cerr << "col has no name " << col_name << std::endl;
+            exit(9);
+        }
+        SetValue(row_idx_find->second, col_idx_find->second, value);
+    }
+
+    void SetValue(size_t row_idx, size_t col_idx, T value, bool lower_triangle) {
+        if (row_idx >= m_matrix.size()) {
+            std::cerr << "row_idx out of bounds." << row_idx << std::endl;
+            exit(9);
+        }
+        if (m_matrix.empty() || col_idx >= m_matrix.front().size()) {
+            std::cerr << "col_idx out of bounds." << col_idx << std::endl;
+            exit(9);
+        }
+
+        if (lower_triangle) {
+            if (row_idx < col_idx) std::swap(row_idx, col_idx);
+            m_matrix[row_idx][col_idx] = value;
+        } else {
+            if (row_idx > col_idx) std::swap(row_idx, col_idx);
+            m_matrix[row_idx][col_idx] = value;
+        }
+    }
+
+    void SetValue(std::string& row_name, std::string& col_name, T value, bool lower_triangle) {
+        auto row_idx_find = m_row_names_to_index.find(row_name);
+        auto col_idx_find = m_col_names_to_index.find(col_name);
+
+        if (row_idx_find == m_row_names_to_index.end()) {
+            std::cerr << "row has no name " << row_name << std::endl;
+            exit(9);
+        }
+        if (col_idx_find == m_col_names_to_index.end()) {
+            std::cerr << "col has no name " << col_name << std::endl;
+            exit(9);
+        }
+        SetValue(row_idx_find->second, col_idx_find->second, value, lower_triangle);
+        any_set = true;
+    }
+
+
+    void PrintMatrix(std::ostream& os=std::cout, std::string const& sep="\t", size_t precision=4) const {
+        os << std::fixed;
+        for (auto col_idx = 0; col_idx < m_col_names.size(); col_idx++) {
+            os << sep << GetName(m_col_names, col_idx);
+        }
+        os << std::endl;
+        for (auto row_idx = 0; row_idx < m_row_names.size(); row_idx++) {
+            os << GetName(m_row_names, row_idx);
+
+            for (auto col_idx = 0; col_idx < m_col_names.size(); col_idx++) {
+                os << sep << std::setprecision(precision) << m_matrix[row_idx][col_idx];
+            }
+            os << std::endl;
+        }
+    };
+
+};
+
+#endif //PROTAL_MATRIX_H
diff --git a/src/Utilities/ProgressBar.h b/src/Utilities/ProgressBar.h
new file mode 100755
index 0000000..4984cdb
--- /dev/null
+++ b/src/Utilities/ProgressBar.h
@@ -0,0 +1,127 @@
+//
+// Created by fritsche on 11/03/2021.
+//
+
+#pragma once
+
+#include <cstdio>
+#include <iostream>
+#include <chrono>
+#include "Utilities.h"
+
+using namespace std::chrono;
+
+
+class ProgressBar {
+    using TimePoints = std::vector<std::pair<time_point<high_resolution_clock>, size_t>>;
+
+    size_t progress_size_ = 0;
+    size_t progress_pos_ = 0;
+    size_t steps_ = 100;
+    size_t bar_width_ = 70;
+    double progress_ = 0.0;
+    int old_pos = -1;
+
+    std::string bar = "";
+
+    size_t last_length = 0;
+
+    time_point<high_resolution_clock> last_time_point;
+
+    size_t window_size = 10;
+    TimePoints time_points;
+
+    void Print(int pos, double progress, double expected_runtime=0) {
+        bar.clear();
+        bar.reserve(150);
+        bar = "[";
+
+        for (int i = 0; i < bar_width_; ++i) {
+            if (i < pos) bar += "=";
+            else if (i == pos) bar += ">";
+            else bar += " ";
+        }
+        std::string exp = Utils::FormatSeconds(std::max(0, int(expected_runtime)));
+        bar += "] ";
+        bar += std::to_string(int(progress * 100.0));
+        bar += " %  ";
+        bar += exp;
+        bar += " left    \r";
+
+        std::cout << bar;
+
+        std::cout.flush();
+    }
+
+    size_t ExpectedRuntime() {
+        size_t expected_runtime;
+
+        auto& first = time_points[0];
+        auto& last = time_points[time_points.size() - 1];
+
+        auto duration = duration_cast<std::chrono::microseconds>(last.first - first.first);
+
+        auto progress_diff = last.second - first.second;
+
+        double progress_per_s = progress_diff/((duration.count()/1000000.f));
+        auto remaining_progress = progress_size_ - last.second;
+
+        if (progress_per_s == 0) return 0;
+        expected_runtime = (remaining_progress/progress_per_s);
+
+        return expected_runtime;
+    }
+
+
+public:
+    ProgressBar (size_t progress_size) : progress_size_(progress_size) {
+        bar.reserve(150);
+        Reset(progress_size_);
+        time_points.reserve(window_size);
+    };
+
+    ProgressBar() = default;
+
+    size_t Reset(size_t new_progress_size) {
+        progress_size_ = new_progress_size;
+        progress_pos_ = 0;
+        progress_ = 0.0;
+        old_pos = -1;
+
+        time_points.clear();
+        time_points.push_back( { high_resolution_clock::now(), 0 } );
+
+        Print(bar_width_ * progress_, progress_, 0);
+        return new_progress_size;
+    }
+
+    void UpdateAdd(size_t progress_pos) {
+        Update(progress_pos_ + progress_pos);
+    }
+
+    size_t Update(size_t new_progress_pos) {
+
+        time_point<high_resolution_clock> new_time_point = high_resolution_clock::now();
+
+        // shift window
+        if (time_points.size() == window_size)
+            time_points.erase(time_points.begin());
+        time_points.push_back( { high_resolution_clock::now(), new_progress_pos } );
+
+        size_t expected_runtime = ExpectedRuntime();
+
+
+        progress_pos_ = new_progress_pos;
+        last_time_point = new_time_point;
+
+        progress_ = (progress_pos_ < progress_size_) * ((double) progress_pos_ / progress_size_) + (progress_pos_ >= progress_size_);
+
+
+        int pos = bar_width_ * progress_;
+
+        Print(pos, progress_, expected_runtime);
+        old_pos = pos;
+
+        return new_progress_pos;
+    }
+};
\ No newline at end of file
diff --git a/src/Utilities/Utilities.h b/src/Utilities/Utilities.h
new file mode 100755
index 0000000..06fee0f
--- /dev/null
+++ b/src/Utilities/Utilities.h
@@ -0,0 +1,428 @@
+//
+// Created by joachim on 20/07/2020.
+//
+
+#pragma once
+
+#include <vector>
+#include <string>
+#include <iomanip>
+#include <sys/stat.h>
+#include <unordered_map>
+#include <cstring>
+#include <robin/robin_set.h>
+#include <iostream>
+#include <emmintrin.h>
+
+#include <time.h>
+#include <fstream>
+
+namespace Utils {
+    class Histogram {
+        std::vector<uint32_t> frequencies{0, 0};
+
+    public:
+        void Join(Histogram const& other) {
+            if (frequencies.size() < other.frequencies.size()) {
+                frequencies.resize(other.frequencies.size(), 0);
+            }
+            for (auto i = 0; i < other.frequencies.size(); i++) {
+                frequencies[i] += other.frequencies[i];
+            }
+        }
+        void AddObservation(uint32_t observation) {
+            if (observation >= frequencies.size()) {
+                frequencies.resize(observation+1, 0);
+            }
+            frequencies[observation]++;
+        }
+
+        void ToTSV(std::string& path) {
+            std::ofstream out(path, std::ios::out);
+            ToStream(out);
+            out.close();
+        }
+        void ToTSV(std::string&& path) {
+            std::ofstream out(path.c_str(), std::ios::out);
+            ToStream(out);
+            out.close();
+        }
+
+        void ToStream(std::ostream& os) {
+            for (auto i = 0; i < frequencies.size(); i++) {
+                os << i << '\t' << frequencies[i] << '\n';
+            }
+        }
+    };
+
+    static size_t CountLines(std::istream& is) {
+        return std::count_if(std::istreambuf_iterator<char>{is}, {}, [](char c) { return c == '\n'; });
+    }
+
+    static void shift(uint8_t * array, size_t length, size_t by) {
+        for (int i = 0; i < length-1; i++) {
+            array[i] <<= by;
+            array[i] |= array[i + 1] >> (8-by);
+        }
+        array[length-1] <<= by;
+    }
+
+    static size_t nChoosek( size_t n, size_t k )
+    {
+        if (k > n) return 0;
+        if (k * 2 > n) k = n-k;
+        if (k == 0) return 1;
+
+        int result = n;
+        for( size_t i = 2; i <= k; ++i ) {
+            result /= i;
+            result *= (n-i+1);
+        }
+        return result;
+    }
+
+    static std::string Input() {
+        std::string input;
+        std::cout << "Input: ";
+        std::cin >> input;
+        return input;
+    }
+
+    struct pair_hash
+    {
+        template <class T1, class T2>
+        std::size_t operator() (const std::pair<T1, T2> &pair) const {
+            return std::hash<T1>()(pair.first) ^ std::hash<T2>()(pair.second);
+        }
+    };
+
+    template<typename T>
+    static void PrintVector(std::vector<T> vector, std::ostream& os) {
+        if (vector.size() == 0) {
+            os << "[]" << std::endl;
+            return;
+        }
+        os << "[" << vector[0].ToString();
+
+        for (auto i = 1; i < vector.size(); i++) {
+            os << ", " << vector[i].ToString();
+        }
+        os << "]" << std::endl;
+    }
+
+
+    static std::string PrintU8(uint8_t* e, size_t size) {
+        std::string res = "[";
+        for (auto i = 0; i < size; i++) {
+            res += std::to_string(i);
+            if (size < size - 1)
+                res += ", ";
+        }
+        res += "]";
+        return res;
+    }
+
+    static std::string GetSharedPrefix(std::string a, std::string b) {
+        for (int i = 0; i < std::min(a.size(), b.size()); i++)
+            if (a[i] != b[i]) return a.substr(0, i);
+        return "";
+    }
+
+    static bool HasSuffix(std::string s, std::string suffix) {
+        if (suffix.length() > s.length()) return false;
+        for (int i = 0; i < suffix.length(); i++) {
+            auto str_idx = s.length() - 1 - i;
+            auto suffix_idx = suffix.length() - 1 - i;
+            if (s[str_idx] != suffix[suffix_idx]) return false;
+        }
+        return true;
+    }
+
+    static std::string RemoveSuffix(std::string s, std::string suffix) {
+        if (suffix.length() > s.length()) return s;
+        for (int i = 0; i < suffix.length(); i++) {
+            auto str_idx = s.length() - 1 - i;
+            auto suffix_idx = suffix.length() - 1 - i;
+            if (s[str_idx] != suffix[suffix_idx]) return s;
+        }
+        return s.substr(0, s.length() - suffix.length());
+    }
+
+    static std::string GetDirectory(std::string s) {
+        return s.substr(0, s.find_last_of('/'));
+    }
+
+    static std::string GetBasename(std::string s) {
+        return s.substr(s.find_last_of('/')+1, s.length());
+    }
+
+    static std::string PadString(std::string s, size_t pad_to, char pad_with) {
+        if (s.length() > pad_to) return s;
+        return s + std::string(pad_to - s.length(), pad_with);
+    }
+
+    static std::string PrintU8(tsl::robin_set<uint8_t> &s) {
+        std::string res = "[";
+        size_t idx = 0;
+        for (auto e : s) {
+            res += std::to_string((uint32_t) e);
+            if (idx < s.size() - 1)
+                res += ", ";
+            idx++;
+        }
+        res += "]";
+        return res;
+    }
+
+    template <typename Range, typename Value = typename Range::value_type>
+    std::string Join(Range const& elements, const char *const delimiter) {
+        std::ostringstream os;
+        auto b = std::begin(elements), e = std::end(elements);
+
+        if (b != e) {
+            std::copy(b, std::prev(e), std::ostream_iterator<Value>(os, delimiter));
+            b = std::prev(e);
+        }
+        if (b != e) {
+            os << *b;
+        }
+
+        return os.str();
+    }
+
+
+    //            typename std::enable_if<std::is_function<Func>::value>
+    template <typename Range, typename Value = typename Range::value_type, typename Func>
+    std::string Join(Range const& elements, const char *const delimiter, Func func) {
+        std::ostringstream os;
+        auto b = std::begin(elements), e = std::end(elements);
+
+        if (b != e) {
+            std::for_each(b, std::prev(e), [&os, &func, &delimiter](Value const& value) {
+                os << func(value) << delimiter;
+            });
+            b = std::prev(e);
+        }
+        if (b != e) {
+            os << func(*b);
+        }
+
+        return os.str();
+    }
+
+    static std::vector<std::string> split(const std::string& s, std::string delimiter)
+    {
+        std::vector<std::string> tokens;
+        std::string token;
+        
+        std::string line = s;
+        int lastpos = 0;
+        int pos = 0;
+        
+        while ((pos = line.find(delimiter, lastpos)) != std::string::npos) {
+            token = line.substr(lastpos, pos-lastpos);
+            tokens.push_back(token);
+            lastpos = pos+delimiter.length();
+        }
+        token = line.substr(lastpos, line.length()-lastpos);
+        tokens.push_back(token);
+        return std::move(tokens);
+    }
+
+
+    static std::string strip_path(std::string& str) {
+        auto idx = str.find_last_of("/");
+        return str.substr(idx, str.length());
+    }
+
+    template <typename Sequence, typename Pred>
+    static Sequence& trim_end(Sequence& seq, Pred pred) {
+        auto last = std::find_if_not(seq.rbegin(),
+                                     seq.rend(),
+                                     pred);
+        seq.erase(last.base(), seq.end());
+        return seq;
+    }
+
+    static std::string& trim_end(std::string& str, const char tr) {
+        return trim_end(str, [&tr](const char c){ return c == tr; });
+    }
+
+    static std::string split(std::string str, char c) {
+        return str.substr(0, str.find_first_of(c));
+    }
+
+    static std::string join(std::vector<std::string> list, std::string sep="") {
+        std::string result = "";
+        if (list.empty()) return result;
+
+        result = list[0];
+        for (int i = 1; i < list.size(); i++) {
+            result += sep + list[i];
+        }
+        return result;
+    }
+    
+    static void split(std::vector<std::string> &tokens, const std::string& s, std::string delimiter)
+    {
+        tokens.clear();
+
+        std::string token;
+        
+        std::string line = s;
+        int lastpos = 0;
+        int pos = 0;
+        
+        while ((pos = line.find(delimiter, lastpos)) != std::string::npos) {
+            token = line.substr(lastpos, pos-lastpos);
+            tokens.push_back(token);
+            lastpos = pos+delimiter.length();
+        }
+        token = line.substr(lastpos, line.length()-lastpos);
+        tokens.push_back(token);
+    }
+    
+    template <class T>
+    static bool vectorContains(std::vector<T> v, T element) {
+        return (v.find(element) == v.end());
+    }
+
+    static std::string FormatSeconds(size_t s) {
+        std::string result = "";
+
+        uint hours = s/3600;
+        s -= hours * 3600;
+        uint mins = s/60;
+        s -= mins * 60;
+        uint secs = s;
+
+        if (hours) result += std::to_string(hours) + "h ";
+        if (mins) result += std::to_string(mins) + "m ";
+        if (secs) result += std::to_string(secs) + "s";
+        return result;
+    }
+
+
+    static std::string FormatMilliseconds(size_t ms) {
+        std::string result = "";
+
+        uint hours = ms/3600000;
+        ms -= hours * 3600000;
+        uint mins = ms/60000;
+        ms -= mins * 60000;
+        uint secs = ms/1000;
+        ms -= secs * 1000;
+
+        if (hours) result += std::to_string(hours) + "h ";
+        if (mins) result += std::to_string(mins) + "m ";
+        if (secs) result += std::to_string(secs) + "s ";
+        if (ms) result += std::to_string(ms) + "ms";
+        return result;
+    }
+    
+    static inline bool exists (const std::string& name) {
+        if (FILE *file = fopen(name.c_str(), "r")) {
+            fclose(file);
+            return true;
+        } else {
+            return false;
+        }
+    }
+    
+    static std::string to_string_precision(double l, int precision) {
+        std::ostringstream strs;
+        strs << std::fixed << std::setprecision(precision)  << l;
+        return strs.str();
+    }
+    
+    template <class T, class U>
+    static bool mapContains(std::unordered_map<T, U> v, T element) {
+        return (v.find(element) == v.end());
+    }
+    
+    static uint64_t swapEndianess(uint64_t &value, uint32_t bytes) {
+        uint8_t swap[8];
+        memset(swap, 0 ,8);
+        for (int i = 7; i > (7-bytes); i--) {
+            swap[7 - i] = ((uint8_t *) &value)[i];
+        }
+        return *((uint64_t*)swap);
+    }
+    
+    static void swapEndianess(uint8_t* value, int32_t bytes) {
+        uint8_t cache;
+        for (int i = 7; i > (7-bytes) && (i >= 4); i--) {
+            cache = value[i];
+            value[i] = value[7-i];
+            value[7-i] = cache;
+        }
+    }
+    
+    static std::string stripExtension(std::string file) {
+        int index = file.rfind('.');
+        int slash_i = file.rfind('/');
+        if (index > 0 && slash_i > 0 && index > slash_i) {
+            return file.substr(slash_i+1, index-slash_i-1);
+        }
+        return file;
+    }
+
+    static long GetFileSize(std::string filename)
+    {
+        struct stat stat_buf;
+        int rc = stat(filename.c_str(), &stat_buf);
+        return rc == 0 ? stat_buf.st_size : -1;
+    }
+
+
+
+//// reference implementation
+//    int FastHammondRef(const char *s, const char *t, int length)
+//    {
+//        int result = 0;
+//        int i;
+//
+//        for (i = 0; i < length; ++i)
+//        {
+//            if (s[i] == t[i])
+//                result++;
+//        }
+//        return result;
+//    }
+//
+//// optimised implementation
+//    int FastHammond(const char *s, const char *t, int length)
+//    {
+//        int result = 0;
+//        int i;
+//
+//        __m128i vsum = _mm_set1_epi32(0);
+//        for (i = 0; i < length - 15; i += 16)
+//        {
+//            __m128i vs, vt, v, vh, vl, vtemp;
+//
+//            vs = _mm_loadu_si128((__m128i *)&s[i]); // load 16 chars from input
+//            vt = _mm_loadu_si128((__m128i *)&t[i]);
+//            v = _mm_cmpeq_epi8(vs, vt);             // compare
+//            vh = _mm_unpackhi_epi8(v, v);           // unpack compare result into 2 x 8 x 16 bit vectors
+//            vl = _mm_unpacklo_epi8(v, v);
+//            vtemp = _mm_madd_epi16(vh, vh);         // accumulate 16 bit vectors into 4 x 32 bit partial sums
+//            vsum = _mm_add_epi32(vsum, vtemp);
+//            vtemp = _mm_madd_epi16(vl, vl);
+//            vsum = _mm_add_epi32(vsum, vtemp);
+//        }
+//
+//        // get sum of 4 x 32 bit partial sums
+//        vsum = _mm_add_epi32(vsum, _mm_srli_si128(vsum, 8));
+//        vsum = _mm_add_epi32(vsum, _mm_srli_si128(vsum, 4));
+//        result = _mm_cvtsi128_si32(vsum);
+//
+//        // handle any residual bytes ( < 16)
+//        if (i < length)
+//        {
+//            result += FastHammondRef(&s[i], &t[i], length - i);
+//        }
+//
+//        return result;
+//    }
+}
\ No newline at end of file
diff --git a/src/Utilities/xxhash64.h b/src/Utilities/xxhash64.h
new file mode 100755
index 0000000..4d0bbc5
--- /dev/null
+++ b/src/Utilities/xxhash64.h
@@ -0,0 +1,202 @@
+// //////////////////////////////////////////////////////////
+// xxhash64.h
+// Copyright (c) 2016 Stephan Brumme. All rights reserved.
+// see http://create.stephan-brumme.com/disclaimer.html
+//
+
+#pragma once
+#include <stdint.h> // for uint32_t and uint64_t
+
+/// XXHash (64 bit), based on Yann Collet's descriptions, see http://cyan4973.github.io/xxHash/
+/** How to use:
+    uint64_t myseed = 0;
+    XXHash64 myhash(myseed);
+    myhash.add(pointerToSomeBytes,     numberOfBytes);
+    myhash.add(pointerToSomeMoreBytes, numberOfMoreBytes); // call add() as often as you like to ...
+    // and compute hash:
+    uint64_t result = myhash.hash();
+
+    // or all of the above in one single line:
+    uint64_t result2 = XXHash64::hash(mypointer, numBytes, myseed);
+
+    Note: my code is NOT endian-aware !
+**/
+class XXHash64
+{
+public:
+  /// create new XXHash (64 bit)
+  /** @param seed your seed value, even zero is a valid seed **/
+  explicit XXHash64(uint64_t seed)
+  {
+    state[0] = seed + Prime1 + Prime2;
+    state[1] = seed + Prime2;
+    state[2] = seed;
+    state[3] = seed - Prime1;
+    bufferSize  = 0;
+    totalLength = 0;
+  }
+
+  /// add a chunk of bytes
+  /** @param  input  pointer to a continuous block of data
+      @param  length number of bytes
+      @return false if parameters are invalid / zero **/
+  bool add(const void* input, uint64_t length)
+  {
+    // no data ?
+    if (!input || length == 0)
+      return false;
+
+    totalLength += length;
+    // byte-wise access
+    const unsigned char* data = (const unsigned char*)input;
+
+    // unprocessed old data plus new data still fit in temporary buffer ?
+    if (bufferSize + length < MaxBufferSize)
+    {
+      // just add new data
+      while (length-- > 0)
+        buffer[bufferSize++] = *data++;
+      return true;
+    }
+
+    // point beyond last byte
+    const unsigned char* stop      = data + length;
+    const unsigned char* stopBlock = stop - MaxBufferSize;
+
+    // some data left from previous update ?
+    if (bufferSize > 0)
+    {
+      // make sure temporary buffer is full (16 bytes)
+      while (bufferSize < MaxBufferSize)
+        buffer[bufferSize++] = *data++;
+
+      // process these 32 bytes (4x8)
+      process(buffer, state[0], state[1], state[2], state[3]);
+    }
+
+    // copying state to local variables helps optimizer A LOT
+    uint64_t s0 = state[0], s1 = state[1], s2 = state[2], s3 = state[3];
+    // 32 bytes at once
+    while (data <= stopBlock)
+    {
+      // local variables s0..s3 instead of state[0]..state[3] are much faster
+      process(data, s0, s1, s2, s3);
+      data += 32;
+    }
+    // copy back
+    state[0] = s0; state[1] = s1; state[2] = s2; state[3] = s3;
+
+    // copy remainder to temporary buffer
+    bufferSize = stop - data;
+    for (uint64_t i = 0; i < bufferSize; i++)
+      buffer[i] = data[i];
+
+    // done
+    return true;
+  }
+
+  /// get current hash
+  /** @return 64 bit XXHash **/
+  uint64_t hash() const
+  {
+    // fold 256 bit state into one single 64 bit value
+    uint64_t result;
+    if (totalLength >= MaxBufferSize)
+    {
+      result = rotateLeft(state[0],  1) +
+               rotateLeft(state[1],  7) +
+               rotateLeft(state[2], 12) +
+               rotateLeft(state[3], 18);
+      result = (result ^ processSingle(0, state[0])) * Prime1 + Prime4;
+      result = (result ^ processSingle(0, state[1])) * Prime1 + Prime4;
+      result = (result ^ processSingle(0, state[2])) * Prime1 + Prime4;
+      result = (result ^ processSingle(0, state[3])) * Prime1 + Prime4;
+    }
+    else
+    {
+      // internal state wasn't set in add(), therefore original seed is still stored in state2
+      result = state[2] + Prime5;
+    }
+
+    result += totalLength;
+
+    // process remaining bytes in temporary buffer
+    const unsigned char* data = buffer;
+    // point beyond last byte
+    const unsigned char* stop = data + bufferSize;
+
+    // at least 8 bytes left ? => eat 8 bytes per step
+    for (; data + 8 <= stop; data += 8)
+      result = rotateLeft(result ^ processSingle(0, *(uint64_t*)data), 27) * Prime1 + Prime4;
+
+    // 4 bytes left ? => eat those
+    if (data + 4 <= stop)
+    {
+      result = rotateLeft(result ^ (*(uint32_t*)data) * Prime1,   23) * Prime2 + Prime3;
+      data  += 4;
+    }
+
+    // take care of remaining 0..3 bytes, eat 1 byte per step
+    while (data != stop)
+      result = rotateLeft(result ^ (*data++) * Prime5,            11) * Prime1;
+
+    // mix bits
+    result ^= result >> 33;
+    result *= Prime2;
+    result ^= result >> 29;
+    result *= Prime3;
+    result ^= result >> 32;
+    return result;
+  }
+
+
+  /// combine constructor, add() and hash() in one static function (C style)
+  /** @param  input  pointer to a continuous block of data
+      @param  length number of bytes
+      @param  seed your seed value, e.g. zero is a valid seed
+      @return 64 bit XXHash **/
+  static uint64_t hash(const void* input, uint64_t length, uint64_t seed)
+  {
+    XXHash64 hasher(seed);
+    hasher.add(input, length);
+      return hasher.hash();
+  }
+
+private:
+  /// magic constants :-)
+  static const uint64_t Prime1 = 11400714785074694791ULL;
+  static const uint64_t Prime2 = 14029467366897019727ULL;
+  static const uint64_t Prime3 =  1609587929392839161ULL;
+  static const uint64_t Prime4 =  9650029242287828579ULL;
+  static const uint64_t Prime5 =  2870177450012600261ULL;
+
+  /// temporarily store up to 31 bytes between multiple add() calls
+  static const uint64_t MaxBufferSize = 31+1;
+
+  uint64_t      state[4];
+  unsigned char buffer[MaxBufferSize];
+  uint64_t      bufferSize;
+  uint64_t      totalLength;
+
+  /// rotate bits, should compile to a single CPU instruction (ROL)
+  static inline uint64_t rotateLeft(uint64_t x, unsigned char bits)
+  {
+    return (x << bits) | (x >> (64 - bits));
+  }
+
+  /// process a single 64 bit value
+  static inline uint64_t processSingle(uint64_t previous, uint64_t input)
+  {
+    return rotateLeft(previous + input * Prime2, 31) * Prime1;
+  }
+
+  /// process a block of 4x4 bytes, this is the main part of the XXHash32 algorithm
+  static inline void process(const void* data, uint64_t& state0, uint64_t& state1, uint64_t& state2, uint64_t& state3)
+  {
+    const uint64_t* block = (const uint64_t*) data;
+    state0 = processSingle(state0, block[0]);
+    state1 = processSingle(state1, block[1]);
+    state2 = processSingle(state2, block[2]);
+    state3 = processSingle(state3, block[3]);
+  }
+};
-- 
2.34.1

