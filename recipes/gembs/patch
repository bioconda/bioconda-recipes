diff --git a/setup.py b/setup.py
index b095d25..bdb1c80 100644
--- a/setup.py
+++ b/setup.py
@@ -155,16 +155,16 @@ class install(_install):
     _install.boolean_options.extend(['no-samtools','no-gem3','no-bscall','minimal'])
 
     def initialize_options(self):
-        self.minimal = False
-        self.no_samtools = False
-        self.no_gem3 = False
-        self.no_bscall = False
-        self.disable_cuda = False
+        self.minimal = True
+        self.no_samtools = True
+        self.no_gem3 = True
+        self.no_bscall = True
+        self.disable_cuda = True
         self.enable_cuda = False
         _install.initialize_options(self)
         
     def run(self):
-        options=['setup', '_bcftools', '_utils']
+        options=['setup', '_utils']
         if not self.minimal:
             if not self.no_samtools:
                 options.append('_samtools')
@@ -176,7 +176,7 @@ class install(_install):
         if not self.enable_cuda:
             self.diable_cuda = True
             
-        compile_gemBS_tools(options, self.enable_cuda, self.disable_cuda)
+        #compile_gemBS_tools(options, self.enable_cuda, self.disable_cuda)
         _install.run(self)
 
         # find target folder
diff --git a/tools/Makefile b/tools/Makefile
index ebd8f3a..27e760d 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -47,7 +47,7 @@ _bcftools: $(HTSLIB_DIR) $(BCFTOOLS_DIR) $(BCFTOOLS_DIR)/config.h
 _bs_call: bs_call/src/Makefile.mk
 	$(MAKE) --directory=bs_call
 
-_utils: utils/Makefile 
+_utils:
 	$(MAKE) --directory=utils
 
 utils/Makefile: utils/Makefile.in utils/configure _samtools
diff --git a/tools/utils/mextr/command_line.c b/tools/utils/mextr/command_line.c
index 2b0ce0d..0ceba19 100644
--- a/tools/utils/mextr/command_line.c
+++ b/tools/utils/mextr/command_line.c
@@ -25,6 +25,7 @@
 // These are copied from htslib:synced_bcf_reader.c as the definitions are not visible
 // in the standard library and we need them to allow sorting of regions
 
+/*
 typedef struct {
 	hts_pos_t start, end;
 } region1_t;
@@ -33,6 +34,7 @@ struct _region_t {
 	region1_t *regs;
 	int nregs, mregs, creg;
 };
+*/
 
 const char *usage(void) {
 	return
@@ -297,11 +299,11 @@ void handle_command_line(int argc, char *argv[], args_t * const args) {
 		if(!nr) error("None of the requested contigs are present in the input file\n");
 		qsort_r(ix, nr, sizeof(int), cmp_reg, reg);
 		char **tseq = malloc(sizeof(char *) * nr);
-		struct _region_t *treg = malloc(sizeof(struct _region_t) * nr);
+		bcf_sr_regions_t *treg = malloc(sizeof(bcf_sr_regions_t) * nr);
 		for(int i = 0; i < nr; i++) {
 			const int j = ix[i];
 			tseq[i] = reg->seq_names[j];
-			memcpy(treg + i, reg->regs + j, sizeof(struct _region_t));
+			memcpy(treg + i, reg->regs + j, sizeof(bcf_sr_regions_t));
 			khash_str2int_set(reg->seq_hash, tseq[i], i);
 		}
 		free(reg->seq_names);
@@ -335,7 +337,7 @@ void handle_command_line(int argc, char *argv[], args_t * const args) {
 			reg->prev_start = reg->prev_end = reg->prev_seq = -1;
 			reg->seq_hash = khash_str2int_init();
 			reg->seq_names = calloc(nctgs, sizeof(char *));
-			reg->regs = calloc(nctgs, sizeof(struct _region_t));
+			reg->regs = calloc(nctgs, sizeof(bcf_sr_regions_t));
 			for(int i = 0; i < nctgs; i++) {
 				reg->nseqs++;
 				reg->seq_names[i] = ctgs[i].name;
