diff -ruN RNAz-2.1/Makefile.am patched_RNAz/Makefile.am
--- RNAz-2.1/Makefile.am	2009-10-28 16:53:13.000000000 +0100
+++ patched_RNAz/Makefile.am	2018-12-28 15:58:36.371446148 +0100
@@ -2,6 +2,6 @@
 
 docu_DATA = INSTALL README AUTHORS COPYING TODO manual.pdf
  
-EXTRA_DIST = INSTALL README AUTHORS COPYING TODO manual.pdf libsvm-2.89
+EXTRA_DIST = INSTALL README AUTHORS COPYING TODO manual.pdf libsvm-3.21
 
 docudir = $(pkgdatadir)
diff -ruN RNAz-2.1/perl/rnazAnnotate.pl patched_RNAz/perl/rnazAnnotate.pl
--- RNAz-2.1/perl/rnazAnnotate.pl	2009-08-11 19:29:06.000000000 +0200
+++ patched_RNAz/perl/rnazAnnotate.pl	2018-12-29 16:07:44.104786150 +0100
@@ -1,4 +1,4 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl -w
 
 # $Id: rnazAnnotate.pl,v 1.3 2006/03/24 15:43:13 wash Exp $
 
diff -ruN RNAz-2.1/perl/rnazAnnotate.pl~ patched_RNAz/perl/rnazAnnotate.pl~
--- RNAz-2.1/perl/rnazAnnotate.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazAnnotate.pl~	2009-08-11 19:29:06.000000000 +0200
@@ -0,0 +1,156 @@
+#!/usr/bin/perl -w
+
+# $Id: rnazAnnotate.pl,v 1.3 2006/03/24 15:43:13 wash Exp $
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+
+my $BEDfile='';
+my $version=0;
+my $man=0;
+my $help='';
+
+GetOptions('bed=s' => \$BEDfile,
+		   'b=s' => \$BEDfile,
+		   'version'=>\$version,
+		   'v'=>\$version,
+		   'man'=>\$man,
+		   'help'=>\$help,
+		   'h'=>\$help
+		  ) or pod2usage(1);
+
+pod2usage(1) if $help;
+pod2usage(-verbose => 2) if $man;
+
+if ($version){
+  print "\nrnazAnnotate.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+
+open(BED,"<$BEDfile")||die("Could not read $BEDfile ($!)");
+
+my %track=();
+
+while (<BED>){
+  next if /track/;
+  (my $chrom, my $start, my $end, my $name)=split;
+
+  if (!exists($track{$chrom})){
+	$track{$chrom}=[{start=>$start,end=>$end,name=>$name}];
+  } else {
+	push @{$track{$chrom}},{start=>$start,end=>$end,name=>$name};
+  }	
+}
+
+foreach my $key (keys %track){
+  $track{$key}=[sort {$a->{start}<=>$b->{start}} @{$track{$key}}];
+}
+
+while (my $line=<>){
+
+  # Only consider "cluster" entries for annotation, simply print "hits"
+  if (!($line=~/\s?^locus/)){
+	print $line;
+	next;
+  }
+
+  (my $clusterID,my $findChrom,my $findStart,my $findEnd)=split(/\t/,$line);
+
+  # In BED files usually only chromosome identifier are stored
+  # (e.g. chr6), while in MAFs and rnazCluster.pl output you find
+  # "hg17.chr6".  If the sequence idenitfiers in the original MAF are
+  # of the form x.y, only y is used for comparison with the BED
+  if ($findChrom =~ /^(.*)\.(.*)$/){
+	$findChrom=$2;
+  }
+
+  next if (!exists($track{$findChrom}));
+
+  # Look for two neighbouring BED entries using intervallschachtelung
+  my $n1=0;
+  my $n2=@{$track{$findChrom}}-1;
+
+  while (($n2-$n1)>1){
+	my $divide=$n1+int(($n2-$n1)/2);
+	if (($track{$findChrom}->[$divide]->{start})<=$findStart){
+	  $n1=$divide
+	} else {
+	  $n2=$divide;
+	}
+  }
+
+  my $hit=undef;
+
+  # if overlaps two BED entries the first is taken
+  if (overlaps($findStart,$findEnd,$track{$findChrom}->[$n1]->{start},$track{$findChrom}->[$n1]->{end})){
+	$hit=$n1;
+  } elsif (overlaps($findStart,$findEnd,$track{$findChrom}->[$n2]->{start},$track{$findChrom}->[$n2]->{end})){
+	$hit=$n2;
+  }
+
+  # If there is overlap, add the name from bed in "" as last field
+  # to the cluster line
+  if (defined $hit){
+	my $ann=$track{$findChrom}->[$hit]->{name};
+	$ann=~s/\t/ /g;
+	chomp($line);
+	print "$line\t\"$ann\"\n";
+  } else {
+	chomp($line);
+	print "$line\t-\n";
+  }
+}
+
+sub overlaps{
+  (my $queryStart,my $queryEnd,my $subjectStart,my $subjectEnd)=@_;
+  return 0 if (($queryEnd<$subjectStart) or ($queryStart>$subjectEnd));
+  return 1;
+}
+
+__END__
+
+=head1 NAME
+
+C<rnazAnnotate.pl> - Compare tab-delimited data file as generated by
+C<rnazCluster> to a BED annotation file.
+
+=head1 SYNOPSIS
+
+ rnazAnnotate.pl [options] [file]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<-b, --bed>
+
+Set the annotation BED file with this option.
+
+=back
+
+=head1 DESCRIPTION
+
+This simple programs reads a tab-delimited data file as generated by
+C<rnazCluster.pl>. It compares the genomic region of each predicted
+locus to the annotations of a BED file. If there is some overlap, the
+description field of the annotation line in the BED file is added in
+double quotes as the last field to the locus line.
+
+=head1 EXAMPLES
+
+ # rnazAnnotate.pl -b annotation.bed results.dat
+
+Annotates the loci in C<results.dat> with annotations in
+C<annotation.bed>.
+
+=head1 AUTHORS
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+=cut
diff -ruN RNAz-2.1/perl/rnazBEDsort.pl patched_RNAz/perl/rnazBEDsort.pl
--- RNAz-2.1/perl/rnazBEDsort.pl	2009-08-11 19:29:06.000000000 +0200
+++ patched_RNAz/perl/rnazBEDsort.pl	2018-12-29 16:07:58.160772609 +0100
@@ -1,4 +1,4 @@
-#!/usr/local/bin/perl -w
+#!/usr/bin/env perl -w
 
 # $Id: rnazBEDsort.pl,v 1.2 2006/03/24 15:43:13 wash Exp $
 
diff -ruN RNAz-2.1/perl/rnazBEDsort.pl~ patched_RNAz/perl/rnazBEDsort.pl~
--- RNAz-2.1/perl/rnazBEDsort.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazBEDsort.pl~	2009-08-11 19:29:06.000000000 +0200
@@ -0,0 +1,117 @@
+#!/usr/local/bin/perl -w
+
+# $Id: rnazBEDsort.pl,v 1.2 2006/03/24 15:43:13 wash Exp $
+
+#missing: re-introduce track line, more intelligent sort of seq-ids (chr9 before chr10)
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+use strict;
+
+my $help=0;
+my $man=0;
+my $version=0;
+
+GetOptions('help'=>\$help,
+		   'man'=>\$man,
+		   'h'=>\$help,
+		   'version'=>\$version,
+		   'v'=>\$version,
+		  ) or pod2usage(1);
+
+pod2usage(1) if $help;
+pod2usage(-verbose => 2) if $man;
+
+if ($version){
+  print "\nrnazSelectSeqs.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+
+my %lines=();
+
+while (my $line=<>){
+
+  chomp($line);
+
+  next if ($line=~/track/);
+  next if ($line=~/^$/);
+
+  my @fields=split(/\t/,$line);
+
+  my $seqID=$fields[0];
+  my $start=$fields[1];
+  my $end=$fields[2];
+
+  if (!exists($lines{$seqID})){
+	$lines{$seqID}=[[@fields]];
+  } else {
+	push @{$lines{$seqID}},[@fields];
+  }
+}
+
+
+foreach my $key (sort keys %lines){
+
+  my @tmp=sort {$a->[1] <=> $b->[1]} @{$lines{$key}};
+
+  foreach my $line (@tmp){
+	#print $line->[1];
+	print join("\t",@$line),"\n";
+  }
+}
+
+__END__
+
+=head1 NAME
+
+C<rnazBEDsort.pl> - Sorts a BED annotation file.
+
+=head1 SYNOPSIS
+
+ rnazBEDsort.pl [options] [file]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<-v, --version>
+
+Prints version information and exits.
+
+=item B<-h, --help>
+
+Prints a short help message and exits.
+
+=item B<--man>
+
+Prints a detailed manual page and exits.
+
+=back
+
+=head1 DESCRIPTION
+
+C<rnazBEDsort.pl> reads a BED formatted annotation file and sorts the
+lines by sequence identifier and genomic location. Note: this simple
+script is not very memory efficient so you could run into problems if
+you try to sort really large BEDs.
+
+=head1 EXAMPLES
+
+ # rnazBEDsort.pl some.bed
+
+Sorts the file C<some.bed> and prints the results to standard out.
+
+=head1 AUTHORS
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+=cut
+
+
+
diff -ruN RNAz-2.1/perl/rnazBEDstats.pl patched_RNAz/perl/rnazBEDstats.pl
--- RNAz-2.1/perl/rnazBEDstats.pl	2009-08-11 19:29:06.000000000 +0200
+++ patched_RNAz/perl/rnazBEDstats.pl	2018-12-29 16:07:10.101818902 +0100
@@ -1,4 +1,4 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl -w
 
 # $Id: rnazBEDstats.pl,v 1.3 2008-01-24 10:26:45 wash Exp $
 
diff -ruN RNAz-2.1/perl/rnazBEDstats.pl~ patched_RNAz/perl/rnazBEDstats.pl~
--- RNAz-2.1/perl/rnazBEDstats.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazBEDstats.pl~	2009-08-11 19:29:06.000000000 +0200
@@ -0,0 +1,137 @@
+#!/usr/bin/perl -w
+
+# $Id: rnazBEDstats.pl,v 1.3 2008-01-24 10:26:45 wash Exp $
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+use strict;
+
+my $help=0;
+my $man=0;
+my $version=0;
+
+GetOptions('help'=>\$help,
+		   'man'=>\$man,
+		   'h'=>\$help,
+		   'version'=>\$version,
+		   'v'=>\$version,
+		  ) or pod2usage(1);
+
+pod2usage(1) if $help;
+pod2usage(-verbose => 2) if $man;
+
+if ($version){
+  print "\nrnazSelectSeqs.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+my $lineCount=0;
+my $total=0;
+my $bases=0;
+
+my $prevEnd=0;
+my $prevSeqID='';
+
+my $max=0;
+my $min=99999999999;
+
+while (<>){
+
+  next if (/track/);
+  next if (/^$/);
+
+  my @fields=split(/\t/,$_);
+
+  my $seqID=$fields[0];
+  my $start=$fields[1];
+  my $end=$fields[2];
+
+  chomp($end);
+
+  my $currRegion=$end-$start;
+
+  $lineCount++;
+
+  $total+=$currRegion;
+
+  if (($lineCount!=1) and
+	  ($prevSeqID eq $seqID) and
+	  ($prevEnd>$start)){
+	$bases+=($end-$prevEnd);
+  } else {
+	$bases+=$currRegion;
+  }
+
+  $max=($currRegion>$max ? $currRegion : $max);
+  $min=($currRegion<$min ? $currRegion : $min);
+
+  $prevEnd=$end;
+  $prevSeqID=$seqID;
+}
+
+my $average=int(($total/$lineCount)+0.5);
+
+print "Items: $lineCount\n";
+print "Item bases: $bases\n";
+print "Item total: $total\n";
+print "Average item: $average\n";
+print "Maximum item: $max\n";
+print "Minimum item: $min\n";
+print "\n";
+
+
+__END__
+
+=head1 NAME
+
+C<rnazBEDstats.pl> - Reports some statistics on a BED annotation file.
+
+=head1 SYNOPSIS
+
+ rnazBEDstats.pl [options] [file]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<-v, --version>
+
+Prints version information and exits.
+
+=item B<-h, --help>
+
+Prints a short help message and exits.
+
+=item B<--man>
+
+Prints a detailed manual page and exits.
+
+=back
+
+=head1 DESCRIPTION
+
+C<rnazBEDstats.pl> reads a BED formatted annotation file and prints
+some basic statistics. It counts the single annotations (``items") but
+also the bases covered by these items. ``Item bases" means the number
+of bases that are covered by the items (overlapping regions are not
+counted). ``Item total" is simply the sum of all items (overlapping
+regions are counted). Important: The BED file B<must be sorted> for
+this program to work. You can use C<rnazBEDsort.pl> for this task.
+
+=head1 EXAMPLES
+
+ # rnazBEDstats.pl some.bed
+
+Sorts the file C<some.bed> and prints statistics for it.
+
+=head1 AUTHORS
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+=cut
+
diff -ruN RNAz-2.1/perl/rnazBlast.pl patched_RNAz/perl/rnazBlast.pl
--- RNAz-2.1/perl/rnazBlast.pl	2009-08-11 19:29:06.000000000 +0200
+++ patched_RNAz/perl/rnazBlast.pl	2018-12-29 16:08:11.998759284 +0100
@@ -1,4 +1,4 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl -w
 
 # $Id: rnazBlast.pl,v 1.2 2006/03/24 15:43:13 wash Exp $
 
diff -ruN RNAz-2.1/perl/rnazBlast.pl~ patched_RNAz/perl/rnazBlast.pl~
--- RNAz-2.1/perl/rnazBlast.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazBlast.pl~	2009-08-11 19:29:06.000000000 +0200
@@ -0,0 +1,227 @@
+#!/usr/bin/perl -w
+
+# $Id: rnazBlast.pl,v 1.2 2006/03/24 15:43:13 wash Exp $
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+use File::Spec qw/path catfile/;
+
+# Set the path to your blast executable here
+my $blastExecutable='blastall';
+
+my $seqDir='';
+my $blastDir='';
+my $dbName='';
+my $cutoff='1e-06';
+my $version=0;
+my $man=0;
+my $help='';
+
+GetOptions('database=s' => \$dbName,
+		   'd=s' => \$dbName,
+		   'seq-dir:s' => \$seqDir,
+		   's:s' => \$seqDir,
+		   'blast-dir=s' => \$blastDir,
+		   'b=s' => \$blastDir,
+		   '--e-value:f' => \$cutoff,
+		   'e:f' => \$cutoff,
+		   'version'=>\$version,
+		   'man'=>\$man,
+		   'v'=>\$version,
+		   'help'=>\$help,
+		   'h'=>\$help
+		  ) or pod2usage(1);
+
+pod2usage(1) if $help;
+pod2usage(-verbose => 2) if $man;
+
+if ($version){
+  print "\nrnazBlast.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+
+if ($seqDir){
+  if (not -d $seqDir){
+	die("Data directory '$seqDir' not a valid directory ($!).");
+  }
+} else {
+  $seqDir='.';
+}
+
+if ($blastDir){
+  if (not -d $blastDir){
+	die("Blast directory '$blastDir' not a valid directory ($!).");
+  }
+} else {
+
+  $blastDir=$ENV{BLASTDB};
+
+  if (not -d $blastDir){
+	die("No blast directory found. Set the BLASTDB variable or use the --blast-dir option.");
+  }
+}
+
+my @PATH=File::Spec->path();
+
+my $found=0;
+
+foreach my $dir ("",@PATH){
+  $found=1 if (-x File::Spec->catfile($dir, $blastExecutable));
+}
+
+if (!$found){
+  print STDERR "Could not find blast executable. Ensure that 'blastn' is in your PATH or set the path directly in the perl program.\n";
+  exit(2);
+}
+
+while (my $line=<>){
+
+  # Only consider "locus" entries for annotation, simply print "windows"
+  if (!($line=~/^locus/)){
+	print $line;
+	next;
+  }
+
+  chomp($line);
+
+  (my $clusterID,my $chrom,my $start,my $end)=split(/\t/,$line);
+
+  my @guess=($chrom);
+
+  if ($chrom =~ /^(.*)\.(.*)$/){
+	push @guess,$2;
+  }
+
+  my $tmp=$#guess;
+  foreach my $i (0..$tmp) {
+	push @guess,$guess[$i].".fa";
+	push @guess,$guess[$i].".fasta";
+  }
+
+  my $realFile='';
+
+  foreach my $file (@guess){
+	if (-e "$seqDir/$file"){
+	  $realFile="$seqDir/$file";
+	  last;
+	}
+  }
+
+  if (not $realFile){
+	warn("No sequence data for '$chrom' found.\n");
+	print "$line\t?\n";
+  } else {
+	my $seq=getSeq($realFile, $start, $end, '+');
+
+	my @result=blastSeq($blastDir, $dbName, $cutoff, $seq,$blastExecutable);
+
+	if (not @result){
+	  print "$line\t-\n";
+	} else {
+
+	  my $name=$result[0]->{subjectID};
+	  my $eValue=$result[0]->{e};
+	  print "$line\t\"$name|$eValue\"\n";
+	}
+  }
+}
+
+__END__
+
+=head1 NAME
+
+C<rnazBlast.pl> - Compares predicted loci from data files as generated
+by C<rnazCluster.pl> to a sequence database using BLAST.
+
+=head1 SYNOPSIS
+
+ rnazBlast.pl [options] [file]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<-b> name, B<--blast-dir>=name
+
+The directory with your BLAST database. If not set, the value from the
+C<BLASTDB> environment variable is used.
+
+=item B<-d> name, B<--database>=name
+
+Name of the BLAST database to compare with. Must exist in the
+directory set with C<--blast-dir> or in the directory set by
+C<BLASTDB>.
+
+=item B<-s> name, B<--seq-dir>=name
+
+Directory with sequence files. For each sequence identifier in your
+input file you need to have a corresponding FASTA formatted file. The
+files should be named with the sequence identifier and the extension
+C<.fa> or C<.fasta>. If your identifier in your input file is for
+example C<contig100> then you should have a file named
+C<contig100.fa>. (If your identifier is of the form
+``assembly.chromosome" as for example used by UCSC alignments, it is
+also possible to name the file C<chr22.fa> for a sequence identifier
+C<hg17.chr22>).
+
+=item B<-e> X, B<--e-value>=X
+
+E-value cutoff. All hits with E < X are reported. (Default: 1e-06)
+
+=item B<-v, --version>
+
+Prints version information and exits.
+
+=item B<-h --help>
+
+Prints a brief help message and exits.
+
+=item B<--man>
+
+Prints the manual page and exits.
+
+=back
+
+=head1 DESCRIPTION
+
+C<rnazBlast.pl> is a simple program to compare your hits to a sequence
+database using BLAST. To use it you need (i) a sequence database (ii)
+the sequence files to which the coordinates in your results file refer
+(iii) a NCBI BLAST installation, i.e. a C<blastall> executable
+somewhere.
+
+First you have to create a BLAST index file for your sequence
+database. You should have a FASTA formatted file of your
+database. Assume for example that the file C<rfam> contains all
+sequences of the Rfam database. Run the following command 
+
+ # formatdb -t rfam -i rfam -p F
+
+Make sure that you have the sequence files available and named
+correctly (see notes for the C<--seq-dir> option). In this example we
+assume that the files are in the subdirectory C<seq>
+
+You can run the following command to compare each locus in the file
+C<results.dat> with the newly created C<rfam> database (which is in
+the subdirectory C<rfam>):
+
+ # rnazBlast.pl --database=rfam --seq-dir=seq \
+                --blast-dir=rfam --e-value=1e-06 \
+                  results.dat > annotated.dat
+
+If there is a hit better than E=1e-06 the name of the matching
+sequence and the E-value is added in double quotes as additional field
+to the locus line.
+
+=head1 AUTHORS
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+=cut
+
diff -ruN RNAz-2.1/perl/rnazCluster.pl patched_RNAz/perl/rnazCluster.pl
--- RNAz-2.1/perl/rnazCluster.pl	2009-08-11 19:37:02.000000000 +0200
+++ patched_RNAz/perl/rnazCluster.pl	2018-12-29 16:07:32.566797264 +0100
@@ -1,4 +1,4 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl -w
 
 # $Id: rnazCluster.pl,v 1.4 2008-01-24 10:26:45 wash Exp $
 
diff -ruN RNAz-2.1/perl/rnazCluster.pl~ patched_RNAz/perl/rnazCluster.pl~
--- RNAz-2.1/perl/rnazCluster.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazCluster.pl~	2009-08-11 19:37:02.000000000 +0200
@@ -0,0 +1,925 @@
+#!/usr/bin/perl -w
+
+# $Id: rnazCluster.pl,v 1.4 2008-01-24 10:26:45 wash Exp $
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+use File::Temp qw/tempfile/;
+use File::Spec qw/path catfile/;
+
+my $cutoff=0.5;
+my $printHits=0;
+my $printClusters=0;
+my $printHeader=0;
+my $html=0;
+my $htmlDir='results';
+my $version=0;
+my $man=0;
+my $help=0;
+
+# Set custom locations of the following programs for the --html output:
+
+my $alifoldProg='RNAalifold';
+my $gsProg='gs';
+my $colorrnaProg='colorrna.pl';
+my $coloralnProg='coloraln.pl';
+
+
+# Under Windows automatically add ".exe" if it is not already done
+
+if ("$^OS"=~/Win32/i){
+
+  $alifoldProg.=".exe" if (not $alifoldProg=~/\.exe/);
+  $gsProg.=".exe" if (not $gsProg=~/\.exe/);
+
+}
+
+
+GetOptions('cutoff:f' => \$cutoff,
+		   'c:f' => \$cutoff,
+		   'windows'=>\$printHits,
+		   'loci'=>\$printClusters,
+		   'w'=>\$printHits,
+		   'l'=>\$printClusters,
+		   'header'=>\$printHeader,
+		   'd'=>\$printHeader,
+		   'html'=>\$html,
+		   'html-dir:s'=>\$htmlDir,
+		   'version'=>\$version,
+		   'man'=>\$man,
+		   'v'=>\$version,
+		   'help'=>\$help,
+		   'h'=>\$help
+		  ) or pod2usage(1);
+
+pod2usage(1) if $help;
+pod2usage(-verbose => 2) if $man;
+
+if ($version){
+  print "\nrnazCluster.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+
+if (!$printHits and !$printClusters){
+  $printHits=$printClusters=1;
+}
+
+if ($printHeader){
+
+  if ($printClusters){
+	print "# locusID\tseqID\tstart\tend\tmaxN\tmaxIdentity\tmaxP\tminZ\n";
+  }
+
+  if ($printHits){
+	print "# windowID\tclusterID\tseqID\tstart\tend\tstrand\tN\tcolumns\tidentity\tmeanMFE\tconsensusMFE\tenergyTerm\tcovarianceTerm\tcombPerPair\tz\tSCI\tdecValue\tP\nGC";
+  }
+}
+
+if ($html){
+  mkdir($htmlDir) || die("Could not create directory for HTML files ($!)");
+
+  my $alifoldFlag=0;
+  my $colorrnaFlag=0;
+  my $coloralnFlag=0;
+  my $gsFlag=0;
+
+  # Search in PATH for executables
+  my @PATH=File::Spec->path();
+  foreach my $dir (@PATH){
+	$alifoldFlag=1 if (-x File::Spec->catfile($dir, $alifoldProg));
+	$gsFlag=1 if (-x File::Spec->catfile($dir, $gsProg));
+	# Test for existance on perl-scripts since in Windows they are not
+	# identified by -x because they are no .exe
+	$colorrnaFlag=1 if (-e File::Spec->catfile($dir, $colorrnaProg));
+	$coloralnFlag=1 if (-e File::Spec->catfile($dir, $coloralnProg));
+	last if $alifoldFlag && $colorrnaFlag && $coloralnFlag && $gsFlag;
+  }
+
+  # Check if a full path to the executables has been set
+  $alifoldFlag=1 if (-x $alifoldProg);
+  $gsFlag=1 if (-x $gsProg);
+  $colorrnaFlag=1 if (-e $colorrnaProg);
+  $coloralnFlag=1 if (-e $coloralnProg);
+
+  if (!($alifoldFlag && $colorrnaFlag && $coloralnFlag && $gsFlag)){
+
+	print STDERR <<END;
+
+To use the --html option you need additional programs. Make sure that
+the following executables are within your PATH of executables or
+directly set the location of the programs in the source code of the
+rnazCluster.pl script:
+END
+
+	print STDERR "'RNAalifold' not found.\n" if not $alifoldFlag; 
+	print STDERR "'colorrna.pl' not found.\n" if not $colorrnaFlag;
+	print STDERR "'coloraln.pl' not found.\n" if not $coloralnFlag;
+	print STDERR "'gs' not found.\n" if not $gsFlag;
+
+	exit(1);
+  }
+}
+
+
+my ($currName,$currStart,$currEnd,$currStrand);
+my ($prevName,$prevStart,$prevEnd);
+
+$prevName=''; $prevStart=0; $prevEnd=0;
+
+my ($maxP, $maxN, $maxID, $maxZ);
+$maxN=0;$maxID=0;$maxZ=100;$maxP=0;
+my $minStart=99000000;
+my $maxEnd=0;
+
+my @hits=();
+
+my $clusterID=1;
+my $hitID=1;
+
+my $fileName=shift @ARGV;
+my $fh;
+
+if (!defined $fileName){
+  $fh=*STDIN;
+} else {
+  open($fh,"<$fileName") || die("Could not open file $fileName ($!)");
+}
+
+while (my $rnazString=getNextRNAz($fh)){
+
+  #print $rnazString,"\n====================================\n";
+
+  my $results=parseRNAz($rnazString);
+
+  $currStart=$results->{refSeqStart};
+  $currEnd=$results->{refSeqEnd};
+  $currName=$results->{refSeqName};
+  $currStrand=$results->{refSeqStrand};
+
+  if ($results->{P}>=$cutoff){
+#	print %$results;
+	# if there is NO overlap start new cluster
+
+	#print "$currName $prevName $currStart $prevEnd\n";
+
+	if (!(($currName eq $prevName) and ($currStart <= $prevEnd))){
+
+	  if ($maxEnd!=0){ # omit first one
+
+		if ($printClusters){
+		  print "locus$clusterID\t$prevName\t$minStart\t$maxEnd\t$maxN\t$maxID\t$maxP\t$maxZ\n";
+		}
+
+		if ($printHits){
+		  foreach my $hit (@hits){
+			$hit->{clusterID}="locus$clusterID";
+			hitLine($hit);
+		  }
+		}
+
+		if ($html){
+		  createHTML(\@hits);
+		}
+		
+		@hits=();
+		$maxN=0;
+		$maxID=0;
+		$maxZ=100;
+		$maxP=0;
+		$minStart=999000000;
+		$maxEnd=0;
+		
+		$clusterID++;
+	  }
+	}
+
+	$maxN=$results->{N} if ($results->{N}>$maxN);
+	$maxP=$results->{P} if ($results->{P}>$maxP);
+	$maxID=$results->{identity} if ($results->{identity}>$maxID);
+	$maxZ=$results->{z} if ($results->{z}<$maxZ);
+	$minStart=$currStart if ($currStart<$minStart);
+	$maxEnd=$currEnd if ($currEnd>$maxEnd);
+
+	#my %currHit=(hitID=>$hitID,name=>$currName,start=>$currStart,end=>$currEnd,strand=>$currStrand);
+	
+	#my $tmp="window$hitID\tCLUSTER\t$currName\t$currStart\t$currEnd\t$currStrand";
+	#foreach my $key (qw(N columns identity meanMFE consensusMFE energy covariance combPerPair z sci decValue P)){
+	#  $tmp.="\t$results->{$key}";
+	#  $currHit{$key}=$results->{$key};
+	#}
+	#push @hits,"$tmp\n";
+
+	push @hits,{%$results,hitID=>"window$hitID"};
+
+	$hitID++;
+	
+	($prevName,$prevStart,$prevEnd)=($currName,$currStart,$currEnd);
+
+	#exit if $hitID>10;
+
+  }
+}
+
+# don't forget last cluster...
+
+if (@hits){
+  if ($printClusters){
+	print "locus$clusterID\t$prevName\t$minStart\t$maxEnd\t$maxN\t$maxID\t$maxP\t$maxZ\n";
+  }
+
+  if ($printHits){
+	foreach my $hit (@hits){
+	  $hit->{clusterID}="locus$clusterID";
+	  hitLine($hit);
+	}
+  }
+
+  if ($html){
+    	createHTML(\@hits);
+  }
+}
+
+sub toPNG{
+
+  my $file=shift;
+
+  (my $baseName)=($file=~/(.*)\.ps/);
+
+  system("gs -r72 -q -dNOPAUSE -dQUIET -dBATCH -dEPSCrop -dTextAlphaBits=4 -dGraphicsAlphaBits=2  -sDEVICE=png16m -sOutputFile=$baseName.png $file");
+
+}
+
+
+
+sub hitLine{
+
+  my %data=%{$_[0]};
+  my @tmp=();
+  foreach my $key (qw(hitID clusterID refSeqName refSeqStart refSeqEnd refSeqStrand N columns identity meanMFE consensusMFE energy covariance combPerPair z sci decValue P GC)){
+	push @tmp,$data{$key};
+  }
+  print join("\t",@tmp);
+  print "\n";
+}
+
+
+
+sub createHTML{
+
+  my @hits=@{$_[0]};
+
+
+  
+  my $locusTemplate='
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+  <head>
+    <title>Locus %clusterID%</title>
+    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+    <STYLE type="text/css">
+    TABLE {	border-spacing:1px;	background-color:#000000;}
+    TD {font-size:10pt;padding:7px;font-family:helvetica,arial,impact,sans-serif; background-color:#e5e8ff;font-weight: bold;}
+    TH {font-size:10pt;background-color:#d4d9ff;padding:7px;font-family:helvetica,arial,impact,sans-serif; text-align:right;  }
+    P {font-size:11pt;font-family:helvetica,arial,impact,sans-serif;}
+    H1 {font-size: 20pt;color:#333399;text-align: center;font-family: helvetica,arial,impact,sans-serif;padding: 10px;}
+    H2 {color:#FFFFFF; background-color:#333399;width: auto; padding:3px; border-width:normal;font-size: 14pt; font-family:helvetica,arial,impact,sans-serif;}
+    IMG {border-style:solid; border-width:thin; border-color:black;}
+    PRE {font-size:9pt;border-style:solid; border-width:thin;padding:5px;background-color:#e5e8ff;}
+
+</STYLE>
+  </head>
+  <body>
+    <h1>Locus %clusterID%</h1>
+	
+	<table>
+		<tr>
+		  <th>Sequence ID</th>
+		  <td>%seqID%</td>
+		</tr>
+		<tr>
+		  <th>Location</th>
+		  <td>%minStart% &ndash; %maxEnd%</td>
+		</tr>
+		<tr>
+		  <th>Length</th>
+		  <td>%length%</td>
+		</tr>
+		<tr>
+		  <th>Max. P</th>
+		  <td>%maxP%</td>
+		</tr>
+	</table>
+<map name="map">
+%imageMap%
+</map>
+<p><img src="map.png" usemap="#map" alt="overview"></p>
+	%hits%
+<hr>
+<p>Generated by <tt>rnazCluster.pl</tt> (part of <tt><a href="http://www.tbi.univie.ac.at/~wash/RNAz">RNAz</a> %rnazversion%</tt>) on %timestamp%</p>
+  </body>
+</html>';
+
+  my $windowTemplate='
+<h2><a name="%hitID%">Window %hitIDnumber%</a></h2>
+	<table>
+		<tr>
+		  <th>Location</th>
+		  <td>%start% &ndash; %end%</td>
+		</tr>
+		<tr>
+		  <th>Length</th>
+		  <td>%length%</td>
+		</tr>
+%rnazUpper%
+	</table>
+<p>Download alignment: <a href="%hitID%.aln">ClustalW</a> | <a href="%hitID%.maf">MAF</a></p>
+<pre>%rnazLower%</pre>
+<p>
+<img src="%hitID%_aln.png" alt="alignment"><br>
+</p>
+<p><a href="%hitID%_aln.ps">Postscript</a></p>
+
+<p><img src="%hitID%_alirna.png" alt="secondary structure"></p>
+<p><a href="%hitID%_alirna.ps">Postscript</a></p>
+<p><img src="%hitID%_alidot.png" alt="dotplot"></p>
+<p><a href="%hitID%_alidot.ps">Postscript</a></p>
+
+';
+
+  chdir $htmlDir;
+  mkdir "locus$clusterID";
+  chdir "locus$clusterID";
+
+  open(INDEX,">index.html") or die("Could not open index.html for writing ($!)");
+
+  my $tmpLocusTemplate=$locusTemplate;
+
+  my $tmpStart=niceNumber($minStart);
+  my $tmpEnd=niceNumber($maxEnd);
+
+  $tmpLocusTemplate=~s/%clusterID%/$clusterID/gs;
+  $tmpLocusTemplate=~s/%seqID%/$prevName/gs;
+  $tmpLocusTemplate=~s/%minStart%/$tmpStart/gs;
+  $tmpLocusTemplate=~s/%maxEnd%/$tmpEnd/gs;
+  $tmpLocusTemplate=~s/%maxP%/$maxP/gs;
+
+  my $length=$maxEnd-$minStart;
+
+  $tmpLocusTemplate=~s/%length%/$length/gs;
+
+  my $tmpWindowTemplate=$windowTemplate;
+  my $hitsOutput='';
+
+  my $cellClass="darkcell";
+
+  my $imageMap=createMap(\@hits);
+
+  foreach my $hit (@hits){
+
+	my $id=$hit->{hitID};
+
+	(my $idNumber)=($id=~/.*(\d+)/);
+
+	$tmpStart=niceNumber($hit->{refSeqStart});
+	$tmpEnd=niceNumber($hit->{refSeqEnd});
+	
+	$tmpWindowTemplate=~s/%hitID%/$id/gs;
+	$tmpWindowTemplate=~s/%hitIDnumber%/$idNumber/gs;
+	$tmpWindowTemplate=~s/%start%/$tmpStart/gs;
+	$tmpWindowTemplate=~s/%end%/$tmpEnd/gs;
+	my $length=$hit->{refSeqEnd}-$hit->{refSeqStart};
+	$tmpWindowTemplate=~s/%length%/$length/gs;
+
+	(my $rnazUpper, my $rnazLower)=($hit->{rawOutput}=~/(.*\#$)(.*)$/ms);
+
+	$rnazUpper=~s/RNAz $RNAz::rnazVersion//g; # remove headline from
+                                              # RNAz output for 1st
+                                              # cluster
+	$rnazUpper=~s/#//g;
+	$rnazUpper=~s/^(.*?):(.*?)$/<tr><th>$1<\/th><td>$2<\/td><\/tr>/msg;
+			
+	$tmpWindowTemplate=~s/%rnazUpper%/$rnazUpper/gs;
+	$tmpWindowTemplate=~s/%rnazLower%/$rnazLower/gs;
+
+	$hitsOutput.=$tmpWindowTemplate;
+	$tmpWindowTemplate=$windowTemplate;
+
+	my $firstLength=length($hit->{aln}->[0]->{seq});
+
+	foreach my $s (@{$hit->{aln}}){
+	  if (length($s->{seq}) != $firstLength){
+		print STDERR "WARNING: Unequal lengths in alignment. Use the --show-gaps option in your RNAz command.\n";
+	  }
+	}
+
+	open(ALN,">$id.maf");
+
+	
+	
+	print ALN formatAln($hit->{aln},"MAF");
+
+	close(ALN);
+			
+	open(ALN,">$id.aln");
+
+	foreach my $seq (@{$hit->{aln}}){
+	  $seq->{start}=undef;
+	  $seq->{end}=undef;
+	}
+			
+	print ALN formatAln($hit->{aln},"CLUSTAL");
+
+	
+
+
+	my $devnull=File::Spec->devnull();
+	system("$alifoldProg -p $id.aln >$devnull 2>$devnull");
+	system("$coloralnProg  $id.aln >$id\_aln.ps");
+	system("$colorrnaProg alirna.ps alidot.ps >$id\_alirna.ps");
+	unlink("alirna.ps");
+	rename("alidot.ps","$id\_alidot.ps");
+
+	toPNG("$id\_alirna.ps");
+	toPNG("$id\_alidot.ps");
+	toPNG("$id\_aln.ps");
+					
+	close ALN;
+
+  }
+
+  $tmpLocusTemplate=~s/%imageMap%/$imageMap/gs;
+
+  $tmpLocusTemplate=~s/%hits%/$hitsOutput/gs;
+
+  my $now=localtime;
+			
+  $tmpLocusTemplate=~s/%timestamp%/$now/gs;
+  $tmpLocusTemplate=~s/%rnazversion%/$RNAz::rnazVersion/gs;
+
+
+  print INDEX $tmpLocusTemplate;
+
+  close INDEX;
+  chdir "../../";
+}
+
+sub createMap{
+
+
+  my @hits=@{$_[0]};
+
+  my $psTemplate='%!PS-Adobe-3.0 EPSF-3.0
+%%BoundingBox: 0 0 %width% %height%
+%%EndComments
+
+/string { % (Text) x y red green blue
+  gsave
+	setrgbcolor
+	18 add
+	moveto
+	show
+  grestore
+} def
+
+
+0 %height% translate
+1 -1 scale
+/Helvetica findfont
+[12 0 0 -12 0 0] makefont setfont
+
+%/Font /Helvetica findfont def
+%/FontSize 12 def
+
+  /rightarrow { % X Y length width red green blue
+  gsave
+	setrgbcolor
+	newpath
+
+	% X,Y
+	3 index
+	3 index
+	moveto
+
+	% X+length, Y
+	3 index
+	2 index
+	add
+	10 sub
+	3 index
+	lineto
+
+	% Draw arrow
+	3 index
+	2 index
+	add
+	1 index
+	2 div
+	4 index
+	add
+	lineto
+
+	% X+length, Y+width
+	3 index
+	2 index
+	add
+	10 sub
+	3 index
+	2 index
+	add
+	lineto
+
+	% X, Y+width
+	3 index
+	3 index
+	2 index
+	add
+	lineto
+	
+	clear
+	closepath
+	fill
+  grestore
+} def
+
+/leftarrow { % X Y length width red green blue
+  gsave
+	setrgbcolor
+	newpath
+
+	% X,Y
+	3 index
+	10 add
+	3 index
+	moveto
+
+	% X+length, Y
+	3 index
+	2 index
+	add
+	3 index
+	lineto
+
+	% X+length, Y+width
+	3 index
+	2 index
+	add
+	3 index
+	2 index
+	add
+	lineto
+
+	% X, Y+width
+	3 index
+	10 add
+	3 index
+	2 index
+	add
+	lineto
+	
+	% Draw arrow, 1/20 of head
+	3 index
+	1 index
+	2 div
+	4 index
+	add
+	lineto
+
+	clear
+	closepath
+	fill
+  grestore
+} def
+  
+
+
+0 0 0 setrgbcolor
+
+%100 100 200 7 0 1 0 rightarrow
+%(This is a string) 100 100 1 0 0 string
+
+  %data%
+
+showpage';
+
+
+  open(MAP,">map.ps") or die("Could not open map.ps for writing ($!)");
+
+my $data='';
+my $imageMap='';
+
+# $maxEnd and $minStart are global variables!
+
+my $realClusterLength=$maxEnd-$minStart;
+
+my $clusterLength=400;
+
+my $factor=$clusterLength/$realClusterLength;
+
+my $lineStep=40;
+my $padding=20;
+my $arrowWidth=6;
+my $rulerWidth=3;
+my $color90='0 0 1';
+my $color50='0.8 0.8 1';
+my $fontColor='0 0 0';
+my $rulerColor='0 0 0';
+my $currY=$padding;
+
+
+foreach my $hit (@hits){
+
+my $realLength=$hit->{refSeqEnd}-$hit->{refSeqStart};
+my $length=$realLength*$factor;
+my $start=($hit->{refSeqStart}-$minStart)*$factor;
+
+my $color=$color50;
+my $command='rightarrow';
+
+$command='leftarrow' if ($hit->{refSeqStrand} eq '-');
+
+$color=$color90 if ($hit->{P}>=0.9);
+
+$start+=$padding;
+
+$data.="$start $currY $length $arrowWidth $color $command\n";
+
+my $tmpX1=int($start);
+my $tmpY1=int($currY);
+my $tmpX2=int($start+$length);
+my $tmpY2=int($currY+$arrowWidth);
+
+$imageMap.="<area shape=\"rect\" coords=\"$tmpX1,$tmpY1,$tmpX2,$tmpY2\" href=\"\#$hit->{hitID}\" alt=\"$hit->{hitID}\">\n";
+
+
+my $id=$hit->{hitID};
+$id=~s/window//;
+
+my $P=sprintf("%.2f",$hit->{P});
+
+my $ann="Window $id \($P\)";
+
+$data.="($ann) $start $currY $fontColor string\n";
+
+
+$currY+=$lineStep;
+
+}
+
+
+$data.="$padding $currY  $clusterLength $rulerWidth $rulerColor rightarrow";
+
+my $ann=$hits[0]->{refSeqName}.": $minStart - $maxEnd";
+
+$data.="($ann) $padding $currY $fontColor string\n";
+
+my $width=$clusterLength+2*$padding;
+
+$currY+=$lineStep+$padding;
+
+$psTemplate=~s/%height%/$currY/gs;
+$psTemplate=~s/%width%/$width/gs;
+$psTemplate=~s/%data%/$data/gs;
+
+print MAP $psTemplate;
+
+toPNG("map.ps");
+
+return $imageMap;
+
+}
+
+
+__END__
+
+=head1 NAME
+
+C<rnazCluster.pl> - Cluster RNAz hits and print a summary of the results.
+
+=head1 SYNOPSIS
+
+ rnazCluster.pl [options] [file]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<-c> X, B<--cutoff>=X
+
+Only consider hits with RNAz class probablility P>X (Default:B<0.5>)
+
+=item B<-w>, B<--windows>
+
+=item B<-l>, B<--loci>
+
+Set these flags to print information for ``windows" and/or ``loci" in
+the output. By default, both single windows and combined loci are
+printed.
+
+=item B<-d>, B<--header>
+
+Print a header explaining the fields of the output (see below for a
+detailed description of the fields).
+
+=item B<--html>
+
+Generates HTML formatted output of the results in the subdirectory
+C<results>. For this option to work you need to have installed
+ghostscript and a few programs from the ViennaRNA package. More
+precisely you need the following executables in your PATH: C<gs>,
+C<RNAalifold>, C<colorrna.pl>, C<coloraln.pl>. Alternatively you can
+adjust the locations of these programs directly in the
+C<rnazCluster.pl> script. Please note that if you use this option the
+program will get B<very slow> because the figures have to be
+generated. It is also important that you have run RNAz with the
+B<C<--show-gaps>> option!
+
+=item B<--html-dir>
+
+Name of directory where HTML pages are stored. Default: B<results>
+
+=item B<-v, --version>
+
+Prints version information and exits.
+
+=item B<-h, --help>
+
+Prints a short help message and exits.
+
+=item B<--man>
+
+Prints a detailed manual page and exits.
+
+=back
+
+=head1 DESCRIPTION
+
+C<rnazCluster.pl> reads RNAz output files and combines hits in
+overlapping windows to ``loci". It prints a summary of the windows
+and/or loci as a tabulator delimited text to the standard output. An
+explanation of the fields can be found below. See the user manual for
+a more detailed meaning of these values.
+
+To work properly, your RNAz output file needs to contain position
+information. This means there must have been genomic locations in your
+original alignments you scored with RNAz (i.e. MAF files with a
+reference sequence). Moreover, the original input alignments have to
+be B<ordered by the genomic location of the reference sequence>.
+
+If you want HTML output please see the notes for the C<--html> option
+above.
+
+=head1 FIELDS
+
+B<"Window" lines>
+
+=over 8
+
+=item 1. B<windowID>
+
+Consecutive numbered ID for each window
+
+=item 2. B<locusID>
+
+The locus which this window belongs to
+
+=item 3. B<sequenceID>
+
+Identifier of the sequence (e.g. human.chr1 or contig42)
+
+=item 4. B<start>
+
+Start position of the reference sequence in the window
+
+=item 5. B<end>
+
+End position of the reference sequence in the window
+
+=item 6. B<strand>
+
+Indicates if the reference sequence is from the positive or
+negative strand
+
+=item 7. B<N>
+
+Number of sequences in the alignment
+
+=item 8. B<columns>
+
+Number of columns in the alignment
+
+=item 9. B<identity>
+
+Mean pairwise identity of the alignment
+
+=item 10. B<meanMFE>
+
+Mean minimum free energy of the single sequences as
+calculated by the RNAfold algorithm
+
+=item 11. B<consensusMFE>
+
+``consensus MFE" for the alignment as calculated by
+the RNAalifold algorithm
+
+=item 12. B<energyTerm>
+
+Contribution to the consensus MFE which comes from the energy part of
+the RNAalifold algorithm
+
+=item 13. B<covarianceTerm>
+
+Contribution to the consensus MFE which comes from the covariance part
+of the RNAalifold algorithm
+
+=item 14. B<combPerPair>
+
+Number of different base combinations per predicted
+pair in the consensus seconary structure
+
+=item 15. B<z>
+
+Mean z-score of the sequences in the alignment
+
+=item 16. B<SCI>
+
+Structure conservation index for the alignment
+
+=item 17. B<decValue>
+
+Support vector machine decision value
+
+=item 18. B<P>
+
+RNA class probability as calculated by the SVM
+
+=back
+
+B<"Loci" lines>
+
+=over 8
+
+=item 1. B<locusID>
+
+Consecutive numbered ID for each locus
+
+=item 3. B<sequenceID>
+
+Identifier of the sequence (e.g. human.chr1 or contig42)
+
+=item 4. B<start>
+
+Start position of the reference sequence in the window
+
+=item 5. B<end>
+
+End position of the reference sequence in the window
+
+=item 6. B<strand>
+
+Indicates if the reference sequence is from the positive or
+negative strand
+
+=item 7. B<maxN>
+
+Maximum number of sequences in the alignments of this locus
+
+=item 9. B<maxIdentity>
+
+Maximum mean pairwise indentity in the alignments of this locus
+
+=item 9. B<maxP>
+
+Maximum RNA class probability in the alignments of this locus
+
+=item 9. B<minZ>
+
+Minimum z-score in the alignments of this locus.
+
+
+=back
+
+
+=head1 EXAMPLES
+
+ # rnazCluster.pl rnaz.out
+
+Parses and clusters the hits in the file C<rnaz.out> and prints loci
+and cluster information to the standard output.
+
+ # rnazCluster.pl -c 0.9 --html rnaz.out > results90.out
+
+Clusters all hits from the file C<rnaz.out> with P>0.9, writes the
+tab-delimited output to the file C<results90.out> and, at the same
+time, generates a website in a subdirectory called C<results>.
+
+=head1 AUTHORS
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+=cut
diff -ruN RNAz-2.1/perl/rnazFilter.pl patched_RNAz/perl/rnazFilter.pl
--- RNAz-2.1/perl/rnazFilter.pl	2009-08-11 19:29:07.000000000 +0200
+++ patched_RNAz/perl/rnazFilter.pl	2018-12-29 16:07:18.867810460 +0100
@@ -1,7 +1,7 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl -w
 
 # -*-Perl-*-
-# Last changed Time-stamp: <2009-02-23 18:28:47 ivo>
+# Last changed Time-stamp: <2018-12-29 16:07:18 fall>
 
 use strict;
 use FindBin;
diff -ruN RNAz-2.1/perl/rnazFilter.pl~ patched_RNAz/perl/rnazFilter.pl~
--- RNAz-2.1/perl/rnazFilter.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazFilter.pl~	2009-08-11 19:29:07.000000000 +0200
@@ -0,0 +1,296 @@
+#!/usr/bin/perl -w
+
+# -*-Perl-*-
+# Last changed Time-stamp: <2009-02-23 18:28:47 ivo>
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+
+my $count=0;
+my $help=0;
+my $man=0;
+my $version=0;
+
+GetOptions('count'=>\$count,
+		   'version'=>\$version,
+		   'v'=>\$version,
+		   'help'=>\$help,
+		   'man'=>\$man,
+		   'h'=>\$help ) or pod2usage(1);
+
+pod2usage(1) if $help;
+pod2usage(-verbose => 2) if $man;
+
+if ($version){
+  print "\nrnazFilter.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+# named column indices
+my %columnNames = (hitID          => 1,
+		   clusterID      => 2,
+		   seqID          => 3,
+		   start          => 4,
+		   end            => 5,
+		   strand         => 6,
+		   N              => 7,
+		   columns        => 8,
+		   identity       => 9,
+		   meanMFE        => 10,
+		   consensusMFE   => 11,
+		   energyTerm     => 12,
+		   covarianceTerm => 13,
+		   combPerPair    => 14,
+		   z              => 15,
+		   SCI            => 16,
+		   decValue       => 17,
+		   P              => 18);
+
+my %fields;
+
+my $filter=shift @ARGV;
+
+foreach my $field (keys %columnNames){
+  $filter=~s/$field/COL$columnNames{$field}/g;
+}
+$filter =~ s/(COL\d+)/\$fields{$1}/g;
+
+# memorize column numbers
+my @columnIDs = ($filter=~ m/COL(\d+)/g);
+
+my $nCluster=0;
+my $nWindow=0;
+
+my $currClusterLine='';
+
+foreach my $line (<>){
+
+  next if $line=~/^\s?\#/;
+  next if $line=~/^\s+$/;
+
+  if ($line=~/^\s?locus\d+/){
+	$currClusterLine=$line;
+	next;
+  }
+
+  my @F = split(/\s+/,$line);
+  foreach my $id (@columnIDs) {
+      $fields{'COL'.$id} = $F[$id-1];
+  }
+
+  local $SIG{__WARN__} =
+	sub {
+	  print STDERR ("You have an error in your filter statement.\n");
+	  exit(1);
+	};
+  local $SIG{__DIE__}=$SIG{__WARN__};
+
+  my $flag=eval $filter;
+
+  if ($flag){
+	if ($currClusterLine){
+	  print $currClusterLine if (!$count);
+	  $currClusterLine='';
+	  $nCluster++;
+	}
+	print $line if (!$count);
+	$nWindow++;
+  }
+}
+
+if ($count){
+  print "Loci: $nCluster\n";
+  print "Windows: $nWindow\n";
+}
+
+__END__
+
+=head1 NAME
+
+C<rnazFilter.pl> - Filter output files from C<rnazCluster.pl> by different criteria.
+
+=head1 SYNOPSIS
+
+ rnazFilter.pl [options] "filter" [file]
+
+=head1 OPTIONS
+
+=over 8
+
+
+=item B<-c, --count>
+
+Count the windows/loci instead of printing them.
+
+=item B<-v, --version>
+
+Prints version information and exits.
+
+=item B<-h, --help>
+
+Print a short help message and exits.
+
+=item B<--man>
+
+Prints a detailed manual page and exits.
+
+=back
+
+=head1 DESCRIPTION
+
+C<rnazFilter.pl> reads tab-delimited data files as generated by
+C<rnazCluster.pl>. For each window a filter is applied and if the
+filter is passed the window and the corresponding locus are printed
+out. Thus, you get all loci with at least one window that fulfills your
+filter criteria.
+
+The mandatory filter statement is given within double quotes (" ") and
+can contain comparison/logical statements and field identifiers as
+listed below.
+
+Technically, the statement is directly interpreted by Perl, so you can
+use anything which works in Perl. The same caveats apply, for example:
+If you want compare numbers you must use C<==>, if you compare strings
+you have to use C<eq>.
+
+Please note: I<everything> you put in the filter statement is
+evaluated by Perl. This can be potentially harmful, so take care.
+
+=head1 FIELDS
+
+=over 8
+
+=item 1. B<windowID>
+
+Consecutive numbered ID for each window
+
+=item 2. B<locusID>
+
+The locus which this window belongs to
+
+=item 3. B<seqID>
+
+Identifier of the sequence (e.g. human.chr1 or contig42)
+
+=item 4. B<start>
+
+Start position of the reference sequence in the window
+
+=item 5. B<end>
+
+End position of the reference sequence in the window
+
+=item 6. B<strand>
+
+Indicates if the reference sequence is from the positive or
+negative strand
+
+=item 7. B<N>
+
+Number of sequences in the alignment
+
+=item 8. B<columns>
+
+Number of columns in the alignment
+
+=item 9. B<identity>
+
+Mean pairwise identity of the alignment
+
+=item 10. B<meanMFE>
+
+Mean minimum free energy of the single sequences as
+calculated by the RNAfold algorithm
+
+=item 11. B<consensusMFE>
+
+``Consensus MFE" for the alignment as calculated by
+the RNAalifold algorithm
+
+=item 12. B<energyTerm>
+
+Contribution to the consensus MFE which comes from the
+energy part of the RNAalifold algorithm
+
+=item 13. B<covarianceTerm>
+
+Contribution to the consensus MFE which comes from
+the covariance part of the RNAalifold algorithm
+
+=item 14. B<combPerPair>
+
+Number of different base combinations per predicted
+pair in the consensus seconary structure
+
+=item 15. B<z>
+
+Mean z-score of the sequences in the alignment
+
+=item 16. B<SCI>
+
+Structure conservation index for the alignment
+
+=item 17. B<decValue>
+
+Support vector machine decision value
+
+=item 18. B<P>
+
+RNA class probability as calculated by the SVM
+
+=item 19. B<COL#>
+
+Specify a particular column by its index #. First column has index 1.
+e.g. C<COL18E<gt>0.9> is equivalent to C<PE<gt>0.9>
+
+=back
+
+=head1 OPERATORS
+
+=over 8
+
+=item B<E<lt>,E<gt>>
+
+Less than, greater than
+
+=item B<==>
+
+Equals numerically
+
+=item B<eq>
+
+Equals (strings)
+
+=item B<=~/regex/>
+
+Matches regular expression.
+
+=item B<(, ), and, or, not>
+
+Logical operators and grouping
+
+=back
+
+
+=head1 EXAMPLES
+
+ # rnazFilter.pl "P>0.9 and z<-3 and seqID~=/chr13/" results.dat
+
+Gives you all clusters with windows with P>0.9 and z<-3 on chromosome
+13.
+
+ # rnazFilter.pl -c "P>0.9" results.dat
+
+Counts all windows/loci with P>0.9.
+
+
+=head1 AUTHOR
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+=cut
diff -ruN RNAz-2.1/perl/rnazIndex.pl patched_RNAz/perl/rnazIndex.pl
--- RNAz-2.1/perl/rnazIndex.pl	2009-08-11 19:29:07.000000000 +0200
+++ patched_RNAz/perl/rnazIndex.pl	2018-12-29 16:08:38.489723488 +0100
@@ -1,7 +1,7 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl -w
 
 # -*-Perl-*-
-# Last changed Time-stamp: <2009-02-23 18:32:12 ivo>
+# Last changed Time-stamp: <2018-12-29 16:08:38 fall>
 
 use strict;
 use FindBin;
diff -ruN RNAz-2.1/perl/rnazIndex.pl~ patched_RNAz/perl/rnazIndex.pl~
--- RNAz-2.1/perl/rnazIndex.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazIndex.pl~	2009-08-11 19:29:07.000000000 +0200
@@ -0,0 +1,505 @@
+#!/usr/bin/perl -w
+
+# -*-Perl-*-
+# Last changed Time-stamp: <2009-02-23 18:32:12 ivo>
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+use vars qw/%COLS $COLIDX $COLNAME $COLDATA/;
+
+$COLIDX=-1;
+$COLNAME = '';
+$COLDATA = '';
+
+my $gff=0;
+my $bed=0;
+my $fasta=0;
+my $clusters=0;
+my $hits=0;
+my $help='';
+my $ucsc='';
+my $version=0;
+my $man=0;
+my $html='';
+my $seqDir='';
+my $forward=0;
+my $reverse=0;
+
+GetOptions('gff' => \$gff,
+	   'g' => \$gff,
+	   'bed' => \$bed,
+	   "col=s"     => sub { my ($colidx, $colname) = split(/:/, $_[1], 2);
+				$COLS{$colidx} = $colname },
+	   'fasta'     => \$fasta,
+	   'f'         => \$fasta,
+	   'b'         => \$bed,
+	   'loci'      => \$clusters,
+	   'forward'   => \$forward,
+	   'reverse'   => \$reverse,
+	   'l'         => \$clusters,
+	   'windows'   => \$hits,
+	   'w'         => \$hits,
+	   'ucsc'      => \$ucsc,
+	   'html'      => \$html,
+	   'seq-dir:s' => \$seqDir,
+	   'version'   => \$version,
+	   'v'         => \$version,
+	   'help'      => \$help,
+	   'man'       => \$man,
+	   'h'         => \$help
+	   ) or pod2usage(1);
+
+pod2usage(1) if $help;
+pod2usage(-verbose => 2) if $man;
+
+if ($version){
+  print "\nrnazIndex.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+($clusters)=1 if (!$clusters and !$hits);
+$forward=1 if (!$forward and !$reverse);
+$bed=1 if (!$bed and !$gff and !$fasta);
+
+my ($seqID, $name, $start, $end, $P, $strand);
+
+$,="\t";
+
+my $isCluster=0;
+my $isHit=0;
+
+if (($fasta) and (not -d $seqDir)){
+
+  print STDERR "ERROR: Sequence directory '$seqDir' does not exist.\n";
+  exit(1);
+}
+
+
+if ($html){
+
+    print << 'EOF_HEADER';
+    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+	<html>
+	<head>
+	<title>Index</title>
+	<meta http-equiv="Content-Type"
+	      content="text/html;
+	      charset=iso-8859-1">
+	<STYLE type="text/css">
+	TABLE {border-spacing:1px;
+	       background-color:#000000;}
+	TD {font-size:10pt;
+	    padding:7px;
+	    font-family:helvetica,arial,impact,sans-serif;
+	    text-align:center}
+	TH {font-size:10pt;
+	    background-color:#333399;
+	    color:#FFFFFF;
+	    padding:7px;
+	    font-family:helvetica,arial,impact,sans-serif;}
+	.darkcell {background-color:#d4d9ff;}
+	.lightcell {background-color:#e5e8ff;}
+	P {font-size:11pt;
+	   font-family:helvetica,arial,impact,sans-serif;}
+	H1 {font-size:20pt;
+	    color:#333399;
+	    text-align:center;
+	    font-family:helvetica,arial,impact,sans-serif;
+	    padding:10px;}
+	H2 {color:#FFFFFF;
+	    background-color:#333399;
+	    width:auto;
+	    padding:3px;
+	    border-width:normal;
+	    font-size:14pt;
+	    font-family:helvetica,arial,impact,sans-serif;}
+       IMG {border-style:solid;
+	    border-width:thin;
+	    border-color:black;}
+       PRE {font-size:10pt;
+	    font-family:courier,monospace;
+	    border-style:solid;
+	    border-width:thin;
+	    padding:5px;background-color:#e5e8ff;}
+       </STYLE>
+       </head>
+       <body>
+       <h1>Index</h1>
+       <table>
+       <tr>
+       <th>Locus ID</th>
+       <th>Seq. ID</th>
+       <th>Location</th>
+       <th>Custom annotation</th>
+       <th>Window ID</th>
+       <th>Location</th>
+       <th>Strand</th>
+       <th>N</th>
+       <th>Length</th>
+       <th>Mean pairwise ID</th>
+       <th>z</th><th>SCI</th>
+       <th>P</th>
+EOF_HEADER
+# add costum columns to table header
+foreach my $key (sort keys %COLS) {
+  print "<th>$COLS{$key}</th>\n";
+}
+print "</tr>\n";
+
+  my @clusters=();
+  my %hits=();
+
+  my $currCluster='';
+
+  while (my $line=<>){
+	if ($line=~/^\s?(locus\d+)/){
+	  $currCluster=$1;
+	  push @clusters, $line;
+	}
+	elsif ($line=~/^\s?window\d+/){
+	  if (exists $hits{$currCluster}){
+		push @{$hits{$currCluster}},$line;
+	  } else {
+		$hits{$currCluster}=[$line];
+	  }
+	}
+  }
+
+  my $cellColor='darkcell';
+
+  foreach my $cluster (@clusters){
+	#print $cluster;
+	my @fields=split(/\t/,$cluster);
+	($seqID, $start, $end, my $name, $P)=
+	  ($fields[1],$fields[2],$fields[3],$fields[0],$fields[6]);
+
+	my @customAnn=();
+
+	my $i=8;
+
+	while (defined $fields[$i]){
+	  push @customAnn, $fields[$i]; # if $COLIDX != $i+1;
+	  $i++;
+	}
+	my $customAnn="&ndash;";
+
+	if (@customAnn){
+	  $customAnn=join("<br>",@customAnn);
+	}
+
+	my $clusterSize=@{$hits{$name}};
+
+	my $clusterName=$name;
+
+	$clusterName=~s/locus//;
+
+	my $location=niceNumber($start)." &ndash; ".niceNumber($end);
+
+	print "<tr><td rowspan=$clusterSize class=\"$cellColor\"><a href=\"locus$clusterName/index.html\">$clusterName</a></td>";
+	print "<td rowspan=$clusterSize class=\"$cellColor\">$seqID</td>";
+	print "<td rowspan=$clusterSize class=\"$cellColor\">$location</td>";
+	print "<td rowspan=$clusterSize class=\"$cellColor\">$customAnn</td>";
+
+	my $isFirst=1; # do not print <tr> if first entry
+	foreach my $hit (@{$hits{$name}}){
+	  my @fields=split(/\t/,$hit);
+	  ($start, $end, $name, $strand, my $N, my $L, my $identity, my $z, my $SCI, my $P)=
+		($fields[3],$fields[4],$fields[0],$fields[5],$fields[6],$fields[7],$fields[8],$fields[14],$fields[15],$fields[17]);
+
+	  $COLDATA = $fields[$COLIDX-1] if $COLIDX >0;
+
+	  $name=~s/window//;
+
+	  $location=niceNumber($start)." &ndash; ".niceNumber($end);
+
+	  print "<tr>" if not $isFirst;
+	  $isFirst=0;
+	  print
+	      "<td class=\"$cellColor\"><a href=\"locus$clusterName/index.html\#window$name\">$name</a></td>",
+	      "<td class=\"$cellColor\">$location</td>",
+	      "<td class=\"$cellColor\">$strand</td>",
+	      "<td class=\"$cellColor\">$N</td>",
+	      "<td class=\"$cellColor\">$L</td>",
+	      "<td class=\"$cellColor\">$identity</td>",
+	      "<td class=\"$cellColor\">$z</td>",
+	      "<td class=\"$cellColor\">$SCI</td>",
+	      "<td class=\"$cellColor\">$P</td>";
+	  # add values to custom column
+	  foreach my $key (sort keys %COLS) {
+	    my $value = (defined $fields[$key-1])
+		? $fields[$key-1] :'&nbsp;';
+	    print
+		"<td class=\"$cellColor\">$value</td>";
+	  }
+	  print "</tr>\n";
+	}
+
+	if ($cellColor eq 'darkcell'){
+	  $cellColor='lightcell';
+	} else {
+	  $cellColor='darkcell';
+	}
+  }
+
+my $timestamp=localtime;
+
+print "</table><hr><p>Generated by <tt>rnazIndex.pl</tt> (part of <tt><a href=\"http://www.tbi.univie.ac.at/~wash/RNAz\">RNAz</a> $RNAz::rnazVersion</tt>) on $timestamp</p></body></html>";
+
+}
+else {
+
+
+while (my $line=<>){
+
+  next if $line=~/^\s?\#/;
+  next if $line=~/^\s+$/;
+
+  my @fields=split(/\t/,$line);
+  chomp(@fields);
+
+  if ($line=~/^\s?locus\d+/){
+	$isCluster=1;$isHit=0;
+	($seqID, $start, $end, $name, $P)=
+	  ($fields[1],$fields[2],$fields[3],$fields[0],$fields[6]);
+
+  } elsif ($line=~/^\s?window\d+/){
+	$isHit=1;$isCluster=0;
+	($seqID, $start, $end, $name, $P,$strand)=
+	  ($fields[2],$fields[3],$fields[4],$fields[0],$fields[16],$fields[5]);
+  }
+
+  if ($ucsc){
+	if ($seqID=~/^(.*)\.(.*)$/){
+	  $seqID=$2;
+	}
+	#if ($P<0.5){
+	#  $P=0;
+	#} elsif (($P>=0.5) and ($P<0.9)){
+	#  $P=500;
+	#} elsif ($P>=0.9){
+	#  $P=1000;
+	#}
+	$P=int($P*1000);
+  }
+
+  if ($bed){
+	if ($isCluster and $clusters){
+	  print $seqID,$start,$end,$name,$P,"\n";
+	}
+	if ($isHit and $hits){
+	  print $seqID,$start,$end,$name,$P,$strand,"\n";
+	}
+  }
+
+  if ($gff){
+	if ($isCluster and $clusters){
+	  print $seqID,"RNAz","structuredRNA",$start+1,$end,$P,".","id \"$name\"","\n";
+	}
+	if ($isHit and $hits){
+	  print $seqID,"RNAz","structuredRNA",$start+1,$end,$P,$strand,"id \"$name\"","\n";
+	}
+  }
+
+  if ($fasta){
+	if ($isCluster and $clusters){
+
+	  if ($forward) {
+		$strand='+';
+	  } else {
+		$strand='-';
+	  }
+
+	  print ">$name ($seqID:$start..$end,$strand)\n";
+	  my $seq=extractSeq($seqID,$start,$end);
+	  $seq=~s/(.{60})/$1\n/g;
+	  chomp($seq);
+	  print $seq,"\n";
+	}
+	if ($isHit and $hits){
+	  print ">$name ($seqID:$start..$end,$strand)\n";
+	  my $seq=extractSeq($seqID,$start,$end,$strand);
+	  $seq=~s/(.{60})/$1\n/g;
+	  chomp($seq);
+	  print $seq,"\n";
+	}
+  }
+}
+}
+
+
+sub extractSeq{
+
+  (my $chrom, my $start, my $end, my $strand)=@_;
+
+  my @guess=($chrom);
+
+  if ($chrom =~ /^(.*)\.(.*)$/){
+	push @guess,$2;
+  }
+
+  my $tmp=$#guess;
+  foreach my $i (0..$tmp) {
+	push @guess,$guess[$i].".fa";
+	push @guess,$guess[$i].".fasta";
+  }
+
+  my $realFile='';
+
+  foreach my $file (@guess){
+	if (-e "$seqDir/$file"){
+	  $realFile="$seqDir/$file";
+	  last;
+	}
+  }
+
+  if (not $realFile){
+
+	my @string=();
+
+	foreach my $entry (@guess){
+	  push @string, "\"$seqDir/$entry\"";
+	}
+	my $tmp=join(' or ',@string);
+	print STDERR "No sequence data for '$chrom' found.\n";
+	print STDERR "I could not find files named: $tmp";
+	return ("");
+  } else {
+	return getSeq($realFile, $start, $end, $strand);
+  }
+
+}
+
+__END__
+
+=head1 NAME
+
+C<rnazIndex.pl> - Convert data files as generated by C<rnazCluster.pl>
+to different formats.
+
+=head1 SYNOPSIS
+
+ rnazIndex.pl [options] [file]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<-g, --gff>
+
+Generate GFF formatted output.
+
+=item B<-b, --bed>
+
+Generate BED formatted output.
+
+=item B<-c #:LABEL, --col #:LABEL>
+
+Append a column named LABEL to the HTML-table holding the data from
+the input file column with index #. e.g. C<rnazIndex.pl --html --col
+19:Alifoldz --col 20:RNAmicro annotated.dat>
+
+
+=item B<-f, --fasta>
+
+Get sequences in FASTA format for loci or windows. See options
+C<--seq-dir>, C<--forward>, C<--reverse>!
+
+=item B<--seq-dir>
+
+Directory with sequence files. You only need this for FASTA output
+(see option C<--fasta>). The files should be named with the sequence
+identifier and the extension C<.fa> or C<.fasta>. If your identifier
+in your input file is for example C<contig100> then you should have a
+file named C<contig100.fa>. (If your identifier is of the form
+``assembly.chromosome" as for example used by UCSC alignments, it is
+also possible to name the file C<chr22.fa> for a sequence identifier
+C<hg17.chr22>).
+
+=item B<--forward, --reverse>
+
+Only relevant for FASTA output (see option C<--fasta>). You can set if
+you want the forward or reverse complement of the sequence
+corresponding to a locus. Since loci don't have strand information you
+might consider both strands for further analysis. Windows have strand
+information, so if you export windows as FASTA these options are
+ignored.
+
+=item B<--ucsc>
+
+In UCSC MAF alignment files it is common to use sequence identifiers
+like for example ``hg17.chr22". However, in BED are usually specific
+for a given assembly and therefore only ``chr22" is used in the BED
+files. With this option you change any identifier of the form ``X.Y"
+into ``Y". Moreover, the scores are multiplied by 1000 and rounded to
+integers since the UCSC genome browser expects scores between 0 and
+1000.
+
+=item B<-l, --loci>
+
+Use the locus information to generate the lines for the GFF and BED
+files. This is the default.
+
+=item B<-w, --windows>
+
+Print the "windows" and not the "loci". Probably, rarely used
+function.
+
+=item B<--html>
+
+With this option you get a HTML table which links to the the HTML
+pages which you can create by using the C<--html> option in
+C<rnazCluster.pl>. Redirect the output to some file which resides in
+the C<results> directory created by C<rnazCluster.pl> and open the
+file with your favourite web-browser.
+
+=item B<-h, --help>
+
+Prints a short help message and exits.
+
+=item B<--man>
+
+Prints a detailed manual page and exits.
+
+=back
+
+=head1 DESCRIPTION
+
+C<rnazIndex.pl> reads tab-delimited data files as generated by
+C<rnazCluster.pl> and converts them to GFF, BED or HTML formatted
+files.
+
+GFF is the most widely used annotation file format and supported by
+many programs and systems
+(http://www.sanger.ac.uk/Software/formats/GFF).
+
+BED is the native annotation file format used by the UCSC genome
+browser (http://genome.ucsc.edu).
+
+=head1 EXAMPLES
+
+ # rnazIndex.pl --gff results.dat > results.gff
+
+Converts the C<results.dat> file to GFF format.
+
+ # rnazIndex.pl --ucsc --bed results.dat > results.bed
+
+Create UCSC style BED format.
+
+ # rnazIndex.pl --html results.dat > results/index.html
+
+Generates HTML formatted table.
+
+ # rnazIndex.pl --forward --fasta --seq-dir=seq results.dat
+
+Exports sequences in FASTA format.
+
+=head1 AUTHOR
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+=cut
diff -ruN RNAz-2.1/perl/rnazMAF2BED.pl patched_RNAz/perl/rnazMAF2BED.pl
--- RNAz-2.1/perl/rnazMAF2BED.pl	2009-08-11 19:29:07.000000000 +0200
+++ patched_RNAz/perl/rnazMAF2BED.pl	2018-12-29 16:08:47.299685860 +0100
@@ -1,4 +1,4 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl -w
 
 # $Id: rnazMAF2BED.pl,v 1.3 2008-01-24 10:26:45 wash Exp $
 
diff -ruN RNAz-2.1/perl/rnazMAF2BED.pl~ patched_RNAz/perl/rnazMAF2BED.pl~
--- RNAz-2.1/perl/rnazMAF2BED.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazMAF2BED.pl~	2009-08-11 19:29:07.000000000 +0200
@@ -0,0 +1,187 @@
+#!/usr/bin/perl -w
+
+# $Id: rnazMAF2BED.pl,v 1.3 2008-01-24 10:26:45 wash Exp $
+
+
+#TODO: handle UCSC style a la: hg17.chr17
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+
+
+my $help='';
+my $seqID='';
+my $version=0;
+my $cluster=0;
+my $man='';
+
+GetOptions('--seq-id=s'=>\$seqID,
+		   '-s=s'=>\$seqID,
+		   '--cluster'=>\$cluster,
+		   '-c'=>\$cluster,
+		   'version'=>\$version,
+		   'v'=>\$version,
+		   'help'=>\$help,
+		   'man'=>\$man,
+		   'h'=>\$help
+		  ) or pod2usage(1);
+
+pod2usage(1) if $help;
+pod2usage(-verbose => 2) if $man;
+
+if ($version){
+  print "\nrnazMAF2BED.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+if (!$cluster){
+
+  while (my $line=<>){
+
+	chomp($line);
+
+	if ($line=~/^s\s+(.+?)\s+(\d+)\s+(\d+).*/){
+
+	  my ($id,$start,$length)=($1,$2,$3);
+
+	  # Use first ID in first alignment as reference if no --seq-id is
+	  # given
+	  if (not $seqID){
+		if ($id=~/(.*)\..*/){
+		  $seqID=$1;
+		} else {
+		  $seqID=$id;
+		}
+	  }
+
+	  my $end=$start+$length;
+
+	  if ($id=~/$seqID/){
+		print "$id\t$start\t$end\n";
+	  }
+	}
+  }
+} else {
+
+  my ($id,$start,$length);
+  my ($currName,$currStart,$currEnd,$currStrand);
+  my ($prevName,$prevStart,$prevEnd);
+  my $minStart=99000000;
+  my $maxEnd=0;
+  $prevStart=0; $prevEnd=0; $prevName='';
+
+  while (my $line=<>){
+
+	chomp($line);
+
+	if ($line=~/^s\s+(.+?)\s+(\d+)\s+(\d+).*/){
+
+	  ($id,$start,$length)=($1,$2,$3);
+
+	  # Use first ID in first alignment as reference if no --seq-id is
+	  # given
+	  if (not $seqID){
+		if ($id=~/(.*)\..*/){
+		  $seqID=$1;
+		} else {
+		  $seqID=$id;
+		}
+	  }
+
+	  next if !($id=~/$seqID/);
+
+	  $currName=$id;
+	  $currStart=$start;
+	  $currEnd=$start+$length;
+
+	} else {
+
+	  next;
+
+	}
+
+	if (!(($currName eq $prevName) and ($currStart <= $prevEnd))){
+
+	  if ($maxEnd!=0){
+		
+		print "$id\t$minStart\t$maxEnd\n";
+		
+		$minStart=999000000;
+		$maxEnd=0;
+
+	  }
+	}
+	$minStart=$currStart if ($currStart<$minStart);
+	$maxEnd=$currEnd if ($currEnd>$maxEnd);
+	
+	($prevName,$prevStart,$prevEnd)=($currName,$currStart,$currEnd);
+  }
+}
+	
+
+__END__
+
+=head1 NAME
+
+C<rnazMAF2BED.pl> - Convert sequence information from MAF formatted
+multiple sequence alignment to a BED style annotation format.
+
+=head1 SYNOPSIS
+
+ rnazMAF2BED.pl [options] [file]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<-s, --seq-id>
+
+Specify the sequence identifier of the sequence which should be used
+as a reference to create the output. Use for example C<hg17> if you
+want to get all sequences containing C<hg17> in the idenitfier
+(e.g. C<hg17.chr10>, C<hg17.chr22>,...). If this option is omitted,
+the first sequence identifier of the first sequence in the first
+alignment block is used.
+
+=item B<-c, --cluster>
+
+Combine overlapping alignments and report non-overlapping
+regions in the BED output. 
+
+=item B<-v, --version>
+
+Prints version information and exits.
+
+=item B<-h, --help>
+
+Prints a short help message and exits.
+
+=item B<--man>
+
+Prints a detailed manual page and exits.
+
+=back
+
+=head1 DESCRIPTION
+
+This simple programs extracts the position information for a given
+sequence out of a MAF alignment and outputs it in a BED style
+annotation format.
+
+=head1 EXAMPLES
+
+ # rnazMAF2BED.pl -s hg17 some.maf
+
+Get the regions of the hg17 sequences in the alignment C<some.maf>.
+
+=head1 AUTHORS
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+=cut
+
diff -ruN RNAz-2.1/perl/rnazRandomizeAln.pl patched_RNAz/perl/rnazRandomizeAln.pl
--- RNAz-2.1/perl/rnazRandomizeAln.pl	2009-08-11 19:29:07.000000000 +0200
+++ patched_RNAz/perl/rnazRandomizeAln.pl	2018-12-29 16:08:59.382634248 +0100
@@ -1,4 +1,4 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl -w
 
 # $Id: rnazRandomizeAln.pl,v 1.2 2006/03/24 15:43:14 wash Exp $
 
diff -ruN RNAz-2.1/perl/rnazRandomizeAln.pl~ patched_RNAz/perl/rnazRandomizeAln.pl~
--- RNAz-2.1/perl/rnazRandomizeAln.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazRandomizeAln.pl~	2009-08-11 19:29:07.000000000 +0200
@@ -0,0 +1,169 @@
+#!/usr/bin/perl -w
+
+# $Id: rnazRandomizeAln.pl,v 1.2 2006/03/24 15:43:14 wash Exp $
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+
+
+my $level=2;
+my $window=120;
+my $slide=120;
+my $version=0;
+my $help='';
+my $man=0;
+
+GetOptions('window:i' => \$window,
+		   'w:i' => \$window,
+		   'slide:i' => \$slide,
+		   's:i' => \$slide,
+		   'level:i' => \$level,
+		   'l:i' => \$level,
+		   'version'=>\$version,
+		   'v'=>\$version,
+		   'help'=>\$help,
+		   'man'=>\$man,
+		   'h'=>\$help
+		  ) or pod2usage(1);
+
+pod2usage(1) if $help;
+pod2usage(-verbose => 2) if $man;
+
+if ($version){
+  print "\nrnazRandomizeAln.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+
+my $fileName=shift @ARGV;
+my $fh;
+
+if (!defined $fileName){
+  $fh=*STDIN;
+} else {
+  open($fh,"<$fileName") || die("Could not open file $fileName ($!)");
+}
+
+my $alnFormat=checkFormat($fh);
+
+while (my $alnString=getNextAln($alnFormat,$fh)){
+
+  my $fullAln=parseAln($alnString,$alnFormat);
+
+  my @shuffledWindows=();
+	
+  my $length=length($fullAln->[0]->{seq});
+  my $sliceStart=0;
+  my $sliceEnd=0;
+  while ($sliceStart<$length){
+	$sliceEnd=$sliceStart+$window;
+	$sliceEnd=$length if ($sliceEnd>$length);
+	my $slice=sliceAlnByColumn($fullAln,$sliceStart,$sliceEnd);
+	$slice=shuffleAln($slice,$level);
+	push @shuffledWindows,$slice;
+	$sliceStart+=$slide;
+	last if ($sliceEnd==$length);
+  }
+
+  foreach my $entry (@{$fullAln}){
+	$entry->{seq}='';
+  }
+  foreach my $w (@shuffledWindows){
+	foreach my $i (0..@{$fullAln}-1){
+	  $fullAln->[$i]->{seq}.=$w->[$i]->{seq};
+	}
+  }
+  print formatAln($fullAln,$alnFormat);
+}
+
+__END__
+
+=head1 NAME
+
+C<rnazRandomizeAln.pl> - Randomize alignments by shuffling the columns.
+
+=head1 SYNOPSIS
+
+ rnazRandomizeAln.pl [options] [file]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<-w> N, B<--window>=N
+
+=item B<-s> N, B<--slide>=N
+
+Long alignment blocks should be shuffled locally in order to maintain
+local characteristics of the alignment. Therefore alignments can be
+shuffled in windows. You can specify here the size of a window and the
+offset. Defaults are window=120 and slide=120, i.e. the alignments are
+shuffled in non-overlapping windows of 120 columns.
+
+=item B<-l> N, B<--level>=N
+
+The shuffling algorithm tries to mantain local conservation patterns,
+i.e. it shuffles only columns of the same degree of conservation. This
+becomes limiting if you have many sequences in your
+alignment. Therfore you can choose the level of ``coarse graining" with
+this option.
+
+To decide which columns have the same degree of conservation, the mean
+pairwise identity (MPI) of each column is calculated and finally only
+columns of the same value are shuffled. You can adjust the rounding of
+the MPI and thus the ``coarse graining" level with this option. If you
+have two columns with say 0.52 and 0.48 MPI you get:
+
+level 0: 1 and 0
+
+level 1: 50 and 50
+
+level 2: 52 and 48
+
+So on level 0 you only have ``conserved" (MPI > 0.5) and ``non-conserved"
+(MPI E<lt> 0.5) columns while on level 2 you need almost exactly the same
+MPI to shuffle two columns.
+
+Default value is 2.
+
+=item B<-v, --version>
+
+Prints version information and exits.
+
+=item B<-h --help>
+
+Prints a brief help message and exits.
+
+=item B<--man>
+
+Prints the manual page and exits.
+
+=back
+
+=head1 DESCRIPTION
+
+C<rnazRandomizeAln.pl> reads a multiple sequence alignment in Clustal
+W or MAF format and returns a randomized version in the same
+format. The program uses the algorithm described in Washietl &
+Hofacker, J. Mol. Biol. 342(1):19 (2004). It generates alignments of
+the same length, the same base composition, the same gap pattern, the
+same overall conservation and the same local conservation patterns
+(see also option B<--level>).
+
+=head1 EXAMPLES
+
+ # rnazRandomizeAln.pl -l 1 some.maf > random.maf
+
+Randomizes the file C<some.maf> using a less stringent parameter for
+maintaining conservation patterns.
+
+=head1 AUTHORS
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+=cut
diff -ruN RNAz-2.1/perl/rnazSelectSeqs.pl patched_RNAz/perl/rnazSelectSeqs.pl
--- RNAz-2.1/perl/rnazSelectSeqs.pl	2009-08-11 19:29:07.000000000 +0200
+++ patched_RNAz/perl/rnazSelectSeqs.pl	2018-12-29 16:09:27.782512952 +0100
@@ -1,4 +1,4 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl -w
 
 # $Id: rnazSelectSeqs.pl,v 1.3 2006/03/24 15:43:14 wash Exp $
 
diff -ruN RNAz-2.1/perl/rnazSelectSeqs.pl~ patched_RNAz/perl/rnazSelectSeqs.pl~
--- RNAz-2.1/perl/rnazSelectSeqs.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazSelectSeqs.pl~	2009-08-11 19:29:07.000000000 +0200
@@ -0,0 +1,159 @@
+#!/usr/bin/perl -w
+
+# $Id: rnazSelectSeqs.pl,v 1.3 2006/03/24 15:43:14 wash Exp $
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+
+my $maxSeqs=6;
+my $minSeqs=2;
+my $nSamples=1;
+my $maxID=99;
+my $optID=80;
+my $noReference=0;
+my $help=0;
+my $version=0;
+my $man=0;
+
+
+GetOptions('num-seqs:i' => \$maxSeqs,
+		   'n:i' => \$maxSeqs,
+		   'min-seqs:i' => \$minSeqs,
+		   'num-samples:i' => \$nSamples,
+		   'a:i' => \$nSamples,
+		   'max-id:i' => \$maxID,
+		   'opt-id:i' => \$optID,
+		   'i:i' => \$optID,
+		   'no-reference' => \$noReference,
+		   'x' => \$noReference,
+		   'help'=>\$help,
+		   'man'=>\$man,
+		   'h'=>\$help,
+		   'version'=>\$version,
+		   'v'=>\$version,
+		  ) or pod2usage(1);
+
+pod2usage(1) if $help;
+pod2usage(-verbose => 2) if $man;
+
+if ($version){
+  print "\nrnazSelectSeqs.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+
+my $fileName=shift @ARGV;
+my $fh;
+
+if (!defined $fileName){
+  $fh=*STDIN;
+} else {
+  open($fh,"<$fileName") || die("Could not open file $fileName ($!)");
+}
+
+my $alnFormat=checkFormat($fh);
+
+while (my $alnString=getNextAln($alnFormat,$fh)){
+
+  my $aln=parseAln($alnString,$alnFormat);
+  #print formatAln($aln,$alnFormat);
+
+  my $keepFirst=1;
+  $keepFirst=0 if ($noReference);
+
+  my $samples=pruneAln(alnRef=>$aln,
+					   maxN=>$maxSeqs,
+					   minN=>$minSeqs,
+					   optSim=>$optID/100,
+					   maxID=>$maxID/100,
+					   keepfirst=>$keepFirst,
+					   numAln=>$nSamples);
+
+  foreach $aln (@$samples){
+	print formatAln($aln,$alnFormat);
+  }
+}
+__END__
+
+=head1 NAME
+
+C<rnazSelectSeqs.pl> - Select subsets of sequences from an alignment.
+
+=head1 SYNOPSIS
+
+ rnazSelectSeqs.pl [options] [file]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<-n> N, B<--num-seqs>=N
+
+Number of sequences in the output alignment(s). (Default:B<6>)
+
+=item B<-a> N, B<--num-samples>=N
+
+Number of output alignments (Default: B<1>)
+
+=item B<-i> X, B<--opt-id>=X
+
+The resulting alignment(s) is (are) optimized for this value of mean
+pairwise identity (in percent, default: B<80>)
+
+=item B<--max-id>=X
+
+Sequences from pairs with pairwise identity higher than X% are removed
+(default: B<99>, i.e. only almost identical sequences are removed)
+
+=item B<-x, --no-reference>
+
+By default the first sequence (=reference sequence) is always present
+in the output alignment(s). If you do not care having it removed, set
+this flag.
+
+=item B<-v, --version>
+
+Prints version information and exits.
+
+=item B<-h, --help>
+
+Prints a short help message and exits.
+
+=item B<--man>
+
+Prints a detailed manual page and exits.
+
+=back
+
+=head1 DESCRIPTION
+
+C<rnazSelectSeqs.pl> reads a multiple sequence alignment in C<Clustal
+W> or C<MAF> format and returns an alignment in the same format with a
+user specified number of sequences. The subset is greedily optimized
+for a user specified mean pairwise identity. There are options to
+removes sequences which are too similar. It is also possible to sample
+more than one alignment. The program uses a simple heuristic to
+accomplish that.
+
+=head1 EXAMPLES
+
+ # rnazSelectSeqs.pl -n 4 -a 3 miRNA.maf
+
+Samples three subsets of four sequences from the alignment C<miRNA.maf>.
+
+ # rnazSelectSeqs.pl -n 5 -i 70 miRNA.maf
+
+Selects a subset of five sequences optimized to a mean pairwise identity of 70%.
+
+=head1 AUTHORS
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+Ivo Hofacker <ivo@tbi.univie.ac.at>
+
+=cut
diff -ruN RNAz-2.1/perl/rnazSort.pl patched_RNAz/perl/rnazSort.pl
--- RNAz-2.1/perl/rnazSort.pl	2009-08-11 19:29:07.000000000 +0200
+++ patched_RNAz/perl/rnazSort.pl	2018-12-29 16:06:57.503831035 +0100
@@ -1,4 +1,4 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl -w
 
 # $Id: rnazSort.pl,v 1.2 2006/03/24 15:43:14 wash Exp $
 
diff -ruN RNAz-2.1/perl/rnazSort.pl~ patched_RNAz/perl/rnazSort.pl~
--- RNAz-2.1/perl/rnazSort.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazSort.pl~	2009-08-11 19:29:07.000000000 +0200
@@ -0,0 +1,302 @@
+#!/usr/bin/perl -w
+
+# $Id: rnazSort.pl,v 1.2 2006/03/24 15:43:14 wash Exp $
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+
+
+my @fieldsList=qw(windowID locusID seqID start end strand N columns
+				  identity meanMFE consensusMFE energyTerm covarianceTerm combPerPair z SCI decValue P );
+my $reverse=0;
+my $noClusters=0;
+my $version=0;
+my $man=0;
+my $help=0;
+
+GetOptions('reverse' => \$reverse,
+		   'r' => \$reverse,
+		   'no-loci'=>\$noClusters,
+		   'n'=>\$noClusters,
+		   'help'=>\$help,
+		   'h'=>\$help,
+		   'version'=>\$version,
+		   'v'=>\$version,
+		   'man'=>\$man
+		  ) or pod2usage(1);
+
+pod2usage(1) if $help;
+pod2usage(-verbose => 2) if $man;
+
+if ($version){
+  print "\nrnazSort.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+
+my $sortKeyInput= shift @ARGV;
+my $sortKey='';
+
+foreach my $key (@fieldsList){
+  if (lc($key) eq lc($sortKeyInput)){
+	$sortKey=$key;
+	last;
+  }
+}
+
+if (!$sortKey){
+  print STDERR "Unknown sort key.\n";
+  exit(1);
+}
+
+my %clustersHeader=();
+my %clusters=();
+my %hits=();
+
+while (my $line=<>){
+
+  next if $line=~/^\s?\#/;
+  next if $line=~/^\s+$/;
+
+  if ($line=~/^(locus\d+)/){
+	$clustersHeader{$1}=$line;
+  }
+
+  if ($line=~/^(window\d+)\s+(locus\d+)/){
+	$clusters{$2}=[] if !defined $clusters{$2};
+	push @{$clusters{$2}},$1;
+	my %fields;
+	@fields{@fieldsList}=split(/\s+/,$line);
+	$hits{$1}={%fields};
+  }
+}
+
+if (!$noClusters){
+
+  foreach my $windowID (sort sortFunction keys %hits){
+	
+	next if not defined $clusters{$hits{$windowID}->{locusID}};
+	
+	print $clustersHeader{$hits{$windowID}->{locusID}};
+	
+	foreach my $hitInCluster (sort sortFunction @{$clusters{$hits{$windowID}->{locusID}}}){
+	  printLine($hitInCluster);
+	}
+	
+	$clusters{$hits{$windowID}->{locusID}}=undef;
+	
+  }
+} else {
+  foreach my $windowID (sort sortFunction keys %hits){
+	printLine($windowID);
+  }
+}
+
+
+sub sortFunction{
+
+  if ($sortKey eq "windowID" or
+	  $sortKey eq "locusID" or
+	  $sortKey eq "seqID" or
+	  $sortKey eq "strand"){
+	if (!$reverse){
+	  return $hits{$a}->{$sortKey} cmp $hits{$b}->{$sortKey};
+	} else {
+	  return $hits{$b}->{$sortKey} cmp $hits{$a}->{$sortKey};
+	}
+  }
+
+  if ($sortKey eq "start" or
+	  $sortKey eq "end" or
+	  $sortKey eq "z" or
+	  $sortKey eq "meanMFE" or
+	  $sortKey eq "consensusMFE" or
+	  $sortKey eq "energyTerm" or
+	  $sortKey eq "covarianceTerm"){
+	if (!$reverse){
+	  return $hits{$a}->{$sortKey} <=> $hits{$b}->{$sortKey};
+	} else {
+	  return $hits{$b}->{$sortKey} <=> $hits{$a}->{$sortKey};
+	}
+  }
+
+  if ($sortKey eq "N" or
+	  $sortKey eq "columns" or
+	  $sortKey eq "identity" or
+	  $sortKey eq "SCI" or
+	  $sortKey eq "combPerPair" or
+	  $sortKey eq "decValue" or
+	  $sortKey eq "P"){
+	if (!$reverse){
+	  return $hits{$b}->{$sortKey} <=> $hits{$a}->{$sortKey};
+	} else {
+	  return $hits{$a}->{$sortKey} <=> $hits{$b}->{$sortKey};
+	}
+  }
+  return $hits{$a}->{$sortKey}<=>$hits{$b}->{$sortKey};
+}
+
+sub printLine{
+  my $windowID=shift;
+  my @tmp;
+  foreach my $key (@fieldsList){
+	push @tmp, $hits{$windowID}->{$key};
+  }
+  print join("\t",@tmp);
+  print "\n";
+}
+
+__END__
+
+=head1 NAME
+
+C<rnazSort.pl> - Sorts output files from C<rnazCluster.pl> by different criteria
+
+=head1 SYNOPSIS
+
+ rnazSort.pl [options] key [file]
+
+=head1 OPTIONS
+
+=over 8
+
+
+=item B<-r, --reverse>
+
+Sort in reverse order. 
+
+=item B<--no-loci>
+
+Do not preserve the locus grouping but simply sort the windows.
+
+=item B<-v, --version>
+
+Prints version information and exits.
+
+=item B<-h, --help>
+
+Prints a short help message and exits.
+
+=item B<--man>
+
+Prints a detailed manual page and exits.
+
+=back
+
+=head1 DESCRIPTION
+
+C<rnazSort.pl> reads tab-delimited data files as generated by
+C<rnazCluster.pl>. The files are sorted according to a key which is
+given at the command line as a mandatory argument. See below for a
+list of possible keys. By default ``better" hits are listed first
+(e.g. lower z-score or higher P). This can be changed by using the
+C<--reverse> option. By default, the grouping in loci is preserved
+during sorting. For example if you sort by z-score, you get first the
+locus first whicht contains the window with the lowest z-score. If you
+simply want all windows sorted without considering the grouping use
+the C<--no-loci> option.
+
+=head1 FIELDS
+
+=over 8
+
+=item 1. B<windowID>
+
+Consecutive numbered ID for each window. BUG: currently window10 comes
+before window9 because it is sorted alphabetically.
+
+=item 2. B<locusID>
+
+The locus which this window belongs to. BUG: currently locus10 comes
+before locus9 because it is sorted alphabetically.
+
+=item 3. B<seqID>
+
+Identifier of the sequence (e.g. human.chr1 or contig42)
+
+=item 4. B<start>
+
+Start position of the reference sequence in the window
+
+=item 5. B<end>
+
+End position of the reference sequence in the window
+
+=item 6. B<strand>
+
+Indicates if the reference seqeunce is from the positive or
+negative strand
+
+=item 7. B<N>
+
+Number of sequences in the alignment
+
+=item 8. B<columns>
+
+Number of columns in the alignment
+
+=item 9. B<identity>
+
+Mean pairwise identity of the alignment
+
+=item 10. B<meanMFE>
+
+Mean minimum free energy of the single sequences as
+calculated by the RNAfold algorithm
+
+=item 11. B<consensusMFE>
+
+``Consensus MFE" for the alignment as calculated by
+RNAalifold algorithm
+
+=item 12. B<energyTerm>
+
+Contribution to the consensus MFE which comes from the
+energy part of the RNAalifold algorithm
+
+=item 13. B<covarianceTerm>
+
+Contribution to the consensus MFE which comes from the covariance part
+of the RNAalifold algorithm
+
+=item 14. B<combPerPair>
+
+Number of different base combinations per predicted
+pair in the consensus seconary structure
+
+=item 15. B<z>
+
+Mean z-score of the sequences in the alignment
+
+=item 16. B<SCI>
+
+Structure conservation index for the alignment
+
+=item 17. B<decValue>
+
+Support vector machine decision value
+
+=item 18. B<P>
+
+RNA class probability as calculated by the SVM
+
+=back
+
+=head1 EXAMPLES
+
+ # rnazSort.pl combPerPair results.dat
+
+Sort by ``combinations per pair" value, i.e. gives you the hits with
+the most compensatory mutations.
+
+=head1 AUTHOR
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+=cut
+
diff -ruN RNAz-2.1/perl/rnazWindow.pl patched_RNAz/perl/rnazWindow.pl
--- RNAz-2.1/perl/rnazWindow.pl	2010-01-04 16:25:06.000000000 +0100
+++ patched_RNAz/perl/rnazWindow.pl	2018-12-29 16:06:50.462837817 +0100
@@ -1,4 +1,4 @@
-#!/usr/bin/perl -w
+#!/usr/bin/env perl -w
 
 use strict;
 use FindBin;
diff -ruN RNAz-2.1/perl/rnazWindow.pl~ patched_RNAz/perl/rnazWindow.pl~
--- RNAz-2.1/perl/rnazWindow.pl~	1970-01-01 01:00:00.000000000 +0100
+++ patched_RNAz/perl/rnazWindow.pl~	2010-01-04 16:25:06.000000000 +0100
@@ -0,0 +1,541 @@
+#!/usr/bin/perl -w
+
+use strict;
+use FindBin;
+use lib $FindBin::Bin;
+use RNAz;
+use Getopt::Long;
+use Pod::Usage;
+
+my $window        = 120;
+my $slide         = 40;
+my $maxLength     = undef;
+my $minLength     = 50;
+my $maxGap        = 0.25;
+my $maxMasked     = 0.1;
+my $minN          = 2;
+my $maxN          = 6;
+my $numSamples    = 1;
+my $refSeq        = 1;
+my $noReference   = 0;
+my $minID         = 50;
+my $optID         = 80;
+my $maxID         = 100;
+my $forwardStrand = 0;
+my $reverseStrand = 0;
+my $bothStrands   = 0;
+my $verbose       = 0;
+my $version       = 0;
+my $help          = 0;
+my $man           = 0;
+
+GetOptions(
+  'window:i'      => \$window,
+  'w:i'           => \$window,
+  'slide:i'       => \$slide,
+  's:i'           => \$slide,
+  'm:i'           => \$maxLength,
+  'max-length:i'  => \$maxLength,
+  'min-length:i'  => \$minLength,
+  'max-gap:f'     => \$maxGap,
+  'max-masked:f'  => \$maxMasked,
+  'max-seqs:i'    => \$maxN,
+  'num-samples:i' => \$numSamples,
+  'min-seqs:i'    => \$minN,
+  'min-id:f'      => \$minID,
+  'max-id:f'      => \$maxID,
+  'opt-id:f'      => \$optID,
+  'both-strands'  => \$bothStrands,
+  'forward'       => \$forwardStrand,
+  'reverse'       => \$reverseStrand,
+  'no-reference'  => \$noReference,
+  'verbose'       => \$verbose,
+  'help'          => \$help,
+  'man'           => \$man,
+  'h'             => \$help,
+  'version'       => \$version,
+  'v'             => \$version
+) or pod2usage(2);
+
+pod2usage(1) if $help;
+pod2usage( -verbose => 2 ) if $man;
+
+if ($version) {
+  print "\nrnazWindow.pl is part of RNAz $RNAz::rnazVersion\n\n";
+  print "http://www.tbi.univie.ac.at/~wash/RNAz\n\n";
+  exit(0);
+}
+
+# If no strand is specified, default is forward
+$forwardStrand = 1 if ( !$forwardStrand
+  and !$reverseStrand
+  and !$bothStrands );
+
+$refSeq = 0 if ($noReference);
+
+$maxLength = $window if not defined $maxLength;
+
+my $originalWindow = $window; # Save command line option because
+                              # $window is changed for small
+                              # alignments dynamically
+
+my $fileName = shift @ARGV;
+my $fh;
+
+if ( !defined $fileName ) {
+  $fh = *STDIN;
+} else {
+  open( $fh, "<$fileName" ) || die("Could not open file $fileName ($!)");
+}
+
+my $alnFormat = checkFormat($fh);
+
+my $alnCounter = 0;
+
+while ( my $alnString = getNextAln( $alnFormat, $fh ) ) {
+
+  $window = $originalWindow; # reset $window size in case it has been altered 
+
+  $alnCounter++;
+
+  #print STDERR "Processing aln $alnCounter\n";
+
+  my $fullAln = parseAln( $alnString, $alnFormat );
+
+  my @tmp = ();
+  foreach (@$fullAln) {
+    push @tmp, { %{$_} };
+  }
+  my $shrinkingAln = [@tmp];
+
+  my $sliceStart     = 0;
+  my $prevSliceStart = 0;
+  my $sliceEnd       = 0;
+  my $length         = length( $fullAln->[0]->{seq} );
+
+  if ( $length <= $maxLength ) {
+    $window = $length;
+  }
+
+  my $refName = $fullAln->[0]->{name};
+
+  my $windowCounter = 0;
+
+  while ( $sliceStart < $length ) {
+
+    $windowCounter++;
+
+    #print STDERR "Processing window $windowCounter\n";
+
+    $sliceEnd = $sliceStart + $window;
+    if ( $sliceEnd > $length ) {
+      $sliceEnd   = $length;
+      $sliceStart = $length - $window;
+      $sliceStart = 0 if ( $sliceStart < 0 );
+    }
+
+    #my $slice=sliceAlnByColumn($fullAln,$sliceStart,$sliceEnd);
+
+    # correct ends without warning if outside of valid range
+    $sliceStart = 0 if ( $sliceStart < 0 );
+    $sliceEnd = length( $fullAln->[0]->{seq} ) if ( $sliceEnd > length( $fullAln->[0]->{seq} ) );
+
+    # make deep copy of list of hash
+    my @newAln = ();
+    foreach (@$fullAln) {
+      push @newAln, { %{$_} };
+    }
+
+    #print "prev: $prevSliceStart, $sliceStart\n";
+
+    foreach my $i ( 0 .. $#newAln ) {
+
+      if ( ( defined $newAln[$i]->{start} ) and ( defined $newAln[$i]->{start} ) ) {
+        my $oldStart = $newAln[$i]->{start};
+        my $oldEnd   = $newAln[$i]->{end};
+
+        #$newAln[$i]->{start}=alnCol2genomePos($newAln[$i]->{seq},$oldStart,$sliceStart);
+        #$newAln[$i]->{end}=alnCol2genomePos($newAln[$i]->{seq},$oldStart,$sliceEnd-1)+1;
+
+        $newAln[$i]->{start} = alnCol2genomePos(
+          $shrinkingAln->[$i]->{seq},
+          $shrinkingAln->[$i]->{start},
+          $sliceStart - $prevSliceStart, 'after'
+        );
+
+        $newAln[$i]->{end} = alnCol2genomePos(
+          $shrinkingAln->[$i]->{seq},
+          $shrinkingAln->[$i]->{start},
+          $sliceEnd - $prevSliceStart - 1, 'before'
+        ) + 1;
+
+      }
+
+      $newAln[$i]->{seq} = substr( $newAln[$i]->{seq}, $sliceStart, $sliceEnd - $sliceStart );
+
+    }
+
+    my $slice = [@newAln];
+
+    my $sliceLength = $sliceEnd - $sliceStart;
+
+    foreach my $i ( 0 .. @{$shrinkingAln} - 1 ) {
+
+      $shrinkingAln->[$i]->{seq} =
+        substr( $fullAln->[$i]->{seq}, $sliceStart, $length - $sliceStart );
+      $shrinkingAln->[$i]->{start} = $slice->[$i]->{start};
+    }
+
+    #	print "BEFORE:\n";
+    #	print(formatAln($slice,"CLUSTAL"));
+
+    if ($refSeq) {
+      my $numGaps = ( $slice->[0]->{seq} =~ tr/-./-/ );
+
+      if ( $numGaps / $sliceLength > $maxGap ) {
+        $slice->[0] = undef;
+
+        if ($verbose) {
+          print STDERR
+            "Alignment $alnCounter, window $windowCounter: Removing seq 1: too many gaps.\n";
+        }
+      } else {
+
+        for my $i ( 1 .. @$slice - 1 ) {
+
+          my @tmpAln = ( { seq => $slice->[0]->{seq} }, { seq => $slice->[$i]->{seq} } );
+
+          removeCommonGaps( \@tmpAln );
+
+          my $numGaps0 = ( $tmpAln[0]->{seq} =~ tr/-./-/ );
+          my $numGaps1 = ( $tmpAln[1]->{seq} =~ tr/-./-/ );
+
+          my $tmpLength = length( $tmpAln[0]->{seq} );
+
+          if ( ( $numGaps0 + $numGaps1 ) / $tmpLength > $maxGap ) {
+            $slice->[$i] = undef;
+            if ($verbose) {
+              my $ii = $i + 1;
+              print STDERR
+                "Alignment $alnCounter, window $windowCounter: Removing seq $ii: too many gaps.\n";
+            }
+          }
+        }
+      }
+    } else {
+      for my $i ( 0 .. @$slice - 1 ) {
+        my $numGaps = ( $slice->[$i]->{seq} =~ tr/-./-/ );
+        if ( $numGaps / $sliceLength > $maxGap ) {
+          $slice->[$i] = undef;
+          if ($verbose) {
+            my $ii = $i + 1;
+            print STDERR
+              "Alignment $alnCounter, window $windowCounter: Removing seq $ii: too many gaps.\n";
+          }
+        }
+      }
+    }
+
+    for my $i ( 0 .. @$slice - 1 ) {
+      next if not defined $slice->[$i];
+      my $numMasked = ( $slice->[$i]->{seq} =~ tr/a-z/a-z/ );
+      if ( $numMasked / $sliceLength > $maxMasked ) {
+        $slice->[$i] = undef;
+        if ($verbose) {
+          my $ii = $i + 1;
+          print STDERR
+            "Alignment $alnCounter, window $windowCounter: Removing seq $ii: too many masked letters.\n";
+        }
+      }
+    }
+
+    for my $i ( 0 .. @$slice - 1 ) {
+      next if not defined $slice->[$i];
+      my $tmpSeq = $slice->[$i]->{seq};
+
+      #print $tmpSeq, ":",rangeWarn([{seq=>$tmpSeq}]),"\n";
+      my $warning = rangeWarn( [ { seq => $tmpSeq } ] );
+      if ($warning) {
+        $slice->[$i] = undef;
+        if ($verbose) {
+          my $ii = $i + 1;
+          if ( $warning == 1 ) {
+            print STDERR
+              "Alignment $alnCounter, window $windowCounter: Removing seq $ii: too short.\n";
+          }
+          if ( $warning == 2 ) {
+            print STDERR
+              "Alignment $alnCounter, window $windowCounter: Removing seq $ii: base composition out of range.\n";
+          }
+          if ( $warning == 3 ) {
+            print STDERR
+              "Alignment $alnCounter, window $windowCounter: Removing seq $ii: base composition out of range/too short.\n";
+          }
+        }
+      }
+    }
+
+    my @tmp;
+    foreach (@$slice) {
+      next if ( !defined $_ );
+      push @tmp, $_;
+    }
+    $slice = \@tmp;
+
+    # Nothing left
+    if ( !@$slice ) {
+      if ($verbose) {
+        print STDERR "Alignment $alnCounter discarded: No sequences left.\n";
+      }
+      goto SKIP;
+    }
+
+    # Reference sequence discarded
+    if ( ($refSeq) and ( $slice->[0]->{name} ne $refName ) ) {
+      if ($verbose) {
+        print STDERR
+          "Alignment $alnCounter discarded: Reference sequence was discarded in previous filter steps.\n";
+      }
+      goto SKIP;
+    }
+
+    # Too few sequences
+    if ( @$slice < $minN ) {
+      if ($verbose) {
+        print STDERR "Alignment $alnCounter discarded: Too few sequences left.\n";
+      }
+      goto SKIP;
+    }
+
+    removeCommonGaps($slice);
+
+    if ( $alnFormat eq "CLUSTAL" ) {
+
+      for my $i ( 0 .. @$slice - 1 ) {
+        $slice->[$i]->{start}  = $sliceStart;
+        $slice->[$i]->{end}    = $sliceEnd;
+        $slice->[$i]->{strand} = '+';
+      }
+    }
+
+    my $slices;
+
+    if ( @$slice > $maxN ) {
+
+      $slices = pruneAln(
+        alnRef    => $slice,
+        maxN      => $maxN,
+        minN      => 2,
+        optSim    => $optID / 100,
+        maxID     => $maxID / 100,
+        numAln    => $numSamples,
+        keepfirst => $refSeq
+      );
+    } else {
+
+      $slices = [$slice];
+
+    }
+
+    foreach my $slice (@$slices) {
+
+      if ( length( $slice->[0]->{seq} ) < $minLength ) {
+        if ($verbose) {
+          print STDERR "Alignment $alnCounter discarded: Too short.\n";
+        }
+        next;
+      }
+
+      if ( meanPairID($slice) * 100 < $minID ) {
+        if ($verbose) {
+          print STDERR "Alignment $alnCounter discarded: Mean pairwise identity out of range.\n";
+        }
+        next;
+      }
+
+      my @strands = ();
+
+      push @strands, '+' if $forwardStrand;
+      push @strands, '-' if $reverseStrand;
+
+      @strands = ( '+', '-' ) if $bothStrands;
+
+      foreach my $strand (@strands) {
+
+        if ( $strand eq '-' ) {
+          $slice = revAln($slice);
+        }
+
+        #print "\n\nAFTER:\n\n";
+
+        print formatAln( $slice, $alnFormat );
+      }
+    }
+
+  SKIP:
+    $prevSliceStart = $sliceStart;
+    $sliceStart += $slide;
+    last if ( $sliceEnd == $length );
+  }
+}
+
+__END__
+
+=head1 NAME
+
+C<rnazWindow.pl> - Slice alignments in overlapping windows and
+process/filter alignment windows in various ways.
+
+=head1 SYNOPSIS
+
+ rnazWindow.pl [options] [file]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<-w, --window>=N
+
+Size of the window (Default: B<120>)
+
+=item B<-s, --slide>=N
+
+Step size (Default: B<120>)
+
+=item B<-m, --max-length>
+
+Slice only alignments longer than N columns. This means blocks longer
+than the window size given by B<--window> but shorter than N are kept
+intact and not sliced. Per default this length is set to the window
+size given by B<--window> (or 120 by default).
+
+=item B<--max-gap>=X
+
+Maximum fraction of gaps. If a reference sequence is used
+(i.e. C<--no-reference> is not set), each sequence is compared to the
+reference sequence and if in the pairwise comparison the fraction of
+columns with gaps is higher than X the sequence is discarded. If no
+reference sequence is used, all sequences with a fraction of gaps
+higher than X are discarded. (Default: B<0.25>)
+
+=item B<--max-masked>=X
+
+Maximum fraction of masked (=lowercase letters) in a sequence. All
+sequences with a fraction of more than X lowercase letters are
+discarded. This is usually used for excluding repeat sequences marked
+by C<RepeatMasker> but any other information can be encoded by using
+lowercase letters. (Default: B<0.1>)
+
+=item B<--min-id>=X
+
+Discard alignment windows with an overall mean pairwise identity
+smaller than X%. (Default: B<50>)
+
+=item B<--min-seqs>=N
+
+Minimum number of sequences in an alignment. Discard any windows with
+less than N sequences (Default:B<2>).
+
+=item B<--max-seqs>=N
+
+Maximum number of sequences in an alignment. If the number of
+sequences in a window is higher than N, a subset of sequences is used
+with exactly N sequences. The greedy algorithm of the program
+C<rnazSelectSeqs.pl> is used which optimizes for a user specified mean
+pairwise identity (see C<--opt-id>). (Default: B<6>)
+
+=item B<--num-samples>=N
+
+Number of different subsets of sequences that is sampled if there are
+more sequences in the alignment than C<--max-seqs>. (Default: B<1>)
+
+=item B<--min-length>=N
+
+Minimum number of columns of an alignment slice. After removing
+sequences from the alignment, ``all-gap" columns are removed. If the
+resulting alignment has fewer than N columns, the complete alignment
+is discarded.
+
+=item B<--opt-id>=X
+
+If the number of sequences has to be reduced (see C<--max-seqs>) a
+subset of sequences is chosen which is optimized for this value of
+mean pairwise identity. (In percent, default: B<80>)
+
+=item B<--max-id>=X
+
+One sequence from pairs with pairwise identity higher than X % this is
+removed (default: B<99>, i.e. only almost identical sequences are
+removed) B<NOT IMPLEMENTED>
+
+=item B<--forward>
+
+=item B<--reverse>
+
+=item B<--both-strands>
+
+Output forward, reverse complement or both of the sequences in the
+windows. Please note: C<RNAz> has the same options, so if you use
+C<rnazWindow.pl> for an RNAz screen, we recommend to set the option
+directly in C<RNAz> and leave the default here. (Default:
+-B<--forward>)
+
+=item B<--no-reference>
+
+By default the first sequence is interpreted as reference
+sequence. This means, for example, that if the reference sequence is
+removed during filtering steps the complete alignment is
+discarded. Also, if there are too many sequences in the alignment, the
+reference sequence is never removed when choosing an appropriate
+subset. Having a reference sequence is crucial if you are doing
+screens of genomic regions. For some other applications it might not
+be necessary and in such cases you can change the default behaviour by
+setting this option.
+
+=item B<--verbose>
+
+Verbose output on STDERR, describing all performed filtering steps.
+
+=item B<-v, --version>
+
+Prints version information and exits.
+
+=item B<-h, --help>
+
+Prints a short help message and exits.
+
+=item B<--man>
+
+Prints a detailed manual page and exits.
+
+=back
+
+=head1 DESCRIPTION
+
+In many cases it is necessary to slice, pre-process and filter
+alignments to get the optimal input for RNAz. This can be a tedious
+task if you have a large number of alignments to analyze. This program
+performs the most common pre-processing and filtering steps.
+
+Basically it slices the input alignments (C<CLUSTAL W> or C<MAF>
+format) in overlapping windows. The resulting alignments windows are
+further processed and only ``reasonable" alignment windows are finally
+printed out, i.e. not too much gaps/repeats, not too few or too many
+sequences...
+
+=head1 EXAMPLES
+
+ # rnazWindow.pl --min-seqs=4 some.aln
+
+Slices the alignment -C<some.aln> in overlapping windows of size 120,
+slide 40 and filters the windows for an optimal input to RNAz
+(=default behaviour). Only alignments with at least four sequences
+are printed.
+
+=head1 AUTHORS
+
+Stefan Washietl <wash@tbi.univie.ac.at>
+
+=cut
+
+
diff -ruN RNAz-2.1/rnaz/Makefile.am patched_RNAz/rnaz/Makefile.am
--- RNAz-2.1/rnaz/Makefile.am	2009-06-04 13:45:10.000000000 +0200
+++ patched_RNAz/rnaz/Makefile.am	2018-12-28 15:58:37.744444795 +0100
@@ -2,11 +2,11 @@
 
 RNAz_SOURCES=RNAz.c rnaz_utils.c svm_helper.c rnaz_utils.h svm_helper.h zscore.c zscore.h cmdline.c cmdline.h strand.c strand.h  ../models/mfe_avg.inc  ../models/mfe_stdv.inc  ../models/strand.inc ../models/decision.inc 
 
-nodist_RNAz_SOURCES=../libsvm-2.89/svm.cpp 
+nodist_RNAz_SOURCES=${PREFIX}/lib/libsvm-3.21/svm.cpp 
 
 LDADD = -L../librna -lRNA -lm
  
 RNAz_LINK = $(CXX) -o $@
  
-INCLUDES = -I../librna -I../libsvm-2.89 -I../models
+INCLUDES = -I../librna -I${PREFIX}/lib/libsvm-3.21 -I../models
 
diff -ruN RNAz-2.1/rnaz/strand.c patched_RNAz/rnaz/strand.c
--- RNAz-2.1/rnaz/strand.c	2009-08-19 14:04:39.000000000 +0200
+++ patched_RNAz/rnaz/strand.c	2018-12-28 15:54:20.928697847 +0100
@@ -123,9 +123,9 @@
 	    ++j;
 	}
 	singleMFE = fold(woGapsSeq, singleStruc);
-	singleZ=mfe_zscore(woGapsSeq,singleMFE,z_score_type,0,warningString_strand);
+	singleZ=mfe_zscore(woGapsSeq,singleMFE,&z_score_type,0,warningString_strand);
 	singleMFE_reverse = fold(woGapsSeq_reverse, singleStruc_reverse);
-	singleZ_reverse=mfe_zscore(woGapsSeq_reverse,singleMFE_reverse,z_score_type,0,warningString_strand);
+	singleZ_reverse=mfe_zscore(woGapsSeq_reverse,singleMFE_reverse,&z_score_type,0,warningString_strand);
 	sumZ+=singleZ;
 	sumMFE+=singleMFE;
 	sumZ_reverse+=singleZ_reverse;
diff -ruN RNAz-2.1/rnaz/svm_helper.c patched_RNAz/rnaz/svm_helper.c
--- RNAz-2.1/rnaz/svm_helper.c	2009-08-17 13:09:57.000000000 +0200
+++ patched_RNAz/rnaz/svm_helper.c	2018-12-28 15:52:50.052787389 +0100
@@ -251,6 +251,7 @@
 */
 
 
+/*
 struct svm_model{
   struct svm_parameter param;
   int nr_class;
@@ -263,7 +264,8 @@
   int *label;
   int *nSV;
   int free_sv;
-};
+  };
+*/
 
 struct svm_model* svm_load_model_string(char *modelString){
 
diff -ruN RNAz-2.1/rnaz/svm_helper.h patched_RNAz/rnaz/svm_helper.h
--- RNAz-2.1/rnaz/svm_helper.h	2009-08-17 13:09:52.000000000 +0200
+++ patched_RNAz/rnaz/svm_helper.h	2018-12-28 15:51:32.059864233 +0100
@@ -11,6 +11,7 @@
  *                                                                   *
  *********************************************************************/
 
+#define svm_destroy_model(A) svm_free_model_content((A))
 
 void get_regression_models(struct svm_model** avg_model,
 			   struct svm_model** stdv_model,
